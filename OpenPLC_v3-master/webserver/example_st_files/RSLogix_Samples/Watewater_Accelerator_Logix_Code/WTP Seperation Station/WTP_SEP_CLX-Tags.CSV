remark,"CSV-Import-Export"
remark,"Date = Mon Jul 27 11:25:31 2009"
remark,"Version = RSLogix 5000 v17.00"
remark,"Owner = user"
remark,"Company = tetratech"
0.3
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,,Local:2:C,"","AB:1756_DI:C:0","",""
TAG,,Local:2:I,"","AB:1756_DI:I:0","",""
COMMENT,,Local:2:I,"Rapid Mix Basin Drive $NIn-Auto",,"Local:2:I.DATA.0"
COMMENT,,Local:2:I,"Rapid Mix Basin Drive $NRunning",,"Local:2:I.DATA.1"
COMMENT,,Local:2:I,"Rapid Mix Basin Drive $NTorque",,"Local:2:I.DATA.2"
COMMENT,,Local:2:I,"Sedimentation Basin #1 Drive$NIn-Auto",,"Local:2:I.DATA.3"
COMMENT,,Local:2:I,"Sedimentation Basin #1 Drive $NRunning",,"Local:2:I.DATA.4"
COMMENT,,Local:2:I,"Sedimentation Basin #1 Drive $NTorque",,"Local:2:I.DATA.5"
COMMENT,,Local:2:I,"PV-1200 $NIn-Auto",,"Local:2:I.DATA.6"
TAG,,Local:3:C,"","AB:1756_DO:C:0","",""
TAG,,Local:3:I,"","AB:1756_DO:I:0","",""
TAG,,Local:3:O,"","AB:1756_DO:O:0","",""
COMMENT,,Local:3:O,"Rapid Mix Basin #1 Drive$NStart/Stop",,"Local:3:O.DATA.0"
COMMENT,,Local:3:O,"Sedimentation Basin #1 Drive$NStart/Stop",,"Local:3:O.DATA.1"
TAG,,Local:4:C,"","AB:1756_IF4_Float:C:0","",""
TAG,,Local:4:I,"","AB:1756_IF4_Float:I:0","",""
COMMENT,,Local:4:I,"Sedimentation Basin Level Indication (LIT-1204) 0-15 Ft",,"Local:4:I.CH0DATA"
COMMENT,,Local:4:I,"To Rapid Mix Basin Flow (FIT-1200) 0-2 MGD",,"Local:4:I.CH1DATA"
COMMENT,,Local:4:I,"PV-1200 Position Indication 0-100%",,"Local:4:I.CH2DATA"
TAG,,Local:5:C,"","AB:1756_OF4_Float:C:0","",""
TAG,,Local:5:I,"","AB:1756_OF4_Float:I:0","",""
TAG,,Local:5:O,"","AB:1756_OF4_Float:O:0","",""
COMMENT,,Local:5:O,"PV-1200 Position Command 0-100%",,"Local:5:O.CH0DATA"
TAG,,WTP_FlocBsn01_M1202:I,"","AB:PowerFlex700VC_FE642F8C:I:0","",""
TAG,,WTP_FlocBsn01_M1202:O,"","AB:PowerFlex700VC_4C9688FB:O:0","",""
TAG,,FlocBsn01_M1202_Intlk,"","P_Intlk","",""
TAG,,FlocBsn01_M1202_Perm,"","P_Perm","",""
TAG,,FlocBsn01_M1202_Reset,"","P_Reset","",""
TAG,,FlocBsn01_M1202_ResInh,"","P_ResInh","",""
TAG,,FlocBsn01_M1202_RunTime,"","P_RunTime","",""
TAG,,FlocBsn01_M1202_VSD,"Secondary Treatment RAS Pump #401$NVariable Speed Drive","P_VSD","",""
ALIAS,,I_SedBsn01Drv_InAuto,"","","Local:2:I.Data.3","(RADIX := Decimal)"
ALIAS,,I_SedBsn01Drv_InAuto_IOFault,"","","Local:2:I.Fault.3","(RADIX := Decimal)"
ALIAS,,I_SedBsn01Drv_RunFdbk,"","","Local:2:I.Data.4","(RADIX := Decimal)"
ALIAS,,I_SedBsn01Drv_RunFdbk_IOFault,"","","Local:2:I.Fault.4","(RADIX := Decimal)"
ALIAS,,I_SedBsn01Drv_Torque,"","","Local:2:I.Data.5","(RADIX := Decimal)"
ALIAS,,I_SedBsn01Drv_Torque_IOFault,"","","Local:2:I.Fault.5","(RADIX := Decimal)"
ALIAS,,I_SedBsn01_Lv,"","","Local:4:I.CH0DATA","(RADIX := Float)"
ALIAS,,I_SedBsn01_Lv_IOFault,"","","Local:4:I.Ch0Fault","(RADIX := Decimal)"
ALIAS,,O_SedBsn01Drv_Out_Run,"","","Local:3:O.Data.1","(RADIX := Decimal)"
TAG,,PLC_CommFail,"","U_CommFail","",""
TAG,,PLC_Device_ResetPB,"Site Wide Device Reset Push Button","BOOL","","(RADIX := Decimal)"
TAG,,PLC_Heartbeat,"PLC Heartbeat","U_Heartbeat","",""
TAG,,PLC_Simulation,"Application running IN SIMULATION","BOOL","","(RADIX := Decimal)"
TAG,,PLC_WallClock,"Wall Clock","U_WallClock","",""
TAG,,SedBsn01Drv_Intlk,"Sedimentation Basin #1 Drive$NInterlocks","P_Intlk","",""
TAG,,SedBsn01Drv_Motor,"Sedimentation Basin #1 Drive$NMotor","P_Motor","",""
TAG,,SedBsn01Drv_Perm,"Sedimentation Basin #1 Drive$NPermissives","P_Perm","",""
TAG,,SedBsn01Drv_Reset,"Sedimentation Basin #1 Drive$NReset","P_Reset","",""
TAG,,SedBsn01Drv_ResInh,"Sedimentation Basin #1 Drive$NRestart Inhibit","P_ResInh","",""
TAG,,SedBsn01Drv_RunTime,"Sedimentation Basin #1 Drive$NRuntime & Starts","P_RunTime","",""
TAG,,SedBsn01Drv_Torque,"Sedimentation Basin #1 Drive$NTorque","P_DIn","",""
TAG,,SedBsn01_Lv,"Sedimentation Basin Level Indication (LIT-1204) 0 - 15 Ft","P_AIn","",""
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
ALIAS,FlocBsn01_M1202,Equip_GroupReset,"","","PLC_Device_ResetPB","(RADIX := Decimal)"
ALIAS,FlocBsn01_M1202,Equip_Intlk,"","","FlocBsn01_M1202_Intlk",""
TAG,FlocBsn01_M1202,Equip_IOFault,"","BOOL","","(RADIX := Decimal)"
ALIAS,FlocBsn01_M1202,Equip_Motor,"","","FlocBsn01_M1202_VSD",""
ALIAS,FlocBsn01_M1202,Equip_VFD_I,"","","WTP_FlocBsn01_M1202:I",""
ALIAS,FlocBsn01_M1202,Equip_VFD_O,"","","WTP_FlocBsn01_M1202:O",""
TAG,FlocBsn01_M1202,Wrk_Hand,"","BOOL","","(RADIX := Decimal)"
TAG,FlocBsn01_M1202,Wrk_ResetReqd,"","BOOL","","(RADIX := Decimal)"
TAG,FlocBsn01_M1202,Wrk_ResetRequired,"","BOOL","","(RADIX := Decimal)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
ALIAS,SedBasin01Drive,Equip_GroupReset,"","","PLC_Device_ResetPB","(RADIX := Decimal)"
ALIAS,SedBasin01Drive,Equip_InAuto,"","","I_SedBsn01Drv_InAuto","(RADIX := Decimal)"
ALIAS,SedBasin01Drive,Equip_InAuto_IOFault,"","","I_SedBsn01Drv_InAuto_IOFault","(RADIX := Decimal)"
ALIAS,SedBasin01Drive,Equip_Intlk,"","","SedBsn01Drv_Intlk",""
TAG,SedBasin01Drive,Equip_IOFault,"","BOOL","","(RADIX := Decimal)"
ALIAS,SedBasin01Drive,Equip_Motor,"","","SedBsn01Drv_Motor",""
ALIAS,SedBasin01Drive,Equip_Out_Run,"","","O_SedBsn01Drv_Out_Run","(RADIX := Decimal)"
ALIAS,SedBasin01Drive,Equip_RunFdbk,"","","I_SedBsn01Drv_RunFdbk","(RADIX := Decimal)"
ALIAS,SedBasin01Drive,Equip_RunFdbk_IOFault,"","","I_SedBsn01Drv_RunFdbk_IOFault","(RADIX := Decimal)"
ALIAS,SedBasin01Drive,Equip_Torque,"","","I_SedBsn01Drv_Torque","(RADIX := Decimal)"
ALIAS,SedBasin01Drive,Equip_Torque_IOFault,"","","I_SedBsn01Drv_Torque_IOFault","(RADIX := Decimal)"
TAG,SedBasin01Drive,Wrk_Hand,"","BOOL","","(RADIX := Decimal)"
TAG,SedBasin01Drive,Wrk_ResetReqd,"","BOOL","","(RADIX := Decimal)"
TAG,SedBasin01Drive,Wrk_ResetRequired,"","BOOL","","(RADIX := Decimal)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_AIn:AOI,Inp_PV,"Input Signal (process variable) from Sensor","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,P_AIn:AOI,Inp_PVBad,"1=PV or I/O Comms Status Bad, 0=OK","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Inp_PVUncertain,"1=PV Value Not Reliable, 0=OK","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Inp_Sim,"1=Use simulated PV (Set_SimPV); 0=Use Input (Inp_PV)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Inp_Reset,"1=Reset all Alarms requiring reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_NoSubstPV,"1=Disallow selection of Substitute PV","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_SetTrack,"1=PSets track OSets in Oper, OSets track PSets in Prog, 0=no tracking","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HasHiHiAlm,"1=High-High Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HasHiAlm,"1=High Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HasLoAlm,"1=Low Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HasLoLoAlm,"1=Low-Low Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HasFailAlm,"1=Analog Input Failure Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiHiResetReqd,"1=Reset required to clear High-High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiResetReqd,"1=Reset required to clear High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoResetReqd,"1=Reset required to clear Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoLoResetReqd,"1=Reset required to clear Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailResetReqd,"1=Reset required to clear Analog InputFailure Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiHiAckReqd,"1=Acknowledge required for High-High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiAckReqd,"1=Acknowledge required for High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoAckReqd,"1=Acknlowledge required for Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoLoAckReqd,"1=Acknowledge required for Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailAckReqd,"1=Acknowledge required for Analog Input Failure Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiHiSeverity,"High-High Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiSeverity,"High Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoSeverity,"Low Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoLoSeverity,"Low-Low Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailSeverity,"Failure Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_InpRawMin,"Input (unscaled) Minimum for Scaling","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_InpRawMax,"Input (unscaled) Maximum for Scaling","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_PVEUMin,"PV (Output) Minimum for Scaling to EU","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_PVEUMax,"PV (Output) Maximum for Scaling to EU","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FiltTC,"PV Filter Time Constant (sec),$N0.0 = unfiltered","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiHiDB,"High-High Alarm Deadband (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiHiMinDuration,"Minimum time above High-High Limit to raise Alarm (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiDB,"High Alarm Deadband (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiMinDuration,"Minimum time above High Limit to raise Alarm (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoDB,"Low Alarm Deadband (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoMinDuration,"Minimum time below Low Limit to raise Alarm (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoLoDB,"Low-Low Alarm Deadband (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoLoMinDuration,"Minimum time below Low-Low Limit to raise Alarm (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailHiLim,"Out-of-Range (fail) High Limit (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailLoLim,"Out-of-Range (fail) Low Limit (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailDB,"Out-of-Range (fail) High/Low Deadband (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailMinDuration,"Minimum time Bad or Out of Range to raise Fail Alarm (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PSet_Owner,"Program Owner Request ID (non-zero) or Release (zero)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PSet_HiHiLim,"Program-Entered High-High Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PSet_HiLim,"Program-Entered High Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PSet_LoLim,"Program-Entered Low Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PSet_LoLoLim,"Program-Entered Low-Low Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,MSet_SubstPV,"Maintenance-Entered Substitute PV (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,OSet_HiHiLim,"Operator-Entered High-High Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,OSet_HiLim,"Operator-Entered High Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,OSet_LoLim,"Operator-Entered Low Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,OSet_LoLoLim,"Operator-Entered Low-Low Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Set_SimPV,"PV used in Simulation (Inp_Sim=1) (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_Acq,"Program Command to Acquire ownership (Oper to Prog)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_Rel,"Program Command to Release ownership (Prog to Oper)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_Lock,"Program Command to Lock Mode in Prog","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_Unlock,"Program Command to Unlock Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_Reset,"Program Command to Reset all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiHiAck,"Program Command to Acknowledge High-High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiHiInhibit,"Program Command to Inhibit High-High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiHiUninhibit,"Program Command to UninhibitHigh-High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiAck,"Program Command to Acknowledge High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiInhibit,"Program Command to Inhibit High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiUninhibit,"Program Command to Uninhibit High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoAck,"Program Command to Acknowledge Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoInhibit,"Program Command to Inhibit Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoUninhibit,"Program Command to Uninhibit Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoLoAck,"Program Command to Acknowledge Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoLoInhibit,"Program Command to Inhibit Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoLoUninhibit,"Program Command to Uninhibit Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_FailAck,"Program Command to Acknowldege Analog Input Failure Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_FailInhibit,"Program Command to Inhibit Analog Input Failure Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_FailUninhibit,"Program Command to Uninhibit Analog Input Failure Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,MCmd_SubstPV,"Maintenance Command to use Substitute PV (override input)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,MCmd_InpPV,"Maintenance Command to use Input PV (normal)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,OCmd_Reset,"Operator Command to Reset all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Val,"Analog Value (after Substitute PV, if used)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Val_InpPV,"Analog Input Value (actual, before Substitute PV selection)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Val_PVEUMin,"Minimum of scaled range = MIN (Cfg_PVEUMin, Cfg_PVEUMax)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Val_PVEUMax,"Maximum of scaled range = MAX (Cfg_PVEUMin, Cfg_PVEUMax)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Val_Owner,"Current Object Owner ID (0=not owned)","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Val_Notify,"Current Alarm Level and Acknowledgement (enumeration)","SINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Val_HiHiLim,"Current High-High Alarm Threshold","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Val_HiLim,"Current High Alarm Threshold","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Val_LoLim,"Current Low Alarm Threshold","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Val_LoLoLim,"Current Low-Low Alarm Threshold","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Sts_SubstPV,"1=Using Substitute PV (Input being overridden)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_InpPV,"1=Using Input PV (normal)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_PVBad,"1=PV Bad quality or Out of Range","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_PVUncertain,"1=PV Value is Uncertain (quality)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Err,"1=Error in Config, see detail Err_ bits for reason","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Err_Raw,"1=Error in Config: Raw Input Scaling Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Err_EU,"1=Error in Config: Scaled EU Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Err_Filt,"1=Error in Config: PV filter params (RateTime, TC)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Err_DB,"1=Error in Config: an Alarm Deadband is < 0.0","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Err_Alarm,"1=Error in Config: Invalid Alarm Min Duration or Severity","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Maint,"1=Mode is Maintenance (supersedes Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Prog,"1=Mode is Program","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Oper,"1=Mode is Operator","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_ProgOperLock,"1=Program or Operator has requested Mode Lock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiHi,"1=Analog Input is above High-High limit","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Alm_HiHi,"1=Analog Input is in High-High Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Ack_HiHi,"1=High-High Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiHiDisabled,"1=High-High Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiHiInhibited,"1=High-High Alarm is Inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiHiSuppressed,"1=High-High Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Hi,"1=Analog Input is above High limit","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Alm_Hi,"1=Analog Input is in High Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Ack_Hi,"1=High Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiDisabled,"1=High Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiInhibited,"1=High Alarm is Inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiSuppressed,"1=High Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Lo,"1=Analog Input is below Low limit","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Alm_Lo,"1=Analog Input is in Low Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Ack_Lo,"1=Low Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoDisabled,"1=Low Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoInhibited,"1=Low Alarm is Inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoSuppressed,"1=Low Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoLo,"1=Analog Input is below Low-Low limit","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Alm_LoLo,"1=Analog Input is in Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Ack_LoLo,"1=Low-Low Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoLoDisabled,"1=Low-Low Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoLoInhibited,"1=Low-Low Alarm is Inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoLoSuppressed,"1=Low-Low Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Fail,"1=Analog Input is Out of Range or PV Bad","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Alm_Fail,"1=Analog Input Failure Alarm (Bad or Out of Range)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Ack_Fail,"1=Analog Input Failure Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_FailDisabled,"1=Analog input Failure Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_FailInhibited,"1=Analog Input Failure Alarm is inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_FailSuppressed,"1=Analog Input Failure Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Rdy_SubstPV,"1=Ready for MCmd_SubstPV","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Rdy_InpPV,"1=Ready for MCmd_InpPV","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Rdy_Reset,"1=At least one Alarm requires Reset","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,LoLo,"Low-Low Alarm","P_Alarm","","(Usage := Local)"
TAG,P_AIn:AOI,Lo,"Low Alarm","P_Alarm","","(Usage := Local)"
TAG,P_AIn:AOI,Hi,"High Alarm","P_Alarm","","(Usage := Local)"
TAG,P_AIn:AOI,HiHi,"High-High Alarm","P_Alarm","","(Usage := Local)"
TAG,P_AIn:AOI,Mode,"Analog Input Mode Selection","P_Mode","","(Usage := Local)"
TAG,P_AIn:AOI,Cfg_EU,"Engineering Units for display on HMI","STRING_8","","(Usage := Local)"
TAG,P_AIn:AOI,Cfg_Tag,"Tagname for display on HMI","STRING_20","","(Usage := Local)"
TAG,P_AIn:AOI,Cfg_Label,"Label for graphic symbol displayed on HMI","STRING_20","","(Usage := Local)"
TAG,P_AIn:AOI,Cfg_Desc,"Description for display on HMI","STRING_40","","(Usage := Local)"
TAG,P_AIn:AOI,Fail,"Analog Input Failure Alarm (bad quality or out of range)","P_Alarm","","(Usage := Local)"
TAG,P_AIn:AOI,Wrk_Notify,"Buffer for building Val_Notify","SINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_AIn:AOI,Wrk_SubstPV,"Internal flag: Using Substitute PV","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_AIn:AOI,Wrk_UnfiltPV,"Unfiltered PV, input to 1st order filter","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_AIn:AOI,Wrk_Alpha,"Filter multiplier = (1 / (1+TC/dT) )","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_AIn:AOI,Wrk_ScanT,"Scan Timer (milliseconds, always runs)","TIMER","","(Usage := Local)"
TAG,P_AIn:AOI,Wrk_ScanTime,"Time since this instance was last scanned","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_AIn:AOI,Wrk_FiltPV,"Filtered PV","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_AIn:AOI,Wrk_InpDINT,"Input REAL bit pattern as a DINT (check for Inf/NaN)","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_AIn:AOI,Wrk_InpInfNaN,"Input is Infinite or Not a Number","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_AIn:AOI,Wrk_ValidONS,"Selected PV goes from Infinite or Not a Number to VALID","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_AIn:AOI,Wrk_SelPVDINT,"Selected PV check for Infinite or Non A Number","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_AIn:AOI,Wrk_SelPVInfNaN,"Selected PV (Input or Substitute) is Infinite or NaN","BOOL","","(RADIX := Decimal, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Alarm:AOI,Inp,"Alarm Condition Input 1=Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Inp_Reset,"1=Reset Alarm requiring reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Cfg_ResetReqd,"1=Reset required to clear Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Cfg_AckReqd,"1=Acknowledge required for Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Cfg_Severity,"1=Info Only; 2=Warning; 3=Process Exception; 4=Fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Cfg_MinDuration,"Minimum time (sec) Input must stay on to generate Alarm","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,PCmd_Reset,"Program Command to Reset latched alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,PCmd_Ack,"Program Command to Acknowledge alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,PCmd_Inhibit,"Program Command to Inhibit alarm (force Alm to 0)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,PCmd_Uninhibit,"Program Command to Uninhibit alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,OCmd_Reset,"Operator Command to Reset latched alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,OCmd_Ack,"Operator Command to Acknowledge alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,OCmd_Disable,"Operator Command to Disable alarm (force Alm to 0)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,OCmd_Enable,"Operator Command to Enable alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Val_Notify,"Current Alarm Level and Acknowledgement (enumeration)","SINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Alm,"Alarm output 1=In Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Ack,"Alarm acknowledged status: 1=Ack rcvd","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Disabled,"1=Alarm has been Disabled by Operator (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Inhibited,"1=Alarm has been Inhibited by logic (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Suppressed,"1=Alarm has been suppressed (not visible on HMI)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Sts_Err,"1=Error in Config: see detail Err_ bits for reason","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Err_MinDuration,"1=Error in Config: Invalid Min Duration (use 0 to 2147483)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Err_Severity,"1=Error in Config: Invalid Severity (use 1 to 4)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Rdy_Reset,"Ready to receive OCmd_Reset (enable button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Rdy_Ack,"Ready to receive OCmd_Ack (enable button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Rdy_Disable,"Ready to receive OCmd_Disable (enable button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Rdy_Enable,"Ready to receive OCmd_Enable (enable button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Wrk_MinDurationT,"Alarm Condition Minimum Duration Timer","TIMER","","(Usage := Local)"
TAG,P_Alarm:AOI,Wrk_Alm,"Internal Alarm Status","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Alarm:AOI,Wrk_Inhibited,"Internal Alarm Inhibit Status","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Alarm:AOI,Wrk_AlmMinOnT,"Alarm output minimum ON time to be seen by alarm server","TIMER","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_DIn:AOI,Inp_PV,"Input Signal (process variable) from Sensor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_DIn:AOI,Inp_PVBad,"Input Comm Status or Quality 1=Bad, 0=OK","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Inp_Target,"Target State of Input (Alarm if not in Target State)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_DIn:AOI,Inp_Gate,"Gate Condition (=1 to enable Alarm)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_DIn:AOI,Inp_Sim,"1=Use simulated PV (Set_SimPV); 0=Use Input (Inp_PV)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Inp_Reset,"1=Reset Alarm requiring reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_NoSubstPV,"1=Disallow selection of Substitute PV","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_NormTextVis,"1=Display state text in $Qnormal$Q state (= target), 0=hide (some HMI objects)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_HasTgtDisagreeAlm,"1=Target Disagree Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_TgtDisagreeResetReqd,"1=Target Disagree Alarm is latched in, requires Reset Command to clear","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_TgtDisagreeAckReqd,"1=Target Disagree Alarm must be acknowledged","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_TgtDisagreeSeverity,"Target Disagree Alarm Severity: 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_GateDly,"Time Inp_Gate must be true before Alarm is checked (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_Debounce,"Minimum time Status must maintain state, (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_TgtDisagreeMinDuration,"Minimum time Input must disagree with target to generate an Alarm (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,MSet_SubstPV,"Maintenance-Entered Substitute PV","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Set_SimPV,"PV used in Simulation (Inp_Sim=1)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,PCmd_Reset,"Program Command to Reset all latched Alarms","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,PCmd_TgtDisagreeAck,"Program Command to Acknowledge the Target Disagree Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,PCmd_TgtDisagreeInhibit,"Program Command to Inhibit the Target Disagree Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,PCmd_TgtDisagreeUninhibit,"Program Command to Uninhibit the Target Disagree Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,MCmd_SubstPV,"Maintenance Command to use Substitute PV (override input)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,MCmd_InpPV,"Maintenance Command to use Input PV (normal)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,OCmd_Reset,"Operator Command to Reset all latched Alarms","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Val_Notify,"Current Alarm Level and Acknowledgement (enumeration)","SINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts,"Discrete Input Status (incl. Debounce, Manual Override, if used)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_DIn:AOI,Sts_PV,"Discrete Input Status (actual, not subject to Override)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_DIn:AOI,Sts_SubstPV,"1=Using Substitute PV (Input being overridden)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_InpPV,"1=Using Input PV (normal)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_PVBad,"Input Comm Status/ Quality (0=OK, 1=Bad)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_Err,"1=Error in Config: see detail bits for reason","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_DIn:AOI,Err_Timer,"1=Error in Config: Invalid Timer Preset (use 0 to 2147483)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Err_Alarm,"1=Error in Config: Invalid Alarm Min Duration or Severity","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_TgtDisagree,"1=Input is not in Target state","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Alm_TgtDisagree,"1=Alarm: Input is not in Target state","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Ack_TgtDisagree,"1=Target Disagree Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_TgtDisagreeDisabled,"1=Target Disagree Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_TgtDisagreeInhibited,"1=Target Disagree Alarm is Inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_TgtDisagreeSuppressed,"1=Target Disagree Alarm is Suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Rdy_SubstPV,"1=Ready for MCmd_SubstPV","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Rdy_InpPV,"1=Ready for MCmd_InpPV","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Rdy_Reset,"1=Ready for Operator Alarm Reset Command","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Wrk_GateDlyT,"Gate Delay timer","TIMER","","(Usage := Local)"
TAG,P_DIn:AOI,Cfg_Tag,"Tagname for display on HMI","STRING_20","","(Usage := Local)"
TAG,P_DIn:AOI,Cfg_Desc,"Description for display on HMI","STRING_40","","(Usage := Local)"
TAG,P_DIn:AOI,Cfg_Label,"Label for graphic symbol displayed on HMI","STRING_20","","(Usage := Local)"
TAG,P_DIn:AOI,Wrk_Sts,"Internal Status (after Manual Override selection)","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_DIn:AOI,TgtDisagree,"Target Disagree Alarm","P_Alarm","","(Usage := Local)"
TAG,P_DIn:AOI,Wrk_FallT,"Timer to ensure Status LOW time on falling edge","TIMER","","(Usage := Local)"
TAG,P_DIn:AOI,Wrk_RiseT,"Timer to ensure Status HIGH time on rising edge","TIMER","","(Usage := Local)"
TAG,P_DIn:AOI,Wrk_SubstPV,"Internal flag: Using Substitute PV","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_DIn:AOI,Cfg_1StText,"Text to display in PV=1 State","STRING_8","","(Usage := Local)"
TAG,P_DIn:AOI,Cfg_0StText,"Text to display in PV=0 State","STRING_8","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Intlk:AOI,Inp_Intlk00,"Interlock Cond. 00 (1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk01,"Interlock Cond. 01$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk02,"Interlock Cond. 02$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk03,"Interlock Cond. 03$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk04,"Interlock Cond. 04$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk05,"Interlock Cond. 05$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk06,"Interlock Cond. 06$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk07,"Interlock Cond. 07$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk08,"Interlock Cond. 08$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk09,"Interlock Cond. 09$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk10,"Interlock Cond. 10$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk11,"Interlock Cond. 11$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk12,"Interlock Cond. 12$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk13,"Interlock Cond. 13$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk14,"Interlock Cond. 14$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk15,"Interlock Cond. 15$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Reset,"1=Reset Latched Interlocks and First-Out","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Cfg_Latched,"Set bits indicate which conditions are latched (sealed in)","INT","","(RADIX := Binary, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Cfg_Bypassable,"Set bits indicate which conditions can be bypassed","INT","","(RADIX := Binary, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,PCmd_Reset,"Program Command to Reset Latched Interlocks","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,OCmd_Reset,"Operator Command to Reset Latched Interlocks","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Sts_IntlkOK,"Overall Interlock Status (1=OK to run, 0=Stop)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Sts_NBIntlkOK,"Non-Bypassable Interlock Status (1=All NB Interlocks OK to run)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Sts_Intlk,"Individual Interlock Status (1=Stop, 0=OK)","INT","","(RADIX := Binary, Usage := Output, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Sts_FirstOut,"Interlock First Out Status (bit 1 is First Not-OK condition)","INT","","(RADIX := Binary, Usage := Output, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Sts_NBFirstOut,"Non-bypassable Interlock First-Out Status (bit=1 is First NB Not-OK condition)","INT","","(RADIX := Binary, Usage := Output, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Rdy_Reset,"1=Ready to receive OCmd_Reset (reset required)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Cfg_CondTxt,"Short HMI description of Interlock Conditions","STRING_20[16]","","(Usage := Local)"
TAG,P_Intlk:AOI,Wrk_Inp,"Collection copy of Inp_IntlkXXs","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_NB,"Working register for Non-Bypassable Interlock ogic","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_Intlk,"Working register for Interlock logic","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_FirstOut,"Working register for First Out logic","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_Sts,"Working register for generating Interlock status","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_NBFirstOut,"Working register for Non-Bypassable First Out logic","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_PrevSts,"Interlock Status previous scan","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_PrevNB,"Non-Bypassable Status previous scan","INT","","(RADIX := Binary, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Mode:AOI,Inp_Hand,"1=Select Hand (typ. hardwired)  Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Mode:AOI,Inp_Ovrd,"1=Select Override (typ. Process/Safety Interlock) Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Mode:AOI,Cfg_PCmdClear,"1=Clear Program Command on receipt; 0=Use Level-based (maintained) PCmds","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,Cfg_OvrdOverLock,"1=Override supersedes Prog/Oper Lock, 0=don$'t override Lock","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,PCmd_Acq,"Program Command to Acquire Ownership (Oper to Prog)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,PCmd_Rel,"Program Command to Release Ownership (Prog to Oper)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,PCmd_Lock,"Program Command to Lock Mode in Prog","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,PCmd_Unlock,"Program Command to Unlock Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,MCmd_Acq,"Maintenance Command to Acquire Ownership (Oper/Prog/Ovrd to Maint)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,MCmd_Rel,"Maintenance Command to Release Ownership (Maint to Oper/Prog/Ovrd)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,OCmd_AcqLock,"Operator Command to Acquire and Lock Mode in Oper","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,OCmd_Unlock,"Operator Command to Unlock Operator Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,Sts_Hand,"1=Mode is Hand (supersedes Maint, Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_Maint,"1=Mode is Maintenance (supersedes Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_Ovrd,"1=Mode is Override (supersedes Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_Prog,"1=Mode is Program","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_Oper,"1=Mode is Operator","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_ProgOperLock,"1=Program or Operator has requested Mode Lock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_ProgOperSel,"Prog/Oper selection 1=Program, 0=Operator","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Mode:AOI,Rdy_Acq,"1=Ready for MCmd_Acq","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Mode:AOI,Rdy_Rel,"1=Ready for MCmd_Rel","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Mode:AOI,Rdy_AcqLock,"1=Ready for OCmd_AcqLock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Mode:AOI,Rdy_Unlock,"1=Ready for OCmd_Unlock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Mode:AOI,Wrk_Locked,"1=Program/Operator Mode selection is Locked","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Mode:AOI,Wrk_Prog,"Internal Program (1) / Operator (0) Mode selection","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Mode:AOI,Wrk_Maint,"Internal Maintenance Mode","BOOL","","(RADIX := Decimal, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Motor:AOI,Inp_RunFdbk,"Input Signal: RUN feedback from motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_PermOK,"1=Permissives OK, motor can start","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_NBPermOK,"1=Non-Bypassable Permissives OK, motor can start","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_IntlkOK,"1=Interlocks OK, motor can start/run","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_NBIntlkOK,"1=Non-Bypassable Interlocks OK, motor can start/run","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_IOFault,"Input Communication Status 0=OK, 1=fail","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Inp_Sim,"1=Simulate working motor; 0=Start/Stop/ Monitor actual motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Inp_Hand,"1=Select Hand (hardwired) Control Strategy","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Inp_Ovrd,"1=Select Override control strategy","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Inp_OvrdState,"1=Override to RUN, 0=Override to STOP","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Inp_Reset,"1=Reset all fault conditions and latched Alarms","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasRunFdbk,"1=Motor provides a run feedback signal","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_UseRunFdbk,"1=Motor run feedback should be used for failure checking","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasPermObj,"1=Tells HMI a P_Perm is connected to Inp_Perm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasIntlkObj,"1=Tells HMI a P_Intlk is connected to Inp_Intlk","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasResInhObj,"1=Tells HMI a P_ResInh Restart Inhibit is connected","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasRunTimeObj,"1=Tells HMI a P_RunTime is connected","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_OvrdPermIntlk,"1=Override ignores Bypassable Perm/ Intlk; 0=always use Perm/Intlk","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasFailToStartAlm,"1=Fail to Start Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasFailToStopAlm,"1=Fail to Stop Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasIntlkTripAlm,"1=Interlock Trip Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasIOFaultAlm,"1=I/O Fault Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStartResetReqd,"1=Reset required to clear Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStopResetReqd,"1=Reset required to clear Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IntlkTripResetReqd,"1=Reset required to clear Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IOFaultResetReqd,"1=Reset required to clear I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStartAckReqd,"1=Acknowledge required for Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStopAckReqd,"1=Acknowledge required for Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IntlkTripAckReqd,"1=Acknowledge required for Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IOFaultAckReqd,"1=Acknowledge required for I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStartSeverity,"Fail To Start Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStopSeverity,"Fail To Stop Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IntlkTripSeverity,"Interlock Trip Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IOFaultSeverity,"I/O Fault Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_SimFdbkT,"Delay to echo back  of Running/Stopped status when in Simulation (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStartT,"Time after Start to get Run Feedback before Fault (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStopT,"Time after Stop to drop Run Feedback before Fault (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PSet_Owner,"Program Owner Request ID (non-zero) or Release (zero)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Start,"Program Command to Start Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Stop,"Program Command to Stop Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Acq,"Program Command to Acquire ownership (Oper/OOS to Prog)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Rel,"Program Command to Release ownership (Prog to OOS)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Lock,"Program Command to Lock Mode in Prog","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Unlock,"Program Command to Unlock Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Reset,"Program Command to Reset all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStartAck,"Program Command to Acknowledge Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStartInhibit,"Program Command to Inhibit Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStartUninhibit,"Program Command to Uninhibit Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStopAck,"Program Command to Acknowledge Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStopInhibit,"Program Command to Inhibit Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStopUninhibit,"Program Command to Uninhibit Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IntlkTripAck,"Program Command to Acknowledge Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IntlkTripInhibit,"Program Command to Inhibit Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IntlkTripUninhibit,"Program Command to Uninhibit Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IOFaultAck,"Program Command to Acknowledge I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IOFaultInhibit,"Program Command to Inhibit I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IOFaultUninhibit,"Program Command to Uninhibit I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,OCmd_Start,"Operator Command to Start Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,OCmd_Stop,"Operator Command to Stop Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,OCmd_Bypass,"Operator Command to Bypass all Bypassable Interlocks and Permissives","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,OCmd_Check,"Operator Command to Check (not bypass) all Interlocks and Permissives","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,MCmd_Disable,"Maintenance Command to Disable Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,MCmd_Enable,"Maintenance Command to Enable (allow to run) Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,OCmd_Reset,"Operator Command to Reset all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Out_Run,"1=Run Motor, 0=Stop Motor","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Out_Start,"1=Start Motor, 0=Motor left in current state","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Out_Stop,"1=Stop Motor, 0=Motor left in current state","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Val_Owner,"Current Object Owner ID (0=not owned)","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Val_Notify,"Current Alarm Level and Acknowledgement (enumeration)","SINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_Stopped,"1=Motor requested to stop and is confirmed stopped","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Starting,"1=Motor requested to run and awaiting run feedback","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Running,"1=Motor requested to run and is confirmed running","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Stopping,"1=Motor requested to stop and awaiting stopped feedback","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Available,"1=Motor available for control by automation (Prog)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_Bypass,"1=Bypassable Interlocks and Permissives are Bypassed","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_BypActive,"1=Bypassing Active (Bypassed or Maintenance)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_Disabled,"1=Motor is Disabled","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_Err,"1=Error in Config: see detail bits for reason","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Err_Timer,"1=Error in Config: Start/Stop Check timer preset (use 0 to 2147483)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Err_Sim,"1=Error in Config: Simulation timer preset (use 0 to 2147483)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Err_Alarm,"1=Error in Config: Invalid Alarm Severity","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_Hand,"1=Mode is Hand (supersedes Maint, Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Maint,"1=Mode is Maintenance (supersedes Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Ovrd,"1=Mode is Override (supersedes Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Prog,"1=Mode is Program (auto)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Oper,"1=Mode is Operator (manual)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_ProgOperLock,"1=Program or Operator has requested Mode Lock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStart,"1=Motor Failed to Start (one-shot)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Alm_FailToStart,"1=Motor Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Ack_FailToStart,"1=Fail to Start Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStartDisabled,"1=Fail to Start Alarm has been disabled (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStartInhibited,"1=Fail to Start Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStartSuppressed,"1=Fail to Start Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStop,"1=Motor Failed to Stop","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Alm_FailToStop,"1=Motor Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Ack_FailToStop,"1=Fail to Stop Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStopDisabled,"1=Fail to Stop Alarm has been disabled (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStopInhibited,"1=Fail to Stop Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStopSuppressed,"1=Fail to Stop Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IntlkTrip,"1=Motor stopped by an Interlock NOT OK (one-shot)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Alm_IntlkTrip,"1=Alarm: Motor stopped by an Interlock NOT OK","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Ack_IntlkTrip,"1=Interlock Trip Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IntlkTripDisabled,"1=Interlock Trip Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IntlkTripInhibited,"1=Interlock Trip Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IntlkTripSuppressed,"1=Interlock Trip Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IOFault,"I/O Comm Fault Status (0=OK, 1=Bad)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Alm_IOFault,"1=I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Ack_IOFault,"1=I/O Fault Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IOFaultDisabled,"1=I/O Fault Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IOFaultInhibited,"1=I/O Fault Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IOFaultSuppressed,"1=I/O Fault Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Start,"1=Ready to receive OCmd_Start (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Stop,"1=Ready to receive OCmd_Stop (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Bypass,"1=Ready to receive OCmd_Bypass (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Check,"1=Ready to receive OCmd_Check (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Disable,"1=Ready to receive MCmd_Disable (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Enable,"1=Ready to receive MCmd_Enable (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Reset,"1=Ready to receive OCmd_Reset (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Mode,"Motor Mode Selection","P_Mode","","(Usage := Local)"
TAG,P_Motor:AOI,IOFault,"I/O Fault Alarm","P_Alarm","","(Usage := Local)"
TAG,P_Motor:AOI,IntlkTrip,"Interlock Trip Alarm","P_Alarm","","(Usage := Local)"
TAG,P_Motor:AOI,FailToStop,"Motor Failed to Stop Alarm","P_Alarm","","(Usage := Local)"
TAG,P_Motor:AOI,FailToStart,"Motor Failed to Start Alarm","P_Alarm","","(Usage := Local)"
TAG,P_Motor:AOI,Cfg_Tag,"Tagname for display on HMI","STRING_20","","(Usage := Local)"
TAG,P_Motor:AOI,Cfg_Label,"Label for graphic symbol displayed on HMI","STRING_20","","(Usage := Local)"
TAG,P_Motor:AOI,Cfg_Desc,"Description for display on HMI","STRING_40","","(Usage := Local)"
TAG,P_Motor:AOI,Wrk_Run,"1=Motor should be $Qrunning$Q, 0=should be $Qstopped$Q","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_SimRunT,"Simulation Delay until Running","TIMER","","(Usage := Local)"
TAG,P_Motor:AOI,Wrk_StopT,"Stop Check Timer","TIMER","","(Usage := Local)"
TAG,P_Motor:AOI,Wrk_StartT,"Start Check Timer","TIMER","","(Usage := Local)"
TAG,P_Motor:AOI,Wrk_Fault,"1=a Motor Fault has been detected","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_SimStopT,"Simulation Delay until Stopped","TIMER","","(Usage := Local)"
TAG,P_Motor:AOI,Wrk_RunFdbk,"Run Feedback based on mode, simulation, etc. 1=running","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_IntlkTrip,"1=Interlock Not OK Tripped Running Motor","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_Notify,"Buffer for building Val_Notify","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_Bypass,"Internal Bypassable Permissives and Interlocks are Bypassed flag","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_Disabled,"Internal Motor is Disabled","BOOL","","(RADIX := Decimal, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Perm:AOI,Inp_Perm00,"Permissive Cond 00$N(1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm01,"Permissive Cond 01 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm02,"Permissive Cond 02 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm03,"Permissive Cond 03 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm04,"Permissive Cond 04 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm05,"Permissive Cond 05$N(1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm06,"Permissive Cond 06 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm07,"Permissive Cond 07 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm08,"Permissive Cond 08 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm09,"Permissive Cond 09 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm10,"Permissive Cond 10$N(1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm11,"Permissive Cond 11 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm12,"Permissive Cond 12 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm13,"Permissive Cond 13 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm14,"Permissive Cond 14 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm15,"Permissive Cond 15$N(1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Cfg_Bypassable,"Set bits indicate which conditions can be bypassed","INT","","(RADIX := Binary, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Sts_PermOK,"Overall Permissive Status (1=OK to start)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Perm:AOI,Sts_NBPermOK,"Non-Bypassable Permissive Status (1 =all non- bypassable Permissives OK to start)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Perm:AOI,Sts_Perm,"Individual Permissive Status (1=OK, 0=don$'t start)","INT","","(RADIX := Binary, Usage := Output, Required := false, Visible := true)"
TAG,P_Perm:AOI,Cfg_CondTxt,"Short HMI description of Permissive Conditions","STRING_20[16]","","(Usage := Local)"
TAG,P_Perm:AOI,Wrk_Inp,"Collection copy of Inp_PermXXs","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Perm:AOI,Wrk_Bypass,"Working Register for Bypassable Permissives","INT","","(RADIX := Binary, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Reset:AOI,Inp_Reset,"Reset Input, 1=Reset, from pushbutton or another object","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Reset:AOI,Inp_ResetReqd,"1=Reset Required, enable Reset button","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Reset:AOI,Cfg_MinHoldTime,"Minimum Time to hold Reset Output true (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Reset:AOI,PCmd_Reset,"Program Command to Reset, from other object","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Reset:AOI,OCmd_Reset,"Operator Command to Reset, from HMI","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Reset:AOI,Out_Reset,"1=Reset received for this P_Reset$'s scope","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Reset:AOI,Sts_Err,"1=Error in Config: Invalid Hold Time (use 0 to 2147483)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Reset:AOI,Rdy_Reset,"1=Ready to receive OCmd_Reset (enable button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Reset:AOI,Wrk_HoldT,"Reset Output Hold Timer (TOF)","TIMER","","(Usage := Local)"
TAG,P_Reset:AOI,Wrk_EnableInONS,"EnableIn transition detection to pulse Reset Output","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Reset:AOI,Wrk_HoldONS,"One-Shot to fire Hold Timer to ensure min. output ON time.","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Reset:AOI,Wrk_ResetCond,"Any incoming Reset condition is TRUE","BOOL","","(RADIX := Decimal, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_ResInh:AOI,Inp_Stopped,"Equipment is confirmed Stopped","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Inp_Starting,"Equipment is Starting, indicating a start attempt","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Inp_Running,"Equipment is confirmed Running","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Cfg_ThreeColdStarts,"Sec within which three starts are allowed if cold","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_FirstFailCold,"Sec for cold motor to wait after 1st start failure before ready to start","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_SubseqFailCold,"Sec for cold motor to wait after 2nd and subsequent start failure before ready","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_FirstFailHot,"Sec for hot motor to wait after 1st start failure before ready to start","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_SubseqFailHot,"Sec for hot motor to wait after 2nd and subsequent start failure before ready","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_HotRestartOK,"Sec for hot motor to run so it can immediately restart after stop","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_RestartHot,"Sec for hot motor to wait after stop if stopped before Hot Restart OK time","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_HotToCold,"Sec for a stopped hot motor to become cold","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Val_MinToReady,"Minutes yet inhibited before ready to start (mmm:ss)","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Val_SecToReady,"Seconds yet inhibited before ready to start$N(mmm:ss)","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Val_State,"State Number (see State Diagram in docs) for HMI","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Sts_Ready,"Permissive for unit to start 1=ready, 0=not ready","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Sts_Err,"1=Error in Config: Invalid Time (use 0.0 to 2147483)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Wrk_FirstColdStartT,"Time since first cold start","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_FirstFailColdT,"Time for cold motor to wait after 1st start failure before ready","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_SubsFailColdT,"Time for cold motor to wait after 2nd and subs. failures before ready","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_FirstFailHotT,"Time for hot motor to wait after 1st start failure before ready","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_SubsFailHotT,"Time for hot motor to wait after 2nd and subs. failures before ready","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_HotRestartOKT,"Time for hot motor to run so it can restart immediately when stopped","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_RestartHotT,"Time for hot motor to wait after stop after running less than Hot Restart OK time","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_HotToColdT,"Time for a stopped hot motor to become cold","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_FailCount,"Number of failed start attempts","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_ResInh:AOI,Wrk_mSecUntilReady,"Milliseconds until the inhibit time is done and the unit is ready to start","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_ResInh:AOI,Wrk_SecUntilReady,"Seconds until inhibit time is done and the unit is ready to start","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_ResInh:AOI,Wrk_State,"Instruction State (see state diagram in design docs)","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_ResInh:AOI,Wrk_Ready,"Internal storage of Sts_Ready:$N1 = OK to start","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_ResInh:AOI,Wrk_SecondColdStartT,"Time since second cold start","TIMER","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_RunTime:AOI,Inp_Starting,"1=Motor is Starting (from motor instruction)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Inp_Running,"1=Motor is Running (from motor instruction)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,PCmd_ClearStarts,"Program Command to Clear Count of Starts (attempts)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,PCmd_ClearMaxHrs,"Program Command to Clear Maximum (continuous) Run Time for any start","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,PCmd_ClearTotHrs,"Program Command to Clear Total Running Time","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,MCmd_ClearStarts,"Maintenance Command to Clear Count of Starts (attempts)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,MCmd_ClearMaxHrs,"Maintenance Command to Clear Maximum (continuous) Run Time for any start","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,MCmd_ClearTotHrs,"Maintenance Command to Clear Total Running Time","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,Val_Starts,"Total number of motor starts or attempts","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Val_CurRunHrs,"Current running time this start (hours)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Val_MaxRunHrs,"Maximum continuous running time for a given start (hours)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Val_TotRunHrs,"Total accumulated running time (hours)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Wrk_CurHours,"Whole hours of current run time","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_RunTime:AOI,Wrk_CurRunT,"Timer for timing current run time","TIMER","","(Usage := Local)"
TAG,P_RunTime:AOI,Wrk_TotTenths,"Tenths of hours of total run time","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_RunTime:AOI,Wrk_Starts,"Counter for counting motor starts","COUNTER","","(Usage := Local)"
TAG,P_RunTime:AOI,Wrk_TotRunT,"Retentive timer for timing 0.1 hour total run time","TIMER","","(Usage := Local)"
TAG,P_RunTime:AOI,Wrk_MaxHours,"Internal Maximum Run Hours","REAL","","(RADIX := Float, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_VSD:AOI,Inp_SpeedFdbk,"Speed Feedbak in Drive Units (typ. 0-32767 = 0 to max freq.)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_FaultCode,"Current Drive Fault Code (enumeration)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Inp_Datalink,"Auxiliary Signal (datalink) Input in Drive (raw) Units","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Ready,"1=Drive is ready to run","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Running,"1=Drive is Running (active)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_CommandDir,"1=Drive is commanded Forward, 0=Drive is commanded Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_ActualDir,"1=Drive is running Forward, 0=Drive is running Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Accelerating,"1=Drive is accelerating","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Decelerating,"1=Drive is decelerating","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Alarm,"1=Drive has an Alarm Condition (see drive display or manual)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Faulted,"1=Drive has Faulted (see drive display or manual)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_AtSpeed,"1=Drive is at commanded speed","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_FwdPermOK,"1=Permissives OK, drive can start Forward","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_FwdNBPermOK,"1=Non-Bypassable Permissives OK, drive can start Forward","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_RevPermOK,"1=Permissives OK, drive can start Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_RevNBPermOK,"1=Non-Bypassable Permissives OK, motor can start Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_IntlkOK,"1=Interlocks OK, drive can start/run","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_NBIntlkOK,"1=Non-Bypassable Interlocks OK, drive can start/run","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_IOFault,"Input Communication Status 0=OK, 1=fail","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Inp_Sim,"1=Simulate working drive; 0=Start/Stop/ Monitor actual drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Inp_Hand,"1=Select Hand (hardwired) Control Strategy","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Ovrd,"1=Select Override control strategy","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_OvrdState,"1=Override to RUN, 0=Override to STOP","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_OvrdSpeed,"Speed at which to run drive in Override if Overriding to RUN","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Reset,"1=Reset drive fault conditions and latched Alarms","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Cfg_HasReverse,"1=Drive can be run reverse, 0=Forward only","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasJog,"1=Drive Jog Command enabled/visible, 0=Drive Jog Command not allowed","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasRunFdbk,"1=Drive provides speed feedback and run signal","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_UseRunFdbk,"1=Drive run feedback should be used for failure checking","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasInpDatalink,"1=A signal is connected to Inp_Datalink1","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasOutDatalink,"1=A signal is connected to Out_Datalink1","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasFwdPermObj,"1=Tells HMI a P_Perm is connected to Inp_FwdPerm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasRevPermObj,"1=Tells HMI a P_Perm is connected to Inp_RevPerm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasIntlkObj,"1=Tells HMI a P_Intlk is connected to Inp_Intlk","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasResInhObj,"1=Tells HMI a P_ResInh Restart Inhibit is connected","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasRunTimeObj,"1=Tells HMI a P_RunTime is connected","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SetTrack,"1=PSets track OSets in Oper, OSets track PSets in Prog, 0=no tracking","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SetTrackOvrdHand,"1=Prog/Oper Settings track Override/Hand speed reference","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OvrdPermIntlk,"1=Override ignores Bypassable Perm/ Intlk; 0=always use Perm/Intlk","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasFailToStartAlm,"1=Fail to Start Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasFailToStopAlm,"1=Fail to Stop Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasIntlkTripAlm,"1=Interlock Trip Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasDriveFaultAlm,"1=Drive Fault alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasIOFaultAlm,"1=I/O Fault Alarm exists and will be checked","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStartResetReqd,"1=Reset requied to clear Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStopResetReqd,"1=Reset required to clear Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IntlkTripResetReqd,"1=Reset required to clear Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_DriveFaultResetReqd,"1=Reset required to clear Drive Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IOFaultResetReqd,"1=Reset required to clear I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStartAckReqd,"1=Acknowledge required for Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStopAckReqd,"1=Acknowledge required for Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IntlkTripAckReqd,"1=Acknowledge required for Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_DriveFaultAckReqd,"1=Acknowledge required for Drive Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IOFaultAckReqd,"1=Acknowledge required for I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStartSeverity,"Fail To Start Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStopSeverity,"Fail To Stop Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IntlkTripSeverity,"Interlock Trip Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_DriveFaultSeverity,"Drive Fault Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IOFaultSeverity,"I/O Fault Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_MinSpdRef,"Minimum Speed Reference in EU (for limiting)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_MaxSpdRef,"Maximum Speed Reference in EU (for limiting)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedRefRawMin,"Speed Reference Minimum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedRefRawMax,"Speed Reference Maximum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedRefEUMin,"Speed Reference Minimum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedRefEUMax,"Speed Reference Maximum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedFdbkRawMin,"Speed Feedback Minimum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedFdbkRawMax,"Speed Feedback Maximum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedFdbkEUMin,"Speed Feedback Minimum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedFdbkEUMax,"Speed Feedback Maximum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_InpDatalinkRawMin,"Input Datalink Minimum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_InpDatalinkRawMax,"Input Datalink Maximum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_InpDatalinkEUMin,"Input Datalink Minimum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_InpDatalinkEUMax,"Input Datalink Maximum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkMin,"Minimum Output Datalink in EU (for limiting)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkMax,"Maximum Output Datalink in EU (for limiting)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkRawMin,"Output Datalink Minimum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkRawMax,"Output Datalink Maximum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkEUMin,"Output Datalink Minimum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkEUMax,"Output Datalink Maximum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SimRampT,"Time to ramp speed fdbk when in Simulation (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStartT,"Time after Start to get Run Feedback before Fault (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStopT,"Time after Stop to drop Run Feedback before Fault (sec)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_ResetPulseT,"Time to pulse Out_Reset to clear drive fault","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PSet_SpeedRef,"Program Setting of Speed Reference (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PSet_OutDatalink,"Program Setting of Output Datalink (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PSet_Owner,"Program Owner Request ID (non-zero) or Release (zero)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OSet_SpeedRef,"Operator Setting of Speed Reference (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OSet_OutDatalink,"Operator Setting of Output Datalink (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Start,"Program Command to Start Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Stop,"Program Command to Stop Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Fwd,"Program Command to set direction to Fowrard","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Rev,"Program Command to set direction to Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Acq,"Program Command to Acquire ownership (Oper/OOS to Prog)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Rel,"Program Command to Release ownership (Prog to OOS)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Lock,"Program Command to Lock Mode in Prog","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Unlock,"Program Command to Unlock Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Reset,"Program Command to Reset drive fault and all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStartAck,"Program Command to Acknowledge Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStartInhibit,"Program Command to Inhibit Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStartUninhibit,"Program Command to Uninhibit Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStopAck,"Program Command to Acknowledge Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStopInhibit,"Program Command to Inhibit Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStopUninhibit,"Program Command to Uninhibit Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IntlkTripAck,"Program Command to Acknowledge Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IntlkTripInhibit,"Program Command to Inhibit Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IntlkTripUninhibit,"Program Command to Uninhibit Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_DriveFaultAck,"Program Command to Acknowledge Drive Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_DriveFaultInhibit,"Program Command to Inhibit Drive Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_DriveFaultUninhibit,"Program Command to Uninhibit Drive Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IOFaultAck,"Program Command to Acknowledge I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IOFaultInhibit,"Program Command to Inhibit I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IOFaultUninhibit,"Program Command to Uninhibit I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Start,"Operator Command to Start Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Stop,"Operator Command to Stop Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Jog,"Operator Command to Jog Drive (not cleared by P_VSD!)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Fwd,"Operator Command to set direction to Forward","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Rev,"Operator Command to set direction to Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Bypass,"Operator Command to Bypass all Bypassable Interlocks and Permissives","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Check,"Operator Command to Check (not bypass) all Interlocks and Permissives","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,MCmd_Disable,"Maintenance Command to Disable Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,MCmd_Enable,"Maintenance Command to Enable (allow to run) Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Reset,"Operator Command to Reset all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Out_SpeedRef,"Drive Speed Reference in Drive Units (typ. 0-32767 = 0 to max freq.)","INT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Datalink,"Auxiliary Signal (datalink) Output in Drive (raw) Units","INT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Run,"1=Start/Run Drive, 0=Stop Drive (for held starter type)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Out_Stop,"1=Stop Drive, 0=drive left in current state","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Start,"1=Start Drive, 0=drive left in current state","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Jog,"1=Jog drive at Jog Speed, -->0=stop jogging","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_ClearFault,"1=Attempt to clear Drive Fault","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Fwd,"1=Set drive direction to Forward","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Rev,"1=Set drive direction to Reverse","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Val_SpeedRef,"Speed Reference (target) to drive","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Val_SpeedFdbk,"Speed Feedback (actual) from drive","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Val_InpDatalink,"Input Datalink value from drive","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Val_OutDatalink,"Output Datalink value to drive","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Val_SpeedFdbkEUMin,"Minimum of Speed Feedback = MIN (Cfg_SpeedFdbkEUMin, Cfg_SpeedFdbkEUMax)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Val_SpeedFdbkEUMax,"Maximum of Speed Feedback = MAX (Cfg_SpeedFdbkEUMin, Cfg_SpeedFdbkEUMax)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Val_Owner,"Current Object Owner ID (0=not owned)","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Val_Notify,"Current Alarm Level and Acknowledgement (enumeration)","SINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Stopped,"1=Drive requested to stop and is confirmed stopped","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Starting,"1=Drive requested to run and awaiting run feedback","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Running,"1=Drive requested to run and is confirmed running","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Stopping,"1=Drive requested to stop and awaiting stopped feedback","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Jogging,"1=Drive requested to Jog","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_CommandDir,"1=Drive commanded to Forward, 0=Reverse","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_ActualDir,"1=Drive Actual direction is Forward, 0=Reverse","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Accel,"1=Drive is Accelerating","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Decel,"1=Drive is Decelerating","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_NotReady,"1=Drive is Not Ready (cannot be started)$NCheck alarms, stops, faults","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Alarm,"1=Drive has an Alarm (see drive display or manual)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_AtSpeed,"1=Drive is running at reference speed","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_SpeedLimited,"1=Speed Reference Setting exceeds configured Max/Min limit","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Available,"1=Drive available for control by automation (Prog)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Bypass,"1=Bypassable Interlocks and Permissives are Bypassed","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Disabled,"1=Drive is Disabled","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Err,"1=Error in Config: see detail bits for reason","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Err_Timer,"1=Error in Config: Invalid Check or Reset Pulse Time (use 0 to 2147483)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_Sim,"1=Error in Config: simulation timer preset: use 0 to 2147483)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_Alarm,"1=Error in Config: Invalid Alarm Severity","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_FdbkRaw,"1=Erron in Config: Speed Fdbk Raw Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_FdbkEU,"1=Error in Config: Speed Fdbk EU Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_RefLim,"1=Error in Config: Speed Ref Limit Min > Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_RefEU,"1=Error in Config: Speed Ref EU Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_RefRaw,"1=Error in Config: Speed Ref Raw Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_InpDLRaw,"1=Error in Config: Input Datalink Raw Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_InpDLEU,"1=Error in Config: Input Datalink EU Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_OutDLLim,"1=Error in Config: Output Datalink Limits Min > Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_OutDLEU,"1=Error in Config: Output Datalink EU Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_OutDLRaw,"1=Error in Config: Output Datalink Raw Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Hand,"1=Mode is Hand (supersedes Maint, Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Maint,"1=Mode is Maintenance (supersedes Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Ovrd,"1=Mode is Override (supersedes Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Prog,"1=Mode is Program (auto)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Oper,"1=Mode is Operator (manual)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_ProgOperLock,"1=Program or Operator has requested Mode Lock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStart,"1=Drive Failed to Start (One-Shot)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Alm_FailToStart,"1=Drive Fail to tart Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Ack_FailToStart,"1=Fail to Start Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStartDisabled,"1=Fail to Start Alarm has been disabled (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStartInhibited,"1=Fail to Start Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStartSuppressed,"1=Fail to Start Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStop,"1=Drive Failed to Stop","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Alm_FailToStop,"1=Drive Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Ack_FailToStop,"1=Fail to Stop Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStopDisabled,"1=Fail to Stop Alarm has been disabled (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStopInhibited,"1=Fail to Stop Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStopSuppressed,"1=Fail to Stop Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IntlkTrip,"1=Drive was stopped by an Interlock NOT OK (One-Shot)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Alm_IntlkTrip,"1=Alarm: Drive stopped by an Interlock NOT OK","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Ack_IntlkTrip,"1=Interlock Trip Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IntlkTripDisabled,"1=Interlock Trip Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IntlkTripInhibited,"1=Interlock Trip Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IntlkTripSuppressed,"1=Interlock Trip Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_DriveFault,"1=Drive Fault (see drive display or manual)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Alm_DriveFault,"1=Alarm: Drive Fault (see drive display or manual)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Ack_DriveFault,"1=Drive Fault Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_DriveFaultDisabled,"1-=Drive Fault Alarm has been disabled (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_DriveFaultInhibited,"1=Drive Fault Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_DriveFaultSuppressed,"1-Drive Fault Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IOFault,"I/O Comm Fault Status (0=OK, 1=Bad)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Alm_IOFault,"1=I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Ack_IOFault,"1=I/O Fault Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IOFaultDisabled,"1=I/O Fault Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IOFaultInhibited,"1=I/O Fault Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IOFaultSuppressed,"1=I/O Fault Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Start,"1=Ready to receive OCmd_Start (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Stop,"1=Ready to receive OCmd_Stop (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Jog,"1=Ready to receive OCmd_Jog (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Fwd,"1=Ready to receive OCmd_Fwd (enabled HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Rev,"1=Ready to receive OCmd_Rev (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Bypass,"1=Ready to receive OCmd_Bypass (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Check,"1=Ready to receive OCmd_Check (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Disable,"1=Ready to receive MCmd_Disable (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Enable,"1=Ready to receive MCmd_Enable (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Reset,"1=Ready to receive OCmd_Reset (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Mode,"Drive Mode Selection","P_Mode","","(Usage := Local)"
TAG,P_VSD:AOI,IOFault,"I/O Fault Alarm","P_Alarm","","(Usage := Local)"
TAG,P_VSD:AOI,IntlkTrip,"Interlock Trip Alarm","P_Alarm","","(Usage := Local)"
TAG,P_VSD:AOI,FailToStop,"Drive Failed to Stop Alarm","P_Alarm","","(Usage := Local)"
TAG,P_VSD:AOI,FailToStart,"Drive Failed to Start Alarm","P_Alarm","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_Tag,"Tagname for display on HMI","STRING_20","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_Label,"Label for graphic symbol displayed on HMI","STRING_20","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_Desc,"Description for display on HMI","STRING_40","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_Run,"1=Drive should be $Qrunning$Q, 0=should be $Qstopped$Q","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_AccelT,"Simulation Accel Ramp timer until Running at speed","TIMER","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_Fault,"1=any Fault has been detected","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_DecelT,"Simulation Decel Ramp time until fully stopped","TIMER","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_RunFdbk,"Run Feedback based on mode, simulation, etc. 1=running","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_IntlkTrip,"1=Interlock Not OK Tripped Running Drive","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_Notify,"Buffer for building Val_Notify","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_Bypass,"Internal Bypassable Permissives and Interlocks are Bypassed flag","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_Disabled,"Internal Drive is Disabled","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,DriveFault,"Drive Faulted Alarm","P_Alarm","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_SpeedRefEU,"Speed Reference Engineering Units for display on HMI","STRING_8","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_SpeedRef,"Working copy of Speed Reference (for limiting)","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_VSD:AOI,Wrk_Rev,"Working (internal) Direction 1=Reverse 0=Forward (default)","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_Jog,"1=Jog Drive, 0=Drive not jogging","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_ResetT,"Reset Output Pulse Timer","TIMER","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_ResetCond,"Any incoming Reset condition is TRUE","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_ResetONS,"One-Shot to fire Reset Timer to ensure min. output ON time.","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Cfg_SpeedFdbkEU,"Speed Feedback Engineering Units for display on HMI","STRING_8","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_OutDatalinkLabel,"Datalink Output Label displayed on faceplate","STRING_20","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_InpDatalinkLabel,"Datalink Input Label displayed on faceplate","STRING_20","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_OutDatalinkEU,"Datalink Output Engineering Units for display on HMI","STRING_8","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_InpDatalinkEU,"Datalink Input Engineering Units for display on HMI","STRING_8","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_OutDatalink,"Selected Output Datalink setting","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_VSD:AOI,Cfg_RevText,"Name for Reverse Direction, e.g., $QDown$Q, $QReverse$Q","STRING_16","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_FwdText,"Name for Forward Direction, e.g., $QUp$Q, $QForward$Q","STRING_16","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_StopT,"Stop Check Timer (for Fail to Stop)","TIMER","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_StartT,"Start Check Timer (for Fail to Start)","TIMER","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,U_CommFail:AOI,Inp_Heartbeat,"Heartbeat from Remote PLC","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_CommFail:AOI,CFG_DelayTimerSec,"Delay Timer in Seconds","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_CommFail:AOI,Sts_CommFail,"Communication Failure Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_CommFail:AOI,HeartBeatDelayTimerOn,"","TIMER","","(Usage := Local)"
TAG,U_CommFail:AOI,HeartBeatDelayTimerOff,"","TIMER","","(Usage := Local)"
TAG,U_CommFail:AOI,ConnectionStatusDelayTimer,"","TIMER","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,U_FlowTot:AOI,Inp_AIn,"Flow Analog Input AOI","P_AIn","","(Usage := InOut, Required := true, Visible := true)"
TAG,U_FlowTot:AOI,Inp_WallClock,"PLC Wall Clock","U_WallClock","","(Usage := InOut, Required := true, Visible := true)"
TAG,U_FlowTot:AOI,Inp_ProgStartReq,"Prog Start Request.  If needed map to turn on totalizer, (ex. pump running) else Defaults to 1 (always start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,U_FlowTot:AOI,Val_FlowRate,"Current Flow Rate","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowTot:AOI,Val_DailyTot,"Todays Total Flow","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowTot:AOI,Val_YestTot,"Yesterday Total Flow","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowTot:AOI,Val_YearlyTot,"This Year Total Flow","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowTot:AOI,Val_LastYearTot,"Last Year Total Flow","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowTot:AOI,YearlyTotalizer,"","TOTALIZER","","(Usage := Local)"
TAG,U_FlowTot:AOI,DailyTotalizer,"","TOTALIZER","","(Usage := Local)"
TAG,U_FlowTot:AOI,FlowRateLowLimit_SSUM,"","SELECTED_SUMMER","","(Usage := Local)"
TAG,U_FlowTot:AOI,LowCutoff_BNOT,"","FBD_BOOLEAN_NOT","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,U_Heartbeat:AOI,CFG_DelayTimerSec,"Delay Timer in Seconds","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_Heartbeat:AOI,Heartbeat,"Heartbeat from Remote PLC","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_Heartbeat:AOI,DelayTimerOn,"","TIMER","","(Usage := Local)"
TAG,U_Heartbeat:AOI,DelayTimerOff,"","TIMER","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,U_RepeatCycTmr:AOI,CFG_OffTimeLoLimitSec,"Off Time Low Limit (Sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,CFG_OnTimeLoLimitSec,"On Time Low Limit (Sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,OSet_CycleNowPB,"Operator Cycle Now Push button","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,Oset_OnTimePreset,"Operator On Time Preset","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,Oset_OffTimePreset,"Operator Off Time Preset","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,Sts_EquipAvailable,"Motor Available","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,Val_OnTimeElapsed,"On Time Elapsed","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,Val_OffTimeElapsed,"Off Time Elapsed","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,Val_OnTimeLoLimit,"On Time Low Limit","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,Val_OnTimeHiLimit,"On Time High Limit","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,Val_OffTimeLoLimit,"Off Time Low Limit","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,Val_OffTimeHiLimit,"Off Time High Limit","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,Out_On,"Motor Run Output","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_RepeatCycTmr:AOI,ONTimer,"On Timer","TIMER","","(Usage := Local)"
TAG,U_RepeatCycTmr:AOI,OFFTimer,"Off Timer","TIMER","","(Usage := Local)"
TAG,U_RepeatCycTmr:AOI,TimerHighLimitSec,"Timer High Limit (Sec)","REAL","","(RADIX := Float, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,U_WallClock:AOI,OCmd_SetTime,"Set the Date and Time Bit","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Year,"Year To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Month,"Month To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Day,"Day To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Hour,"Hour To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Minute,"Minute To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Second,"Second To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentYear,"Current Year","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentMonth,"Current Month","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentDay,"Current Day","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentHour,"Current Hour","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentMinute,"Current Minute","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentSecond,"Current Second","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_DayOfWeek,"Day of Week$N 0 = Sun, 1=Mon, 2=Tues, 3=Wed, 4=Thur, 5=Fri, 6=Sat","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Sts_HourlyReset,"Hourly Reset","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Sts_DailyReset,"Daily Reset","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Sts_MonthlyReset,"Monthly Reset","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Sts_YearlyReset,"Yearly Reset","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Wrk_SetDateTime,"","DINT[7]","","(RADIX := Decimal, Usage := Local)"
TAG,U_WallClock:AOI,Wrk_GetDateTime,"Result of GSV to Wallclocktime -- input to Day of Week calculation","DINT[7]","","(RADIX := Decimal, Usage := Local)"
COMMENT,U_WallClock:AOI,Wrk_GetDateTime,"Year",,"Wrk_GetDateTime[0]"
COMMENT,U_WallClock:AOI,Wrk_GetDateTime,"Month",,"Wrk_GetDateTime[1]"
COMMENT,U_WallClock:AOI,Wrk_GetDateTime,"Day",,"Wrk_GetDateTime[2]"
COMMENT,U_WallClock:AOI,Wrk_GetDateTime,"Hour",,"Wrk_GetDateTime[3]"
COMMENT,U_WallClock:AOI,Wrk_GetDateTime,"Minute",,"Wrk_GetDateTime[4]"
COMMENT,U_WallClock:AOI,Wrk_GetDateTime,"Second",,"Wrk_GetDateTime[5]"
COMMENT,U_WallClock:AOI,Wrk_GetDateTime,"Microsecond",,"Wrk_GetDateTime[6]"
TAG,U_WallClock:AOI,Wrk_G,"Function of Year and Month, used to calculate Day of Week","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,U_WallClock:AOI,Wrk_F,"Function of Month, used to calculate Day of Week","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,U_WallClock:AOI,Wrk_DayONS,"One-Shot for daily pulse output","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,U_WallClock:AOI,Wrk_HourONS,"One-Shot for hourly pulse output","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,U_WallClock:AOI,Wrk_MonthONS,"One-Shot for monthly pulse output","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,U_WallClock:AOI,Wrk_YearONS,"One-Shot for yearly pulse output","BOOL","","(RADIX := Decimal, Usage := Local)"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"FlocBsn01_M1202","A01_Pump_LDR","===============================================================$NDEVICE MOTOR$N===============================================================$NThis rung actually monitors and controls the Device motor.$NMapping inputs:  Run Feedback$NHand Mode selection (local operation)$NPermissive OK$NProtective$2019s OK,$NI/O Fault signals$NPump Reset (above)$N$NDEVICE$N$NOutput Mapping: Starter output","NOP()","0"
RCOMMENT,"FlocBsn01_M1202","A01_Pump_LDR","===============================================================$NRESET$N===============================================================$NDEVICE RESET$NResets all alarms, interlocks and faults for the P1 motor and related signals. $NIt also receives and forwards a site-wide reset.  ","OTE(Wrk_ResetReqd)","1"
RCOMMENT,"FlocBsn01_M1202","A01_Pump_LDR","===============================================================$NVFD DPI port selection for Speed Reference$N===============================================================$NConfigure source of Speed Reference (Set to DPI port 5)$N","OTU(Equip_VFD_O.DriveLogicRslt_SpdRefID2)","2"
RCOMMENT,"FlocBsn01_M1202","Main","===============================================================$NSUB ROUTINE$N===============================================================","JSR(A02_Pump_FBD,0)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"MainProgram","Main","===============================================================$NPUMP  SIMULATION$N===============================================================$NGlobal on/off inputs simulation","OTL(PLC_Simulation)","0"
RCOMMENT,"MainProgram","Main","===============================================================$NWALL CLOCK$N==============================================================","WallClock(PLC_WallClock)","1"
RCOMMENT,"MainProgram","Main","===============================================================$NHEART BEAT$N==============================================================","Heartbeat(PLC_Heartbeat)","2"
RCOMMENT,"MainProgram","Main","===============================================================$NPLC COMMUNICATION FAIL$N==============================================================$NUse if plc is not using produce/consume","CommFail(PLC_CommFail)","3"
RCOMMENT,"MainProgram","Main","===============================================================$NSUB ROUTINE$N===============================================================","JSR(A04_MiscAnalogOutputs,0)","4"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"SedBasin01Drive","A01_Drive_LDR","===============================================================$NDEVICE MOTOR$N===============================================================$NThis rung actually monitors and controls the Device motor.$NMapping inputs:  Run Feedback$NHand Mode selection (local operation)$NPermissive OK$NProtective$2019s OK,$NI/O Fault signals$NPump Reset (above)$N$NDEVICE$N$NOutput Mapping: Starter output","OTE(Equip_IOFault)","0"
RCOMMENT,"SedBasin01Drive","A01_Drive_LDR","===============================================================$NRESET$N===============================================================$NDEVICE RESET$NResets all alarms, interlocks and faults for the P1 motor and related signals. $NIt also receives and forwards a site-wide reset.  ","OTE(Wrk_ResetReqd)","2"
RCOMMENT,"SedBasin01Drive","Main","===============================================================$NSUB ROUTINE$N===============================================================","JSR(A02_Drive_FBD,0)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
remark,"Comments for Program (P_AIn:AOI) Routine (EnableInFalse) not exported: source is protected"
remark,"Comments for Program (P_AIn:AOI) Routine (Logic) not exported: source is protected"
remark,"Comments for Program (P_AIn:AOI) Routine (Prescan) not exported: source is protected"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
remark,"Comments for Program (P_Alarm:AOI) Routine (EnableInFalse) not exported: source is protected"
remark,"Comments for Program (P_Alarm:AOI) Routine (Logic) not exported: source is protected"
remark,"Comments for Program (P_Alarm:AOI) Routine (Prescan) not exported: source is protected"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
remark,"Comments for Program (P_DIn:AOI) Routine (EnableInFalse) not exported: source is protected"
remark,"Comments for Program (P_DIn:AOI) Routine (Logic) not exported: source is protected"
remark,"Comments for Program (P_DIn:AOI) Routine (Prescan) not exported: source is protected"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
remark,"Comments for Program (P_Intlk:AOI) Routine (EnableInFalse) not exported: source is protected"
remark,"Comments for Program (P_Intlk:AOI) Routine (Logic) not exported: source is protected"
remark,"Comments for Program (P_Intlk:AOI) Routine (Prescan) not exported: source is protected"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
remark,"Comments for Program (P_Mode:AOI) Routine (EnableInFalse) not exported: source is protected"
remark,"Comments for Program (P_Mode:AOI) Routine (Logic) not exported: source is protected"
remark,"Comments for Program (P_Mode:AOI) Routine (Prescan) not exported: source is protected"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
remark,"Comments for Program (P_Motor:AOI) Routine (EnableInFalse) not exported: source is protected"
remark,"Comments for Program (P_Motor:AOI) Routine (Logic) not exported: source is protected"
remark,"Comments for Program (P_Motor:AOI) Routine (Prescan) not exported: source is protected"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
remark,"Comments for Program (P_Perm:AOI) Routine (EnableInFalse) not exported: source is protected"
remark,"Comments for Program (P_Perm:AOI) Routine (Logic) not exported: source is protected"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_Reset:AOI","EnableInFalse","============================================================$NP_Reset:  RESET Enable In False Handling$N============================================================$NOn Enable In False:$N$NClear the bit used to detect Enable In transition from False to True$Nin preparation for the next transition$N$N(See main Logic Routine for Enable In False-to-True triggering of Reset.)$N","OTU(Wrk_EnableInONS)","0"
RCOMMENT,"P_Reset:AOI","EnableInFalse","============================================================$NCONFIGURATION$N============================================================$NThis rung takes the configured Output Hold time and calculates$Nthe appropriate hold timer preset.  A negative preset would fault$Nthe controller and so is disallowed.","OTE(Sts_Err)","1"
RCOMMENT,"P_Reset:AOI","EnableInFalse","============================================================$NCOMMAND AND INPUT HANDLING$N============================================================$NThis rung processes received Reset Commands from:$N$N1.  Higher-level strategies via Program Command$N2.  The Operator via HMI Operator Command$N3.  Pushbuttons or other block via Input, or$N4.  On transition of rung condition from False to True$N(button or other logic as rung condition).$N$NThe reset starts the Hold Timer (One-Shot Off-Delay)$Nto ensure the output is held on for at least the minimum time.","TOF(Wrk_HoldT,?,?)","2"
RCOMMENT,"P_Reset:AOI","EnableInFalse","The Hold Timer $Qdone$Q bit comes on immediately and stays on$Nfor the hold time.  If it, or any held-on reset initiator, is TRUE, set the Output.","OTE(Out_Reset)","3"
RCOMMENT,"P_Reset:AOI","EnableInFalse","If an associated object is ready to be reset, set the Inp_Reset pin on this object.$NThen, if something needs reset, and we$'re not already resetting it, enable this$Nobject$'s Reset Pushbutton.$N$N(If this function is not wired, the button will generally be enabled.$NIf this function IS wired, it is suggested to make the enabled Reset button$NFLASH to alert the operator that a reset is required!)","OTE(Rdy_Reset)","4"
RCOMMENT,"P_Reset:AOI","Logic","============================================================$NP_Reset:  PROCESS -- RESET$N============================================================$NRevision 0.6-01 FOR TEST:  2009-03-16, DER$NAligned name, description and local STRING values, sizes, across instructions.$N============================================================$NThis Instruction provides a command/interface point for resetting$Nalarms, faults or other conditions across a strategy (EM,$NUnit, Cell, Area, Site, etc.).  Its Output is intended to be wired$Nto input, device and interlock instructions to allow a single reset$Ncommand or pushbutton to reset alarms and faults in all objects in its scope.$N============================================================$NPOWER UP OR INVALID STATE$N============================================================$NNo special power up logic is required.$N$N============================================================$NCONFIGURATION$N============================================================$NThis rung takes the configured Output Hold time and calculates$Nthe appropriate hold timer preset.  A negative preset would fault$Nthe controller and so is disallowed and flagged.$N","OTE(Sts_Err)","0"
RCOMMENT,"P_Reset:AOI","Logic","============================================================$NCOMMAND AND INPUT HANDLING$N============================================================$NThis rung processes received Reset Commands from:$N$N1.  Higher-level strategies via Program Command$N2.  The Operator via HMI Operator Command$N3.  Pushbuttons or other block via Input, or$N4.  On transition of rung condition from False to True$N(button or other logic as rung condition).$N$NThe reset starts the Hold Timer (One-Shot Off-Delay)$Nto ensure the output is held on for at least the minimum time.","TOF(Wrk_HoldT,?,?)","1"
RCOMMENT,"P_Reset:AOI","Logic","The Hold Timer $Qdone$Q bit comes on immediately and stays on$Nfor the hold time.  If it, or any held-on reset initiator, is TRUE, set the Output.","OTE(Out_Reset)","2"
RCOMMENT,"P_Reset:AOI","Logic","If an associated object is ready to be reset, set the Inp_Reset pin on this object.$NThen, if something needs reset, and we$'re not already resetting it, enable this$Nobject$'s Reset Pushbutton.$N$N(If this function is not wired, the button will generally be enabled.$NIf this function IS wired, it is suggested to make the enabled Reset button$NFLASH to alert the operator that a reset is required!)","OTE(Rdy_Reset)","3"
RCOMMENT,"P_Reset:AOI","Prescan","============================================================$NPRESCAN (POWERUP) HANDLING$N============================================================$NOn Prescan, clear any $Qlurking$Q Commands.","OTU(PCmd_Reset)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_ResInh:AOI","EnableInFalse","============================================================$NP_ResInh:  RESTART INHIBIT Enable In False Handling$N============================================================$NTreat Enable In False (False Rung) as if$N Inp_Starting = 0, Inp_Running = 0 and Inp_Stopped = 1,$N($'motor stopped$')$N$NThis logic is identical to the main Logic Routine except that actions with the Motor$NRunning or Starting have been removed, and all actions with the Motor$NStopped have been made unconditional.  Adjacent unconditional rungs$Nhave been combined to save memory.$N$N============================================================$NINVALID STATE$N============================================================$NIf the State number is not valid (valid states are 1..12),$N the various timers are reset (all are retentive), and the State Machine is set to:$N$N*  State S01  ( Cold Motor Ready to Start )  if the pump is NOT Running, or$N*  State S03  ( Cold Motor Running )  if the pump is Running.$N","MOV(3,Wrk_State)","0"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","===========================================================================$NCONFIGURATION$N===========================================================================$N$NThis rung gets Configuration data.  Timer Configurations are scaled from seconds to$Nmilliseconds and stored in the appropriate timer presets.$NIf a calculated timer preset is negative, it will fault the controller;$Noverwrite it and flag the configuration as bad.","MOV(Wrk_FirstColdStartT.PRE,Wrk_SecondColdStartT.PRE)","1"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","====================================================================================$NRESTART INHIBIT STATE MACHINE$N====================================================================================$N$NThe following code implements the State Machine logic shown in the Design Document.$N$NThis rung dispatches execution to the code for the current state.  This is to keep from scanning$Nthe code for all the states every scan, and so that certain timers can be shared by multiple states.$N(For State = 1, execution just falls through into the State 1 code.)","JMP(S12)","2"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S01:  COLD MOTOR READY TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the motor is cold, but ready to start.  $NThe time since the last cold start attempt is accumulated.$N$NWhen the motor is started:$NIf it has been at least Last Cold Start minutes since the last attempt was made to start the motor, $Nthe motor is still considered cold, it has had enough time to cool off.  $NIf it has been less than Last Cold Start minutes since the last attempt was made to start the motor, $Nthe motor is considered hot due to multiple re-starts in too short a time period.  $N","OTL(Wrk_Ready)","3"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S02:  COLD MOTOR STARTING  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, a Cold motor start attempt has been made.$NThe time since the last Cold start attempt is accumulated.   $NThe motor must confirm that it is running within RestartInhibit.Wrk_StartCheckTime minutes.  $NIf it does, the state will change to S3: Cold Motor Running$NIf it does not start properly within the allowable time, the state will change to either S4: 1st Failed Cold Restart, or S5: Subsequent Cold Failed Restart.$N","OTL(Wrk_Ready)","5"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S03:  COLD MOTOR RUNNING$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, $NThe time since the last cold start attempt is accumulated.  $NIf the cold motor is turned off, the state will change back to S1: Ready to Start, Cold.","OTL(Wrk_Ready)","8"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S04:  COLD MOTOR FIRST FAILURE TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Cold motor has failed to start for the first time since it was last running properly.$NThe time since the last cold start attempt is accumulated.   $NThe state is changed back to S1: Ready to Start, Cold when RestartInhibit.Wrk_FirstFailCold timer elapses.","SUB(Wrk_FirstFailColdT.PRE,Wrk_FirstFailColdT.ACC,Wrk_mSecUntilReady)","10"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S05:  COLD MOTOR SUBSEQUENT FAILURE TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Cold motor has failed to start at least twice in a row since it was last running properly.$NThe time since the last cold start attempt is accumulated.   $NThe state is changed back to S1: Ready to Start, Cold when RestartInhibit.Wrk_SubsFailCold timer elapses.","SUB(Wrk_SubsFailColdT.PRE,Wrk_SubsFailColdT.ACC,Wrk_mSecUntilReady)","13"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S06:  COLD MOTOR STARTING$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, a Hot motor start attempt has been made.$NThe motor must confirm that it is running within RestartInhibit.Wrk_StartCheckTime minutes.  $NIf it does, the state will change to S7: Hot Motor Running < 4 Hours.$NIf it does not start properly within the allowable time, the state will change to either S10: 1st Failed Hot Restart, or S11: Subsequent Hot Failed Restart.","OTL(Wrk_Ready)","16"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S07:  HOT MOTOR RUNNING  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been started. $NIf it is stopped before RestartInhibit.Wrk_HotRestartOk elapses,$Nit must wait RestartInhibit.Wrk_RestartHot minutes before it can be restarted  (S08).$NIf it is stopped after RestartInhibit.Wrk_HotRestartOk elapses, it can be restarted immediately (S09).","RTO(Wrk_HotRestartOKT,?,?)","19"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S08:  HOT MOTOR SHORT RUN THEN STOPPED$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been stopped before RestartInhibit.Wrk_HotRestartOk elapsed.$NIt must wait RestartInhibit.Wrk_RestartHot minutes before it can be restarted  (S12).","SUB(Wrk_RestartHotT.PRE,Wrk_RestartHotT.ACC,Wrk_mSecUntilReady)","21"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S09:  HOT MOTOR LONG RUN COOLED  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been running long enough to have cooled.$NSince it is stopped (Enable In is false), it can be restarted immediately  (S1).$N","OTL(Wrk_Ready)","24"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S10:  HOT MOTOR FIRST FAILURE TO START $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has failed to start for the first time since it was last running properly.$NThe time since the Hot motor stopped is accumulated.   Once it reaches the First Hot Fail time,$Nit can be restarted  (S12).","SUB(Wrk_FirstFailHotT.PRE,Wrk_FirstFailHotT.ACC,Wrk_mSecUntilReady)","26"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S11:  HOT MOTOR SUBSEQUENT FAILURE TO START$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has failed to start at least twice in a row since it was last running properly.$NThe time since the Hot motor stopped is accumulated.   Once it reaches the Subsequent Hot Fail Time,$Nit can be restarted  (S12).","SUB(Wrk_SubsFailHotT.PRE,Wrk_SubsFailHotT.ACC,Wrk_mSecUntilReady)","29"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S12:  HOT MOTOR READY TO START$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the motor is Hot, but ready to start.  $NThe time since the Hot motor stopped is accumulated.   $NRestartInhibit.Wrk_LastColdStart is run so it is properly timed out when changing to S1: Ready to Start, Cold.  $NIf 16 hours have elapsed since the Hot motor was running, the state will be changed to S1: Ready to Start, Cold.  $NThis reflects the fact that the motor has had time to cool off.  $NOtherwise, the logic waits for a Start attempt to change the state to S6: Start Check, Hot.","RTO(Wrk_HotToColdT,?,?)","32"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","This is common return point for ALL states when Enable In is FALSE.$N$N====================================================================================$NSTART TIMERS$N====================================================================================$N$NThese two rungs run the cold start timers used in the $QThree Starts$Q logic when NOT in State 1.$N","TON(Wrk_SecondColdStartT,?,?)","35"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","====================================================================================$NVALUES$N====================================================================================$N$NThis rung makes sure that the RestartInhibit.Wrk_mSecsUntilReady value is greater than or equal to zero.$NIf it is not, the register value will be cleared.","CLR(Wrk_mSecUntilReady)","37"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","This rung takes the time remaining until the motor is ready to start (in milliseconds), converts it$Nto seconds, then reports it in  minutes : seconds format for display on the HMI or LAWSDAC.","MOD(Wrk_SecUntilReady,60,Val_SecToReady)","38"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","Finally, copy out the internal State number so the HMI can display an animated state diagram.","MOV(Wrk_State,Val_State)","39"
RCOMMENT,"P_ResInh:AOI","Logic","============================================================$NP_ResInh:  PROCESS -- RESTART INHIBIT$N============================================================$NRevision 0.12-02 FOR TEST:  2009-03-16, DER$NAligned name, description and local STRING values, sizes, across instructions.$N============================================================$NThis Instruction monitors starts, running and stops of a motor and decides, based on$Nsimple criteria for winding heating, when the motor can be started again.$N$NThis Instruction is largely State Machine-based.  It has the following states:$N*  S01:  Cold Motor Ready to Start  $N*  S02:  Cold Motor Starting$N*  S03:  Cold Motor Running$N*  S04:  Cold Motor First Failure to Start$N*  S05:  Cold Motor Subsequent Failure to Start$N*  S06:  Hot Motor Starting$N*  S07:  Hot Motor Running$N*  S08:  Hot Motor Short Run Then Stopped$N*  S09:  Hot Motor Long Run Cooled$N*  S10:  Hot Motor First Failure to Start$N*  S11:  Hot Motor Subsequent Failure to Start$N*  S12:  Hot Motor Ready to Start$N$NRefer to the state diagram in the End User Documentation for details.$NNOTE: The state is stored in a Local Tag and not available outside to other$Ninstructions, but can be shown on an HMI.$N============================================================$NINVALID STATE$N============================================================$NIf the State number is not valid (valid states are 1..12),$N the various timers are reset (all are retentive), and the State Machine is set to:$N$N*  State S01  ( Cold Motor Ready to Start )  if the pump is NOT Running, or$N*  State S03  ( Cold Motor Running )  if the pump is Running.","MOV(3,Wrk_State)","0"
RCOMMENT,"P_ResInh:AOI","Logic","===========================================================================$NCONFIGURATION$N===========================================================================$N$NThis rung gets Configuration data.  Timer Configurations are scaled from seconds to$Nmilliseconds and stored in the appropriate timer presets.$NIf a calculated timer preset is negative, it will fault the controller;$Noverwrite it and flag the configuration as bad.","MOV(Wrk_FirstColdStartT.PRE,Wrk_SecondColdStartT.PRE)","1"
RCOMMENT,"P_ResInh:AOI","Logic","====================================================================================$NRESTART INHIBIT STATE MACHINE$N====================================================================================$N$NThe following code implements the State Machine logic shown in the Design Document.$N$NThis rung dispatches execution to the code for the current state.  This is to keep from scanning$Nthe code for all the states every scan, and so that certain timers can be shared by multiple states.$N(For State = 1, execution just falls through into the State 1 code.)","JMP(S12)","2"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S01:  COLD MOTOR READY TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the motor is cold, but ready to start.  $NThe time since the last cold start attempt is accumulated.$N$NWhen the motor is started:$NIf it has been at least Last Cold Start minutes since the last attempt was made to start the motor, $Nthe motor is still considered cold, it has had enough time to cool off.  $NIf it has been less than Last Cold Start minutes since the last attempt was made to start the motor, $Nthe motor is considered hot due to multiple re-starts in too short a time period.  ","OTL(Wrk_Ready)","3"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S02:  COLD MOTOR STARTING  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, a Cold motor start attempt has been made.$NThe time since the last Cold start attempt is accumulated.   $NThe motor must confirm that it is running within RestartInhibit.Wrk_StartCheckTime minutes.  $NIf it does, the state will change to S3: Cold Motor Running$NIf it does not start properly within the allowable time, the state will change to either S4: 1st Failed Cold Restart, or S5: Subsequent Cold Failed Restart.","OTL(Wrk_Ready)","9"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S03:  COLD MOTOR RUNNING$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, $NThe time since the last cold start attempt is accumulated.  $NIf the cold motor is turned off, the state will change back to S1: Ready to Start, Cold.","OTL(Wrk_Ready)","13"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S04:  COLD MOTOR FIRST FAILURE TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Cold motor has failed to start for the first time since it was last running properly.$NThe time since the last cold start attempt is accumulated.   $NThe state is changed back to S1: Ready to Start, Cold when RestartInhibit.Wrk_FirstFailCold timer elapses.","SUB(Wrk_FirstFailColdT.PRE,Wrk_FirstFailColdT.ACC,Wrk_mSecUntilReady)","16"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S05:  COLD MOTOR SUBSEQUENT FAILURE TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Cold motor has failed to start at least twice in a row since it was last running properly.$NThe time since the last cold start attempt is accumulated.   $NThe state is changed back to S1: Ready to Start, Cold when RestartInhibit.Wrk_SubsFailCold timer elapses.","SUB(Wrk_SubsFailColdT.PRE,Wrk_SubsFailColdT.ACC,Wrk_mSecUntilReady)","19"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S06:  HOT MOTOR STARTING$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, a Hot motor start attempt has been made.$NThe motor must confirm that it is running within RestartInhibit.Wrk_StartCheckTime minutes.  $NIf it does, the state will change to S7: Hot Motor Running < 4 Hours.$NIf it does not start properly within the allowable time, the state will change to either S10: 1st Failed Hot Restart, or S11: Subsequent Hot Failed Restart.","OTL(Wrk_Ready)","22"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S07:  HOT MOTOR RUNNING  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been started. $NIf it is stopped before RestartInhibit.Wrk_HotRestartOk elapses,$Nit must wait RestartInhibit.Wrk_RestartHot minutes before it can be restarted  (S08).$NIf it is stopped after RestartInhibit.Wrk_HotRestartOk elapses, it can be restarted immediately (S09).","RTO(Wrk_HotRestartOKT,?,?)","26"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S08:  HOT MOTOR SHORT RUN THEN STOPPED$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been stopped before RestartInhibit.Wrk_HotRestartOk elapsed.$NIt must wait RestartInhibit.Wrk_RestartHot minutes before it can be restarted  (S12).","SUB(Wrk_RestartHotT.PRE,Wrk_RestartHotT.ACC,Wrk_mSecUntilReady)","30"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S09:  HOT MOTOR LONG RUN COOLED  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been running long enough to have cooled.$NWhen it is eventually stopped, it can be restarted immediately as a cold motor  (S1).","OTL(Wrk_Ready)","33"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S10:  HOT MOTOR FIRST FAILURE TO START $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has failed to start for the first time since it was last running properly.$NThe time since the Hot motor stopped is accumulated.   Once it reaches the First Hot Fail time,$Nit can be restarted  (S12).","SUB(Wrk_FirstFailHotT.PRE,Wrk_FirstFailHotT.ACC,Wrk_mSecUntilReady)","36"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S11:  HOT MOTOR SUBSEQUENT FAILURE TO START$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has failed to start at least twice in a row since it was last running properly.$NThe time since the Hot motor stopped is accumulated.   Once it reaches the Subsequent Hot Fail Time,$Nit can be restarted  (S12).","SUB(Wrk_SubsFailHotT.PRE,Wrk_SubsFailHotT.ACC,Wrk_mSecUntilReady)","39"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S12:  HOT MOTOR READY TO START$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the motor is Hot, but ready to start.  $NThe time since the Hot motor stopped is accumulated.   $NRestartInhibit.Wrk_LastColdStart is run so it is properly timed out when changing to S1: Ready to Start, Cold.  $NIf 16 hours have elapsed since the Hot motor was running, the state will be changed to S1: Ready to Start, Cold.  $NThis reflects the fact that the motor has had time to cool off.  $NOtherwise, the logic waits for a Start attempt to change the state to S6: Start Check, Hot.","RTO(Wrk_HotToColdT,?,?)","42"
RCOMMENT,"P_ResInh:AOI","Logic","This is common return point for all states except State 1.$N$N====================================================================================$NSTART TIMERS$N====================================================================================$N$NThese two rungs run the cold start timers used in the $QThree Starts$Q logic when NOT in State 1.","TON(Wrk_SecondColdStartT,?,?)","46"
RCOMMENT,"P_ResInh:AOI","Logic","This code is common for ALL states.$N$N====================================================================================$NVALUES$N====================================================================================$N$NThis rung makes sure that the RestartInhibit.Wrk_mSecsUntilReady value is greater than or equal to zero.$NIf it is not, the register value will be cleared.","CLR(Wrk_mSecUntilReady)","48"
RCOMMENT,"P_ResInh:AOI","Logic","This rung takes the time remaining until the motor is ready to start (in milliseconds), converts it$Nto seconds, then reports it in  minutes : seconds format for display on the HMI or LAWSDAC.","MOD(Wrk_SecUntilReady,60,Val_SecToReady)","49"
RCOMMENT,"P_ResInh:AOI","Logic","Finally, copy out the internal State number so the HMI can display an animated state diagram.","MOV(Wrk_State,Val_State)","50"
RCOMMENT,"P_ResInh:AOI","Prescan","============================================================$NPRESCAN / POWER UP$N============================================================$NOn Prescan, the various timers are reset (all are retentive), and the State$NMachine is set to:$N*  State S01  ( Cold Motor Ready to Start )  if the pump is NOT Running, or$N*  State S03  ( Cold Motor Running )  if the pump is Running.$N","MOV(3,Wrk_State)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_RunTime:AOI","EnableInFalse","============================================================$NENABLE-IN FALSE HANDLING$N============================================================$NEnable In False is treated the same as $QMotor Stopped$Q --$NCommands are still processed, $Ntotal run time is held (RTO), the Starts counter is prepared for$Nthe next start (.CU clears on CTU with AFI), and the$NCurrent Run Time is cleared (TON false).$N============================================================$NCOMMAND PROCESSING$N============================================================$NThese rungs handle received Commands.  This object has no Modes and$NCommands are accepted regardless of Mode.  Commands should be$Nrestricted to authorized personnel (typically at a maintenance level).$N$NPCmd_ClearTotHrs: Program Command to Clear Total Runtime Hours$NMCmd_ClearTotHrs: Maintenance Command to Clear Total Runtime Hours$N","CLR(Wrk_TotTenths)","0"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","PCmd_ClearStarts: Program Command to Clear Count of Starts$NMCmd_ClearStarts: Maintenance Command to Clear Count of Starts","RES(Wrk_Starts)","1"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","PCmd_ClearMaxHrs: Program Command to Clear Maximum Single Run Hours$NMCmd_ClearMaxHrs: Maintenance Command to Clear Maximum Single Run Hours","CLR(Val_MaxRunHrs)","2"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","============================================================$NENABLE-IN FALSE HANDLING$N============================================================$NEnable In False is treated the same as $QMotor Stopped$Q --$NTotal run time is held (RTO), the Starts counter is prepared for$Nthe next start (.CU clears on CTU with AFI), and the$NCurrent Run Time is cleared (TON false).$N$NNOTE: IN ORDER TO AVOID USING AN AFI (resulting in routine verification warnings in V17),$NTHIS RUNG USES AN XIC AND XIO OF THE SAME BIT TO ENSURE THE$NTIMERS AND COUNTER ARE SCANNED FALSE.$N$NTHIS IS NOT DEAD CODE.  IT IS INTENTIONALLY CODED THIS WAY FOR PROPER OPERATION.$N","TON(Wrk_CurRunT,?,?)","3"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","============================================================$NREPORT VALUES$N============================================================$N$NThe number of starts is directly reported as an integer Value.","MOV(Wrk_Starts.ACC,Val_Starts)","4"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","The current hours working register is cleared, but the Value is left$Nin place for display until the next run begins.$N$NNOTE: The Maximum Run Hours (high-water of Current Run Hours)$Nis also left in place.","CLR(Wrk_CurHours)","5"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","The Total Running Time is reported as a REAL number of Hours.$N(This will always be in $Qcompleted tenths$Q of an hour, like a mechanical hours counter.)","MUL(Wrk_TotTenths,0.1,Val_TotRunHrs)","6"
RCOMMENT,"P_RunTime:AOI","Logic","============================================================$NP_RunTime:  PROCESS -- RUN TIME AND STARTS$N============================================================$NRevision 0.7-04 FOR TEST:  2009-03-16, DER$NAligned name, description and local STRING values, sizes, across instructions.$N============================================================$NThis Instruction monitors the $QRunning$Q and $QStarting$Q Status of a motor or other device and  provides:$N$N*  Total accumulated run time, in 1/10 hour increments (hour meter)$N*  Total number of starts or start attemptes (count)$N*  Maximum continuous run time for any start (hours)$N* Commands to allow clearing of the totals/maximum$N============================================================$NCOMMAND PROCESSING$N============================================================$NThese rungs handle received Commands.  This object has no Modes and$NCommands are accepted regardless of Mode.  Commands should be$Nrestriceted to authorized personnel (typically at a maintenance level).$N$NPCmd_ClearTotHrs: Program Command to Clear Total Runtime Hours$NMCmd_ClearTotHrs: Maintenance Command to Clear Total Runtime Hours","CLR(Wrk_TotTenths)","0"
RCOMMENT,"P_RunTime:AOI","Logic","PCmd_ClearStarts: Program Command to Clear Count of Starts$NMCmd_ClearStarts: Maintenance Command to Clear Count of Starts","RES(Wrk_Starts)","1"
RCOMMENT,"P_RunTime:AOI","Logic","PCmd_ClearMaxHrs: Program Command to Clear Maximum Single Run Hours$NMCmd_ClearMaxHrs: Maintenance Command to Clear Maximum Single Run Hours","CLR(Wrk_MaxHours)","2"
RCOMMENT,"P_RunTime:AOI","Logic","Clear current run hours if stopped.$NNOTE: Val_CurHours is maintained for display!","CLR(Wrk_CurHours)","3"
RCOMMENT,"P_RunTime:AOI","Logic","============================================================$NACCUMULATE TIMES / STARTS$N============================================================$NThis rung runs the Total (retentive) and Maximum (non-retentive) Run Time$Ntimers and increments the Number of Starts counter  whenever$N the motor/device is Starting or Running (contactor energized...).$N$NNOTE:  The counter only counts on the rising edge of the rung.  As long as$Nthere$'s no delay between Starting going OFF and Running coming ON, this will work fine.","TON(Wrk_CurRunT,?,?)","4"
RCOMMENT,"P_RunTime:AOI","Logic","Note that an RTO timer can only time up to 2G milliseconds, about 28 days.$NA pump will accumulate much more run time.  So the RTO is used to time 1/10 hour,$Nwhich is then added to a count of $QTenths of Hours$Q.  Then the RTO accumulator is reduced by 1/10 hour.$N(The timer doesn$'t lose time because it is not reset and keeps running.)","SUB(Wrk_TotRunT.ACC,360000,Wrk_TotRunT.ACC)","5"
RCOMMENT,"P_RunTime:AOI","Logic","The Maximum Run Time TON is treated the same way.  A motor/device$Ncould potentially run continuously for more than 28 days, so an integer count$Nof (up to 2 billion) hours (almost 245,000 years!) is used.  Should be enough...","SUB(Wrk_CurRunT.ACC,3600000,Wrk_CurRunT.ACC)","6"
RCOMMENT,"P_RunTime:AOI","Logic","============================================================$NREPORT VALUES$N============================================================$N$NThe number of starts is directly reported as an integer Value.","MOV(Wrk_Starts.ACC,Val_Starts)","7"
RCOMMENT,"P_RunTime:AOI","Logic","The Current (continuous) Run Time is reported as a REAL number of Hours.$NThis number includes all fractional hours (timer accumulator / 3,600,000 ms/hr),$Nnot just completed tenths like the total run time below.","CPT(Val_CurRunHrs,Wrk_CurHours+(Wrk_CurRunT.ACC/3600000.0))","8"
RCOMMENT,"P_RunTime:AOI","Logic","If the Current Run Time exceeds the stored Maximum Run Time,$Nupdate the Maximum.$NRegardless, report the Maximum Run Time.$N$NNOTE:  The Wrk_MaxHours register is required to prevent writes to Val_MaxHours$Nfrom improperly overwriting this object$'s state.$N","MOV(Wrk_MaxHours,Val_MaxRunHrs)","9"
RCOMMENT,"P_RunTime:AOI","Logic","The Total Running Time is reported as a REAL number of Hours.$N(This will always be in $Qcompleted tenths$Q of an hour, like a mechanical hours counter.)","MUL(Wrk_TotTenths,0.1,Val_TotRunHrs)","10"
RCOMMENT,"P_RunTime:AOI","Prescan","============================================================$NPOWER UP / PRESCAN HANDLING$N============================================================$NTotal run time, Maximum run time and starts count are retained through$Na power cycle.  Current run time is reset (internally only,$NVal_CurHours is maintained for display!).$N","CLR(Wrk_CurHours)","0"
RCOMMENT,"P_RunTime:AOI","Prescan","On Prescan, clear any $Qlurking$Q Commands.","OTU(PCmd_ClearStarts)","1"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_VSD:AOI","EnableInFalse","============================================================$NOFF-SCAN (Enable In is False) STATUS$N============================================================$N$NIf this Drive is OFF-SCAN (rung is false or Enable In is false in FBD), then:$N$NReset the Alarm Timers$NClear the Alarms$NShow the Drive as $QDisabled$Q$NShow the Drive as Running or Stopped, based on the feedback input$NTurn off the Outputs, zero the Speed Reference.$N$NOther data are left in Last State!$N","OTU(Out_Rev)","0"
RCOMMENT,"P_VSD:AOI","EnableInFalse","The Running Status (Sts_Running) bit shows if the drive is running,$Neven though the drive is Disabled by being on a false rung.","OTE(Sts_Running)","1"
RCOMMENT,"P_VSD:AOI","EnableInFalse","The Stopped Status (Sts_Stopped) bit shows if the drive is stopped,$Neven though the drive is Disabled by being on a false rung.","OTE(Sts_Stopped)","2"
RCOMMENT,"P_VSD:AOI","EnableInFalse","The remaining actual drive status bits are passed through to Status,$Neven though the drive is Disabled by being on a false rung.","OTE(Sts_NotReady)","3"
RCOMMENT,"P_VSD:AOI","EnableInFalse","============================================================$NVALUES PROCESSING$N============================================================$NThis rung outputs instruction Values:$N$NVal_SpeedFdbk (actual running speed), if not in simulation,$Nfrom Input.  If in simulation, simulate accel/decel.","CPT(Val_SpeedFdbk,Cfg_SpeedFdbkEUMin+(Cfg_SpeedFdbkEUMax-Cfg_SpeedFdbkEUMin)/(Cfg_SpeedFdbkRawMax-Cfg_SpeedFdbkRawMin)*(Inp_SpeedFdbk-Cfg_SpeedFdbkRawMin))","4"
RCOMMENT,"P_VSD:AOI","EnableInFalse","This rung publishes the Values for the scaled speed feedback range.$NIf this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$Nthe values are swapped so the EUMax Value is always greater than the EUMin Value.$NThis makes the HMI bargraph and trend coding easier, and provides values$Nthat can be pinned to the configuration of a PID, so the VSD and PID ranges are in lockstep.$N","MOV(Cfg_SpeedFdbkEUMax,Val_SpeedFdbkEUMin)","5"
RCOMMENT,"P_VSD:AOI","EnableInFalse","Alarms are turned off when off-scan or out of service, so clear the Notification Level.","CLR(Val_Notify)","7"
RCOMMENT,"P_VSD:AOI","EnableInFalse","$QLurking$Q Operator Commands are cleared, as well as Program Reset.","OTU(PCmd_Reset)","8"
RCOMMENT,"P_VSD:AOI","EnableInFalse","$QLurking$Q Program Commands are cleared if they are set as $QEdge$Q triggered$N(cleared by this object as received).$N(Lurking Acknowledge Commands are left to perform their action.)","OTU(PCmd_IOFaultUninhibit)","9"
RCOMMENT,"P_VSD:AOI","EnableInFalse","Handle $QNO MODE$Q Selection using the standard P_Mode AOI (Enable In False Routine, AFI required!).$N$NNOTE:  IN ORDER TO AVOID USING AN $QAFI$Q (which will generate a routine verify warning),$NTHIS RUNG USES AN XIC of Cfg_PCmdClear, followed by an XIO of the SAME BIT$Nto ensure P_Mode is SCANNED FALSE ($QNO MODE$Q).$N$NTHIS IS NOT DEAD CODE AND MUST APPEAR EXACTLY AS SHOWN FOR PROPER OPERATION!$N","OTU(Sts_ProgOperLock)","10"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NP_VSD :  PROCESS -- VARIABLE-SPEED DRIVE$N============================================================$NRevision 0.15-01 FOR TEST:  2009-03-16, DER$NAligned name, description and local STRING values, sizes, across instructions.$N============================================================$NThis Instruction controls and monitors a Variable-Speed Drive (AC or DC) and provides:$N$N*  Starting, stopping, jogging of drive, setting speed reference and direction$N*  Monitoring of run feedback, display of actual drive status, including accel, decel, direction, speed$N*  Detection of Failure to Start, Failure to Stop, Drive Fault$N*  Monitoring of Permissive conditions to allow starting$N* Monitoring of Interlock conditions to stop / prevent starting$N* Simulation, providing feedback of a working drive while disabling outputs$N* Monitoring of I/O communication faults$N* Alarms for Fail to Start, Fail to Stop, Interlock Trip, Drive Fault, I/O Fault$N* Operation in Hand, Maintenance, Override, Program and Operator Modes$N* $QAvailable$Q status for use by automation logic to know whether Drive$Ncan be controlled by other objects.$N============================================================$NPOWER UP / INVALID STATE HANDLING$N============================================================$NMode states are retained through a power cycle.$NDrive $Qrun$Q request is cleared on first scan, in the rung which unlatches $QWrk_Run$Q, below$N============================================================$NMODE PROCESSING$N============================================================$NThese rungs handle received Mode Inputs and Commands:$N$NNOTE:  Operator Commands for Mode, Alarm are sent directly to the contained P_Mode and P_Alarm AOIs.$N$NInp_Hand: forward the Hand Input directly to the Mode instruction.$N","OTE(Mode.Inp_Hand)","0"
RCOMMENT,"P_VSD:AOI","Logic","Inp_Ovrd: forward the Override Input directly to the Mode instruction.","OTE(Mode.Inp_Ovrd)","1"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_Acq: Program Command to Acquire ownership","OTU(Mode.PCmd_Acq)","2"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_Rel: Program Command to Release ownership (to OOS)","OTL(Mode.PCmd_Rel)","3"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_Lock: Program Command to Lock ownership in Prog Mode","OTU(Mode.PCmd_Lock)","4"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_Unlock: Program Command to Unlock Mode","OTL(Mode.PCmd_Unlock)","5"
RCOMMENT,"P_VSD:AOI","Logic","Handle Mode Selection using the standard P_Mode AOI","Mode(Mode)","6"
RCOMMENT,"P_VSD:AOI","Logic","This rung handles simple First-Come First-Served Ownership Arbitration.$NIf a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$NOwnership is assigned to the requesting ID.  When that requestor sets the Owner ID back$Nto zero, Ownership is relinquished back to NONE.","MOV(PSet_Owner,Val_Owner)","7"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NCONFIGURATION$N============================================================$N$NThese rungs get Configuration data (such as timer presets) and distribute as needed.$NNote that some Configuration data are used directly in-place.$N$NEnter the time (in seconds) for the Drive to successfully start before declaring a fault.$NEnter the time (in seconds) for the Drive to successfully stop before declaring a fault.$NEnter the time (in seconds) for the Drive Fault Reset output to be pulsed when a reset is received.$N$NIf the timer preset calculated wraps negative (more than 2.14... million seconds), then max out the$Nor clear the Timer Preset (as appropriate) and flag it.  Note that a negative timer preset will fault the controller!!!$N","OTE(Err_Timer)","8"
RCOMMENT,"P_VSD:AOI","Logic","Enter the time (in seconds) to ramp up the simulated speed feedback when starting in simulation.$NThe same time is used for ramping down when stopping.$N$NHandle timer preset invalid values as above.","MOV(Wrk_AccelT.PRE,Wrk_DecelT.PRE)","9"
RCOMMENT,"P_VSD:AOI","Logic","If the Drive does not even have a Run Feedback input,$Nit cannot be used for Drive feedback checking!","OTU(Cfg_UseRunFdbk)","10"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NRUN FEEDBACK DETERMINATION$N============================================================$NIf the Drive is being simulated or has no run feedback, use the Sim Timers to provide$Na $Qfake$Q feedback signal based on the simulation time to start and time to stop.$N$NIf the Drive is NOT being simulated and it HAS and IS USING a run feedback,$Nuse the state of the run feedback input as the Drive run state.","OTU(Wrk_RunFdbk)","11"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NSETTINGS PROCESSING$N============================================================$NThis rung handles received Settings:$N$NWhen the Mode is Program, use the Program Setting for the Speed Reference.$NWhen the Mode is Operator or Maintenance, use the Operator Setting for the Speed Reference.$NWhen the Mode is Override, use the Override Speed Reference input.","MOV(Inp_OvrdSpeed,Wrk_SpeedRef)","12"
RCOMMENT,"P_VSD:AOI","Logic","Check the selected speed reference against the configured Maximum and Minimum$Nallowed reference limits and ensure the speed is within limits.$NBe sure the speed reference is not negative.  This object supports reversing$Nby command only; negative speed reference is NOT supported!","OTE(Sts_SpeedLimited)","13"
RCOMMENT,"P_VSD:AOI","Logic","Check the selected Output Data link against its configured Maximum and Minimum$Nallowed limits and ensure the setting is within limits.$N","MOV(Cfg_OutDatalinkMin,Wrk_OutDatalink)","14"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NCOMMAND HANDLING$N============================================================$NThese rungs receive and handle the Commands for this Drive.$N$NThe Bypass Command bypasses only the Bypass able Permissive and Interlocks.$N","OTL(Wrk_Bypass)","15"
RCOMMENT,"P_VSD:AOI","Logic","The Check Command enables checking of ALL$NPermissive and Interlocks (cancels the bypass).$N","OTU(Wrk_Bypass)","16"
RCOMMENT,"P_VSD:AOI","Logic","The Disable Command disables the Drive so it cannot be run.","OTL(Wrk_Disabled)","17"
RCOMMENT,"P_VSD:AOI","Logic","The Enable Command cancels the Disable and allows the Drive to run.","OTU(Wrk_Disabled)","18"
RCOMMENT,"P_VSD:AOI","Logic","The Reverse Command sets drive to run in reverse direction.","OTL(Wrk_Rev)","19"
RCOMMENT,"P_VSD:AOI","Logic","The Forward Command sets drive to run in forward direction.","OTU(Wrk_Rev)","20"
RCOMMENT,"P_VSD:AOI","Logic","These next several rungs, in priority order, determine whether$Nthe drive should be running, jogging or stopped.$N$NIf a Drive START command is received in Operator, Program or Maintenance$NMode, or if in Override Mode and the Override State is RUN, mark the Drive to RUN.$NPermissive must be OK or bypassed to start the Drive (Interlocks are checked below...).$NThe drive must be READY (or in simulation), and the drive can$'t already be jogging.$N(Modes are mutually exclusive, thus handling the priority.)$N","OTL(Wrk_Run)","21"
RCOMMENT,"P_VSD:AOI","Logic","This rung determines if the Drive SHOULD BE JOGGING.  This is when:$N$N* The Operator is requesting to Jog$N* The Drive is in OPER or MAINT$N* Permissives and Interlocks are OK or bypassed if in OPER$N* Non-Bypassable Interlocks and Permissives are OK,$N* The drive is Ready (or in simulation), AND$N* The drive is not otherwise requested to RUN","OTL(Wrk_Jog)","22"
RCOMMENT,"P_VSD:AOI","Logic","If the drive is changed to Override or Program Mode, or if the Jog command$Ngoes away, stop jogging.","OTU(Wrk_Jog)","23"
RCOMMENT,"P_VSD:AOI","Logic","If a Drive STOP command is received in Operator, Program or Maintenance$NMode, or if in Override Mode and the Override State is STOP,$Nmark the Drive TO STOP (jogging or running).","OTU(Wrk_Jog)","24"
RCOMMENT,"P_VSD:AOI","Logic","Higher Priority:$NIf Interlocks are not OK (Non-Bypass able not OK, or bypass able not OK$Nand not bypassed by Maintenance, Override or Bypass Command), $NOR if the Drive is DISABLED or FAULTED, set it to STOP.$N$NIf we tripped on an Interlock while running or jogging, also issue the Interlock Trip Alarm.$N","OTU(Wrk_Jog)","25"
RCOMMENT,"P_VSD:AOI","Logic","Highest Priority: HAND always wins:$NIf in Hand, have the Drive follow the RunFeedback.","OTU(Wrk_Run)","26"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NALARM AND DRIVE RESET COMMAND HANDLING$N============================================================$NThis rung processes received Reset Commands from:$N$N1.  Higher-level strategies via Program Command$N2.  The Operator via HMI Operator Command$N3.  Pushbuttons or other block via Input, or$N$NThe reset starts the Reset Timer (One-Shot Off-Delay)$Nto ensure the output is held on for at least the minimum time.","TOF(Wrk_ResetT,?,?)","27"
RCOMMENT,"P_VSD:AOI","Logic","The Hold Timer $Qdone$Q bit comes on immediately and stays on$Nfor the hold time.  If it, or any held-on reset initiator, is TRUE, set the Output.","OTL(DriveFault.PCmd_Reset)","28"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NDrive FAIL TO START ALARMING$N============================================================$NIf the Drive SHOULD BE RUNNING, run a Start Timer to check for Fail to Start, and run a$NSimulation Timer to provide simulated run feedback if needed.","TON(Wrk_AccelT,?,?)","29"
RCOMMENT,"P_VSD:AOI","Logic","If the Start Timer times out and the Drive run feedback (or simulated feedback) never showed up,$Nshow the Drive as $QFAILED TO START$Q and issue an Alarm.","OTE(FailToStart.Inp)","30"
RCOMMENT,"P_VSD:AOI","Logic","If this alarm DOES NOT EXIST:$N*  ignore its configuration errors -- the HMI will have the config grayed out;$N*  it won$'t respond to a Reset, so don$'t include it in the $Qreset required$Q (ready to reset) logic;$N* it should not be counted in the overall alarm severity/unacknowledged display (Val_Notify);$N*  it won$'t respond to Program Commands, so clear any $Qlurking$Q ones;$N*  and skip the remaining alarm code to optimize scan time.$N","JMP(FailToStopAlarm)","31"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStartAck: Program Command to Acknowledge the Fail to Start Alarm","OTL(FailToStart.PCmd_Ack)","32"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStartInhibit: Program Command to Inhibit the Fail to Start Alarm","OTL(FailToStart.PCmd_Uninhibit)","33"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStartUninhibit: Program Command to Uninhibit the Fail to Start Alarm","OTL(FailToStart.PCmd_Uninhibit)","34"
RCOMMENT,"P_VSD:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAck Reqd: Alarm must be acknowledged to clear$NReset Reqd: Alarm latched in, must be cleared via Reset Command$NMin Duration: Alarm must stay on at least this long to be seen by HMI poll","CLR(FailToStart.Cfg_MinDuration)","35"
RCOMMENT,"P_VSD:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(FailToStart)","36"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NDrive FAIL TO STOP ALARMING$N============================================================$NIf the Drive SHOULD BE STOPPED, run a Stop Timer to check for Fail to Stop, and run a$NSimulation Timer to provide simulated run feedback off (stop feedback) if needed.","TON(Wrk_DecelT,?,?)","37"
RCOMMENT,"P_VSD:AOI","Logic","If the Stop Timer times out and the Drive run feedback (or simulated feedback) never showed $Qstopped$Q,$Nshow the Drive as $QFAILED TO STOP$Q and issue an Alarm.","OTE(FailToStop.Inp)","38"
RCOMMENT,"P_VSD:AOI","Logic","If this alarm DOES NOT EXIST:$N*  ignore its configuration errors -- the HMI will have the config grayed out;$N*  it won$'t respond to a Reset, so don$'t include it in the $Qreset required$Q (ready to reset) logic;$N* it should not be counted in the overall alarm severity/unacknowledged display (Val_Notify);$N*  it won$'t respond to Program Commands, so clear any $Qlurking$Q ones;$N*  and skip the remaining alarm code to optimize scan time.$N","JMP(IntlkTripAlarm)","39"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStopAck: Program Command to Acknowledge the Fail to Stop Alarm","OTL(FailToStop.PCmd_Ack)","40"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStopInhibit: Program Command to Inhibit the Fail to Stop Alarm","OTL(FailToStop.PCmd_Uninhibit)","41"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStopUninhibit: Program Command to Uninhibit the Fail to Stop Alarm","OTL(FailToStop.PCmd_Uninhibit)","42"
RCOMMENT,"P_VSD:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAck Reqd: Alarm must be acknowledged to clear$NReset Reqd: Alarm latched in, must be cleared via Reset Command$NMin Duration: Alarm must stay on at least this long to be seen by HMI poll","CLR(FailToStop.Cfg_MinDuration)","43"
RCOMMENT,"P_VSD:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(FailToStop)","44"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NDrive INTERLOCK TRIP ALARMING$N============================================================$NIf the INTERLOCKS NOT OK caused the Drive to stop in the  ---( U )---- Wrk_Run$Nrung above, raise an INTERLOCK TRIP ALARM.","OTE(IntlkTrip.Inp)","45"
RCOMMENT,"P_VSD:AOI","Logic","If this alarm DOES NOT EXIST:$N*  ignore its configuration errors -- the HMI will have the config grayed out;$N*  it won$'t respond to a Reset, so don$'t include it in the $Qreset required$Q (ready to reset) logic;$N* it should not be counted in the overall alarm severity/unacknowledged display (Val_Notify);$N*  it won$'t respond to Program Commands, so clear any $Qlurking$Q ones;$N*  and skip the remaining alarm code to optimize scan time.$N","JMP(DriveFaultAlarm)","46"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IntlkTripAck: Program Command to Acknowledge the Interlock Trip Alarm","OTL(IntlkTrip.PCmd_Ack)","47"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IntlkTripInhibit: Program Command to Inhibit the Interlock Trip Alarm","OTL(IntlkTrip.PCmd_Uninhibit)","48"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IntlkTripUninhibit: Program Command to Uninhibit the Interlock trip Alarm","OTL(IntlkTrip.PCmd_Uninhibit)","49"
RCOMMENT,"P_VSD:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAck Reqd: Alarm must be acknowledged to clear$NReset Reqd: Alarm latched in, must be cleared via Reset Command$NMin Duration: Alarm must stay on at least this long to be seen by HMI poll","CLR(IntlkTrip.Cfg_MinDuration)","50"
RCOMMENT,"P_VSD:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(IntlkTrip)","51"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NDRIVE FAULT ALARMING$N============================================================$NIf the DRIVE FAULT Input is TRUE or the DRIVE READY  Input is FALSE,$Nand the drive is not being Simulated, raise a DRIVE FAULT ALARM.","OTE(DriveFault.Inp)","52"
RCOMMENT,"P_VSD:AOI","Logic","If this alarm DOES NOT EXIST:$N*  ignore its configuration errors -- the HMI will have the config grayed out;$N*  it won$'t respond to a Reset, so don$'t include it in the $Qreset required$Q (ready to reset) logic;$N* it should not be counted in the overall alarm severity/unacknowledged display (Val_Notify);$N*  it won$'t respond to Program Commands, so clear any $Qlurking$Q ones;$N*  and skip the remaining alarm code to optimize scan time.","JMP(IOFaultAlarm)","53"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_DriveFaultAck: Program Command to Acknowledge the Drive Fault Alarm","OTL(DriveFault.PCmd_Ack)","54"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_DriveFaultInhibit: Program Command to Inhibit the Drive Fault Alarm","OTL(DriveFault.PCmd_Uninhibit)","55"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_DriveFaultUninhibit: Program Command to Uninhibit the Drive Fault Alarm","OTL(DriveFault.PCmd_Uninhibit)","56"
RCOMMENT,"P_VSD:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAck Reqd: Alarm must be acknowledged to clear$NReset Reqd: Alarm latched in, must be cleared via Reset Command$NMin Duration: Alarm must stay on at least this long to be seen by HMI poll","CLR(DriveFault.Cfg_MinDuration)","57"
RCOMMENT,"P_VSD:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(DriveFault)","58"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NI/O FAULT ALARMING$N============================================================$NIf the I/O FAULT input is true and the I/O are not being SIMULATED,\$Nthen there is an I/O Fault.  Raise an Alarm and stop the Drive.","OTE(IOFault.Inp)","59"
RCOMMENT,"P_VSD:AOI","Logic","If this alarm DOES NOT EXIST:$N*  ignore its configuration errors -- the HMI will have the config grayed out;$N*  it won$'t respond to a Reset, so don$'t include it in the $Qreset required$Q (ready to reset) logic;$N* it should not be counted in the overall alarm severity/unacknowledged display (Val_Notify);$N*  it won$'t respond to Program Commands, so clear any $Qlurking$Q ones;$N*  and skip the remaining alarm code to optimize scan time.","JMP(Faults)","60"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IOFaultAck: Program Command to Acknowledge the I/O Fault Alarm","OTL(IOFault.PCmd_Ack)","61"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IOFaultInhibit: Program Command to Inhibit the I/O Fault Alarm","OTL(IOFault.PCmd_Uninhibit)","62"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IOFaultUninhibit: Program Command to Uninhibit the I/O Fault Alarm","OTL(IOFault.PCmd_Uninhibit)","63"
RCOMMENT,"P_VSD:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAck Reqd: Alarm must be acknowledged to clear$NReset Reqd: Alarm latched in, must be cleared via Reset Command$NMin Duration: Alarm must stay on at least this long to be seen by HMI poll","CLR(IOFault.Cfg_MinDuration)","64"
RCOMMENT,"P_VSD:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(IOFault)","65"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NOUTPUT GENERATION$N============================================================$N$NIf the Drive is NOT SIMULATED and NOT OUT OF SERVICE, generate the$Nappropriate outputs for the Drive.$NIf the Drive should be running, is not faulted and not in hardwired control, energize Out_Run.$NAlso, energize Out_Start until we get feedback that the Drive is running.$N$NIf the Drive should be stopped and is not in hardwired control and the feedback shows the Drive$Nis NOT stopped, or if the Drive is Faulted, energize the Out_Stop output to stop the Drive.$N","OTE(Out_Rev)","67"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NSTATUS GENERATION$N============================================================$N$NThe following rungs generates Status bits for this object.$N$NThese Status bits are a copy of the internal Mode AOI bits for$NHand, Maint, Ovrd, Prog, Oper, and mode Locked.$N$NNOTE for Sts_Maint:  This Drive is in Maintenance (Out Of Service, no able to run normally)$Nif this instruction is on a False Rung (Enable In False).  See the Enable In False Routine.","OTE(Sts_ProgOperLock)","70"
RCOMMENT,"P_VSD:AOI","Logic","This rung handles the reports of all Bad Configuration Status.$NIndividual bits are provided for various status:$NBad Raw Scaling configs$NBad Engineering Units Scaling configs$NBad 1st-Order Filter configs$NBad Alarm Dead band configs$NBad Alarm Minimum Duration configs$N$NThen a summary Bad Config status is provided, simply an OR of the individual bits.$N","OTE(Sts_Err)","71"
RCOMMENT,"P_VSD:AOI","Logic","Status bits are a copy of the internal Alarm AOI bits when the alarm exists.$NIf it doesn$'t, Alm, Sts_Disabled, Sts_Inhibited and Sts_Suppressed are cleared$Nand Ack is set to keep HMI happy for the alarm and the $QI$Q icon on the graphic symbol.$N","OTE(Ack_FailToStart)","72"
RCOMMENT,"P_VSD:AOI","Logic","Status bits are a copy of the internal Alarm AOI bits when the alarm exists.$NIf it doesn$'t, Alm, Sts_Disabled, Sts_Inhibited and Sts_Suppressed are cleared$Nand Ack is set to keep HMI happy for the alarm and the $QI$Q icon on the graphic symbol.$N","OTE(Ack_FailToStop)","73"
RCOMMENT,"P_VSD:AOI","Logic","Status bits are a copy of the internal Alarm AOI bits when the alarm exists.$NIf it doesn$'t, Alm, Sts_Disabled, Sts_Inhibited and Sts_Suppressed are cleared$Nand Ack is set to keep HMI happy for the alarm and the $QI$Q icon on the graphic symbol.$N","OTE(Ack_IntlkTrip)","74"
RCOMMENT,"P_VSD:AOI","Logic","Status bits are a copy of the internal Alarm AOI bits when the alarm exists.$NIf it doesn$'t, Alm, Sts_Disabled, Sts_Inhibited and Sts_Suppressed are cleared$Nand Ack is set to keep HMI happy for the alarm and the $QI$Q icon on the graphic symbol.$N","OTE(Ack_DriveFault)","75"
RCOMMENT,"P_VSD:AOI","Logic","Status bits are a copy of the internal Alarm AOI bits when the alarm exists.$NIf it doesn$'t, Alm, Sts_Disabled, Sts_Inhibited and Sts_Suppressed are cleared$Nand Ack is set to keep HMI happy for the alarm and the $QI$Q icon on the graphic symbol.$N","OTE(Ack_IOFault)","76"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NVALUES PROCESSING$N============================================================$NThis rung outputs instruction Values:$N$NVal_SpeedFdbk (actual running speed), if not in simulation,$Nfrom Input.  If in simulation, simulate accel/decel.","CLR(Val_SpeedFdbk)","77"
RCOMMENT,"P_VSD:AOI","Logic","This rung publishes the Values for the scaled speed feedback range.$NIf this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$Nthe values are swapped so the EUMax Value is always greater than the EUMin Value.$NThis makes the HMI bargraph and trend coding easier, and provides values$Nthat can be pinned to the configuration of a PID, so the VSD and PID ranges are in lockstep.$N","MOV(Cfg_SpeedFdbkEUMax,Val_SpeedFdbkEUMin)","78"
RCOMMENT,"P_VSD:AOI","Logic","Val_SpeedRef (commanded speed)$N$NBased on Mode and Tracking settings, copy the Speed$NReference Value back into the Operator and Program Settings.","MOV(Val_SpeedRef,OSet_SpeedRef)","81"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NNOTIFICATION VALUE$N============================================================$NIndicate the current alarm notification level as the max of any of the alarms:$N0 = none$N2 = info or prompt only$N4 = warning$N6 = exception (equipment impact)$N8 = fault (equipment failure)$NAdd one for any unsuppressed alarm that is not acknowledged (for blink).","MOV(Wrk_Notify,Val_Notify)","82"
RCOMMENT,"P_VSD:AOI","Logic","These rungs generate the Starting, Running, Stopping and Stopped Status bits.$N$NIf the Drive is in HAND and HAS NO RUN FEEDBACK, its state is meaningless;$Nturn off ALL the Sts_xxx states!!!!!$N$NIf the Drive is commanded to run (Output on) and the feedback doesn$'t yet show it running,$Nthe Drive is STARTING.$N$NIf the Drive is commanded to run (Output on) and the feedback shows it running,$Nthe Drive is RUNNING.$N$NIf the Drive is commanded to stoop (Output off) and the feedback still shows it running,$Nthe Drive is STOPPING.$N$NIf the Drive is commanded to stop (Output off) and the feedback shows it has stopped,$Nthe Drive is STOPPED.","OTE(Sts_Jogging)","83"
RCOMMENT,"P_VSD:AOI","Logic","The Drive is AVAILABLE to be run by automation (either in Automatic or in $NProgram Manual) if interlocks are OK, and if stopped, permissive are also OK.$N","OTE(Sts_Available)","85"
RCOMMENT,"P_VSD:AOI","Logic","If the internal Bypass flag is set, Bypassable Permissives and Interlocks ARE BYPASSED.","OTE(Sts_Bypass)","86"
RCOMMENT,"P_VSD:AOI","Logic","If the internal Disabled flag is set, the Drive is DISABLED.","OTE(Sts_Disabled)","87"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NOPERATOR COMMAND READIES$N============================================================$N$NReady to Start if in Operator Manual, Stopped, and Permissives and Interlocks are OK.$N$NReady to Stop if in Operator Manual and (Running or Starting).","OTE(Rdy_Stop)","88"
RCOMMENT,"P_VSD:AOI","Logic","Ready to Bypass all Bypassable Permissives and Interlocks if not bypassed.","OTE(Rdy_Bypass)","89"
RCOMMENT,"P_VSD:AOI","Logic","Ready to Check Bypassable Permissives and Interlocks if bypassed.","OTE(Rdy_Check)","90"
RCOMMENT,"P_VSD:AOI","Logic","Ready to Disable Drive if not Disabled","OTE(Rdy_Disable)","91"
RCOMMENT,"P_VSD:AOI","Logic","Ready to Enable Drive if Disabled.","OTE(Rdy_Enable)","92"
RCOMMENT,"P_VSD:AOI","Logic","Forward / Reverse direction can be toggled if the drive is in Operator or Maintenance$Nand is not Disabled, and if configured to allow reversing.","OTE(Rdy_Fwd)","93"
RCOMMENT,"P_VSD:AOI","Logic","This object requires a Reset if the drive is Faulted$Nor if any of its Alarms requires a Reset.","OTE(Rdy_Reset)","94"
RCOMMENT,"P_VSD:AOI","Prescan","============================================================$NPRESCAN (POWER UP) HANDLING$N============================================================$NOn Prescan, set the Ownership to NO OWNER (0).$N","CLR(Val_Owner)","0"
RCOMMENT,"P_VSD:AOI","Prescan","On power up (prescan), set drive to stop.","OTU(Wrk_Jog)","1"
RCOMMENT,"P_VSD:AOI","Prescan","$QLurking$Q Operator Commands are cleared, as well as Program Reset.","OTU(PCmd_Reset)","2"
RCOMMENT,"P_VSD:AOI","Prescan","$QLurking$Q Program Commands are cleared if they are set as $QEdge$Q triggered$N(cleared by this object as received).$N(Lurking Acknowledge Commands are left to perform their action.)","OTU(PCmd_IOFaultUninhibit)","3"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"U_CommFail:AOI","Logic","Timer Map","MUL(CFG_DelayTimerSec,1000,HeartBeatDelayTimerOff.PRE)","0"
RCOMMENT,"U_CommFail:AOI","Logic","Heartbeat","TON(HeartBeatDelayTimerOff,?,?)","1"
RCOMMENT,"U_CommFail:AOI","Logic","Alarm","OTE(Sts_CommFail)","2"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","===============================================================$NRepeat Cycle Timer$N===============================================================$NA Repeat Cycle Timer (RPC) runs equipment with an On time preset and Off time preset that repeats.   Timer presets have low & high limits.  Preset Units are selectable by the operator.  The cycle can be manually reset by an operator push button.   ","NOP()","0"
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","Configure timer limits","CPT(TimerHighLimitSec,2147483647 / 1000)","1"
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","On Time Low Limit Check","MOV(Val_OnTimeLoLimit,Oset_OnTimePreset)","2"
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","On time Hi Limit check","MOV(Val_OnTimeHiLimit,Oset_OnTimePreset)","3"
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","On Time HMI Preset Setpoint and Elapsed Indication","DIV(ONTimer.ACC,60000,Val_OnTimeElapsed)","4"
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","Off Time Low Limit Check","MOV(Val_OffTimeLoLimit,Oset_OffTimePreset)","5"
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","Off time Hi Limit check","MOV(Val_OffTimeHiLimit,Oset_OffTimePreset)","6"
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","Off Time  for the HMI Preset Setpoint and Elapsed Indication","DIV(OFFTimer.ACC,60000,Val_OffTimeElapsed)","7"
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","Normal Start Cycle","TON(ONTimer,?,?)","8"
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","Normal End Cycle","TON(OFFTimer,?,?)","10"
RCOMMENT,"U_RepeatCycTmr:AOI","Logic","Reset both timers from OIC and intiate an ON Cycle","RES(OFFTimer)","11"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"U_WallClock:AOI","Logic","============================================================$NU_WallClock:  CONTROLLER CLOCK HANDLER$N============================================================$NModified 2009-03-24, DER$NSimplified Day of Week calculation, removed unused parameters$N============================================================$NThis object manages the controller $QWall Clock$Q, providing date and time services$Nincluding:$N* Accepts downloaded date and time and $QSet$Q command from HMI or other sync source and sets the clock$N* Reads the clock and provides the local date and time to other logic$N* Calculates and provides the day of the week for the current date$N* Sets a flag every Hour, Day, Month and Year for resets / data collectors$N$NThe time is provided as separate Values:$NVal_CurrentYear : DINT, $NVal_CurrentMonth : DINT,$NVal_CurrentDay : DINT,$NVal_CurrentHour : DINT,$NVal_CurrentMinute : DINT,$NVal_CurrentSecond : DINT,$NVal_DayOfWeek : DINT)$N============================================================$NHANDLE RECEIVED DATE/TIME SYNC, SET CLOCK$N============================================================$NIf a date and time have been received with a $QSet$Q command,$Nstore the date/time to the controller clock.$N","MOV(0,Wrk_SetDateTime[6])","0"
RCOMMENT,"U_WallClock:AOI","Logic","**TetraTech**$Nuse local since date time already has time zone info","SSV(WALLCLOCKTIME,,LocalDateTime,Wrk_SetDateTime[0])","1"
RCOMMENT,"U_WallClock:AOI","Logic","============================================================$NGET CURRENT DATE / TIME$N============================================================$N$NGet the Controller$'s real time clock broken down by Year, month, day...seconds$Nand store in a tag so that the values can be used.$N$N**TetraTech**$Nuse local since date time already has time zone info","MOV(Wrk_GetDateTime[5],Val_CurrentSecond)","2"
RCOMMENT,"U_WallClock:AOI","Logic","============================================================$NCALCULATE THE DAY OF THE WEEK$N============================================================$NThis version of the day of the week is based on:$N$Nhttp://alcor.concordia.ca/~gpkatch/gdate-algorithm.html$N$N(NOTE:  ALL divisions are INTEGER -- truncated -- divisions!)$NF = ( month + 9 ) MOD 12$NG = year - ( F / 10 )$NGregorian DayNumber [ D ] = ( 365 * G ) + ( G / 4 ) - ( G / 100 ) + ( G / 400 ) + ( ( ( F * 306 ) + 5 ) / 10 ) + day - 1$NDayOfWeek = ( DayNumber + 3 ) MOD 7$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NThis rung calculates the $QG$Q and $QF$Q functions shown in the algorithm above.$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","CPT(Wrk_G,Wrk_GetDateTime[0]-(Wrk_F/10))","3"
RCOMMENT,"U_WallClock:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NThis rung calculates the remainder of the algorithm.$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NThe $QDay Number$Q is calculated, and the MOD 7$N(remainder after division by 7) is stored as the Day of the Week.$N$NNOTE:  The $Q+2$Q offset aligns Val_DayOfWeek as:$N0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat","CPT(Val_DayOfWeek,(365*Wrk_G+(Wrk_G/4)-(Wrk_G/100)+(Wrk_G/400)+((Wrk_F*306+5)/10)+Wrk_GetDateTime[2]+2)MOD 7)","4"
RCOMMENT,"U_WallClock:AOI","Logic","============================================================$NRESET PULSE OUTPUTS$N============================================================$N$NThese rungs generate one-shot outputs once hourly, daily, monthly and yearly.","OTE(Sts_HourlyReset)","5"
