remark,"CSV-Import-Export"
remark,"Date = Tue Mar 10 16:23:53 2009"
remark,"Version = RSLogix 5000 v17.00"
remark,"Owner = user"
remark,"Company = tetratech"
0.3
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,,WWTP_CLX_Rack01_Slot00_CNB:1:C,"","AB:1756_DI:C:0","",""
ALIAS,,WWTP_CLX_Rack01_Slot00_CNB:1:I,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1]",""
TAG,,WWTP_CLX_Rack01_Slot00_CNB:2:C,"","AB:1756_DO:C:0","",""
ALIAS,,WWTP_CLX_Rack01_Slot00_CNB:2:I,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[2]",""
ALIAS,,WWTP_CLX_Rack01_Slot00_CNB:2:O,"","","WWTP_CLX_Rack01_Slot00_CNB:O.Slot[2]",""
TAG,,WWTP_CLX_Rack01_Slot00_CNB:4:C,"","AB:1756_IF4_Float:C:0","",""
TAG,,WWTP_CLX_Rack01_Slot00_CNB:4:I,"","AB:1756_IF4_Float:I:0","",""
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:4:I,"Alum Tank #1$N Level Ind",,"WWTP_CLX_Rack01_Slot00_CNB:4:I.CH0DATA"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:4:I,"Feed Pump #1 Speed Ind",,"WWTP_CLX_Rack01_Slot00_CNB:4:I.CH2DATA"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:4:I,"Feed  Pump #2 Speed Ind",,"WWTP_CLX_Rack01_Slot00_CNB:4:I.CH3DATA"
TAG,,WWTP_CLX_Rack01_Slot00_CNB:6:C,"","AB:1756_OF8_Float:C:0","",""
TAG,,WWTP_CLX_Rack01_Slot00_CNB:6:I,"","AB:1756_OF8_Float:I:0","",""
TAG,,WWTP_CLX_Rack01_Slot00_CNB:6:O,"","AB:1756_OF8_Float:O:0","",""
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:6:O,"Feed  Pump #1$NSpeed Cmd",,"WWTP_CLX_Rack01_Slot00_CNB:6:O.CH0DATA"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:6:O,"Feed  Pump #2$NSpeed Cmd",,"WWTP_CLX_Rack01_Slot00_CNB:6:O.CH1DATA"
TAG,,WWTP_CLX_Rack01_Slot00_CNB:I,"","AB:1756_CNB_7SLOT:I:0","",""
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:I,"Feed  Pump No.1 In Auto",,"WWTP_CLX_Rack01_Slot00_CNB:I.SLOT[1].DATA.0"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:I,"Feed Pump No.1 Running",,"WWTP_CLX_Rack01_Slot00_CNB:I.SLOT[1].DATA.1"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:I,"Feed  Pump No.1  Fault",,"WWTP_CLX_Rack01_Slot00_CNB:I.SLOT[1].DATA.2"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:I,"Feed  Pump No.1  OverLoad",,"WWTP_CLX_Rack01_Slot00_CNB:I.SLOT[1].DATA.3"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:I,"Feed  Pump No.2 In Auto",,"WWTP_CLX_Rack01_Slot00_CNB:I.SLOT[1].DATA.4"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:I,"Feed Pump No.2 Running",,"WWTP_CLX_Rack01_Slot00_CNB:I.SLOT[1].DATA.5"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:I,"Feed  Pump No.2  Fault",,"WWTP_CLX_Rack01_Slot00_CNB:I.SLOT[1].DATA.6"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:I,"Feed  Pump No.2  OverLoad",,"WWTP_CLX_Rack01_Slot00_CNB:I.SLOT[1].DATA.7"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:I,"Feed  Pump No.2 In Auto",,"WWTP_CLX_Rack01_Slot00_CNB:I.SLOT[1].DATA.8"
TAG,,WWTP_CLX_Rack01_Slot00_CNB:O,"","AB:1756_CNB_7SLOT:O:0","",""
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:O,"Feed Pump #1 Start/Stop",,"WWTP_CLX_Rack01_Slot00_CNB:O.SLOT[2].DATA.0"
COMMENT,,WWTP_CLX_Rack01_Slot00_CNB:O,"Feed Pump #2 Start/Stop",,"WWTP_CLX_Rack01_Slot00_CNB:O.SLOT[2].DATA.1"
TAG,,I_AerTk_InflFlow,"","REAL","","(RADIX := Float)"
TAG,,I_AerTk_InflFlow_IOFault,"","BOOL","","(RADIX := Decimal)"
ALIAS,,I_AlumTk1Lv,"","","WWTP_CLX_Rack01_Slot00_CNB:4:I.Ch0Data","(RADIX := Float)"
ALIAS,,I_AlumTk1Lv_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:4:I.Ch0Fault","(RADIX := Decimal)"
ALIAS,,I_FeedP1_Fault,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Data.2","(RADIX := Decimal)"
ALIAS,,I_FeedP1_Fault_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Fault.2","(RADIX := Decimal)"
ALIAS,,I_FeedP1_InAuto,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Data.0","(RADIX := Decimal)"
ALIAS,,I_FeedP1_InAuto_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Fault.0","(RADIX := Decimal)"
ALIAS,,I_FeedP1_OverLoad,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Data.3","(RADIX := Decimal)"
ALIAS,,I_FeedP1_OverLoad_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Fault.3","(RADIX := Decimal)"
ALIAS,,I_FeedP1_RunFdbk,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Data.1","(RADIX := Decimal)"
ALIAS,,I_FeedP1_RunFdbk_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Fault.1","(RADIX := Decimal)"
ALIAS,,I_FeedP1_SpeedFdbk,"","","WWTP_CLX_Rack01_Slot00_CNB:4:I.Ch2Data","(RADIX := Float)"
ALIAS,,I_FeedP1_SpeedFdbk_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:4:I.Ch2Fault","(RADIX := Decimal)"
ALIAS,,I_FeedP2_Fault,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Data.6","(RADIX := Decimal)"
ALIAS,,I_FeedP2_Fault_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Fault.6","(RADIX := Decimal)"
ALIAS,,I_FeedP2_InAuto,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Data.4","(RADIX := Decimal)"
ALIAS,,I_FeedP2_InAuto_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Fault.4","(RADIX := Decimal)"
ALIAS,,I_FeedP2_OverLoad,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Data.7","(RADIX := Decimal)"
ALIAS,,I_FeedP2_OverLoad_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Fault.7","(RADIX := Decimal)"
ALIAS,,I_FeedP2_RunFdbk,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Data.5","(RADIX := Decimal)"
ALIAS,,I_FeedP2_RunFdbk_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:I.Slot[1].Fault.5","(RADIX := Decimal)"
ALIAS,,I_FeedP2_SpeedFdbk,"","","WWTP_CLX_Rack01_Slot00_CNB:4:I.Ch3Data","(RADIX := Float)"
ALIAS,,I_FeedP2_SpeedFdbk_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:4:I.Ch3Fault","(RADIX := Decimal)"
ALIAS,,O_FeedP1_Out_Run,"","","WWTP_CLX_Rack01_Slot00_CNB:2:O.Data.0","(RADIX := Decimal)"
ALIAS,,O_FeedP1_SpeedRef,"","","WWTP_CLX_Rack01_Slot00_CNB:6:O.Ch0Data","(RADIX := Float)"
ALIAS,,O_FeedP1_SpeedRef_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:6:I.Ch0Fault","(RADIX := Decimal)"
ALIAS,,O_FeedP2_Out_Run,"","","WWTP_CLX_Rack01_Slot00_CNB:2:O.Data.1","(RADIX := Decimal)"
ALIAS,,O_FeedP2_SpeedRef,"","","WWTP_CLX_Rack01_Slot00_CNB:6:O.Ch1Data","(RADIX := Float)"
ALIAS,,O_FeedP2_SpeedRef_IOFault,"","","WWTP_CLX_Rack01_Slot00_CNB:6:I.Ch1Fault","(RADIX := Decimal)"
TAG,,PLC_Device_ResetPB,"Site Wide Device Reset Push Button","BOOL","","(RADIX := Decimal)"
TAG,,PLC_Simulation,"Application running IN SIMULATION","BOOL","","(RADIX := Decimal)"
TAG,,PLC_WallClock,"Wall Clock","U_WallClock","",""
TAG,,WWTP_AerTk_InflFlow,"Aeration Tank Influent Flow","U_Flow","",""
TAG,,WWTP_Alum,"Alum Chemical","U_Chemical","",""
TAG,,WWTP_AlumTk1Lv,"Alum Tank #1 Level","P_AIn","",""
TAG,,WWTP_FeedP1,"Feed Pump #1","U_MotorVSD","",""
TAG,,WWTP_FeedP1_FlowPacing,"Feed Pump #1 $NFlow Pacing","U_FlowPacing","",""
TAG,,WWTP_FeedP1_OverLoad,"Feed Pump #1$NOverload","P_DIn","",""
TAG,,WWTP_FeedP2,"Feed Pump #2","U_MotorVSD","",""
TAG,,WWTP_FeedP2_FlowPacing,"Feed Pump #2$NFlow Pacing","U_FlowPacing","",""
TAG,,WWTP_FeedP2_OverLoad,"Feed Pump #2$NOverload","P_DIn","",""
TAG,,WWTP_FeedSys_OSet_PumpSelect,"Feed Pump System$NPump Select","BOOL","","(RADIX := Decimal)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
ALIAS,FeedP1,Device,"","","WWTP_FeedP1",""
ALIAS,FeedP1,Device_Alm0,"","","WWTP_FeedP1_OverLoad",""
ALIAS,FeedP1,Device_Alm0_Input,"","","I_FeedP1_OverLoad","(RADIX := Decimal)"
ALIAS,FeedP1,Device_Alm0_Input_IOFault,"","","I_FeedP1_OverLoad_IOFault","(RADIX := Decimal)"
TAG,FeedP1,Device_Alm1,"","P_DIn","",""
TAG,FeedP1,Device_Alm1_Input,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP1,Device_Alm1_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP1,Device_Alm2,"","P_DIn","",""
TAG,FeedP1,Device_Alm2_Input,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP1,Device_Alm2_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP1,Device_Alm3,"","P_DIn","",""
TAG,FeedP1,Device_Alm3_Input,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP1,Device_Alm3_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP1,Device_Alm4,"","P_DIn","",""
TAG,FeedP1,Device_Alm4_Input,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP1,Device_Alm4_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
ALIAS,FeedP1,Device_Faulted,"","","I_FeedP1_Fault","(RADIX := Decimal)"
ALIAS,FeedP1,Device_Faulted_IOFault,"","","I_FeedP1_Fault_IOFault","(RADIX := Decimal)"
ALIAS,FeedP1,Device_GroupReset,"","","PLC_Device_ResetPB","(RADIX := Decimal)"
ALIAS,FeedP1,Device_InAuto,"","","I_FeedP1_InAuto","(RADIX := Decimal)"
ALIAS,FeedP1,Device_InAuto_IOFault,"","","I_FeedP1_InAuto_IOFault","(RADIX := Decimal)"
ALIAS,FeedP1,Device_Out_Run,"","","O_FeedP1_Out_Run","(RADIX := Decimal)"
ALIAS,FeedP1,Device_RunFdbk,"","","I_FeedP1_RunFdbk","(RADIX := Decimal)"
ALIAS,FeedP1,Device_RunFdbk_IOFault,"","","I_FeedP1_RunFdbk_IOFault","(RADIX := Decimal)"
ALIAS,FeedP1,Device_SpeedFdbk,"","","I_FeedP1_SpeedFdbk","(RADIX := Float)"
ALIAS,FeedP1,Device_SpeedFdbk_IOFault,"","","I_FeedP1_SpeedFdbk_IOFault","(RADIX := Decimal)"
ALIAS,FeedP1,Device_SpeedRef,"","","O_FeedP1_SpeedRef","(RADIX := Float)"
ALIAS,FeedP1,Device_SpeedRef_IOFault,"","","O_FeedP1_SpeedRef_IOFault","(RADIX := Decimal)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
ALIAS,FeedP2,Device,"","","WWTP_FeedP2",""
ALIAS,FeedP2,Device_Alm0,"","","WWTP_FeedP2_OverLoad",""
ALIAS,FeedP2,Device_Alm0_Input,"","","I_FeedP2_OverLoad","(RADIX := Decimal)"
ALIAS,FeedP2,Device_Alm0_Input_IOFault,"","","I_FeedP2_OverLoad_IOFault","(RADIX := Decimal)"
TAG,FeedP2,Device_Alm1,"","P_DIn","",""
TAG,FeedP2,Device_Alm1_Input,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP2,Device_Alm1_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP2,Device_Alm2,"","P_DIn","",""
TAG,FeedP2,Device_Alm2_Input,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP2,Device_Alm2_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP2,Device_Alm3,"","P_DIn","",""
TAG,FeedP2,Device_Alm3_Input,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP2,Device_Alm3_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP2,Device_Alm4,"","P_DIn","",""
TAG,FeedP2,Device_Alm4_Input,"","BOOL","","(RADIX := Decimal)"
TAG,FeedP2,Device_Alm4_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
ALIAS,FeedP2,Device_Faulted,"","","I_FeedP2_Fault","(RADIX := Decimal)"
ALIAS,FeedP2,Device_Faulted_IOFault,"","","I_FeedP2_Fault_IOFault","(RADIX := Decimal)"
ALIAS,FeedP2,Device_GroupReset,"","","PLC_Device_ResetPB","(RADIX := Decimal)"
ALIAS,FeedP2,Device_InAuto,"","","I_FeedP2_InAuto","(RADIX := Decimal)"
ALIAS,FeedP2,Device_InAuto_IOFault,"","","I_FeedP2_InAuto_IOFault","(RADIX := Decimal)"
ALIAS,FeedP2,Device_Out_Run,"","","O_FeedP2_Out_Run","(RADIX := Decimal)"
ALIAS,FeedP2,Device_RunFdbk,"","","I_FeedP2_RunFdbk","(RADIX := Decimal)"
ALIAS,FeedP2,Device_RunFdbk_IOFault,"","","I_FeedP2_RunFdbk_IOFault","(RADIX := Decimal)"
ALIAS,FeedP2,Device_SpeedFdbk,"","","I_FeedP2_SpeedFdbk","(RADIX := Float)"
ALIAS,FeedP2,Device_SpeedFdbk_IOFault,"","","I_FeedP2_SpeedFdbk_IOFault","(RADIX := Decimal)"
ALIAS,FeedP2,Device_SpeedRef,"","","O_FeedP2_SpeedRef","(RADIX := Float)"
ALIAS,FeedP2,Device_SpeedRef_IOFault,"","","O_FeedP2_SpeedRef_IOFault","(RADIX := Decimal)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
ALIAS,FeedPSys,Chemical,"","","WWTP_Alum",""
ALIAS,FeedPSys,P1_FlowPacing,"","","WWTP_FeedP1_FlowPacing",""
ALIAS,FeedPSys,P1_Motor,"","","WWTP_FeedP1.Motor",""
ALIAS,FeedPSys,P2_FlowPacing,"","","WWTP_FeedP2_FlowPacing",""
ALIAS,FeedPSys,P2_Motor,"","","WWTP_FeedP2.Motor",""
ALIAS,FeedPSys,PacedFlow,"","","WWTP_AerTk_InflFlow",""
ALIAS,FeedPSys,PumpSelect,"","","WWTP_FeedSys_OSet_PumpSelect","(RADIX := Decimal)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,MainProgram,Alm00,"","P_DIn","",""
TAG,MainProgram,Alm00_Input,"","BOOL","","(RADIX := Decimal)"
TAG,MainProgram,Alm00_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,MainProgram,Alm01,"","P_DIn","",""
TAG,MainProgram,Alm01_Input,"","BOOL","","(RADIX := Decimal)"
TAG,MainProgram,Alm01_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,MainProgram,Alm02,"","P_DIn","",""
TAG,MainProgram,Alm02_Input,"","BOOL","","(RADIX := Decimal)"
TAG,MainProgram,Alm02_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,MainProgram,Alm03,"","P_DIn","",""
TAG,MainProgram,Alm03_Input,"","BOOL","","(RADIX := Decimal)"
TAG,MainProgram,Alm03_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,MainProgram,Alm04,"","P_DIn","",""
TAG,MainProgram,Alm04_Input,"","BOOL","","(RADIX := Decimal)"
TAG,MainProgram,Alm04_Input_IOFault,"","BOOL","","(RADIX := Decimal)"
TAG,MainProgram,BNOT_01,"","FBD_BOOLEAN_NOT","",""
TAG,MainProgram,DailyTotalizer,"","TOTALIZER","",""
TAG,MainProgram,FlowRateLowLimitSelect,"","SELECTED_SUMMER","",""
TAG,MainProgram,YearlyTotalizer,"","TOTALIZER","",""
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_AIn:AOI,Inp_PV,"Input Signal (process variable) from Sensor","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,P_AIn:AOI,Inp_PVBad,"1=PV or I/O Comms Status Bad, 0=OK","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_AIn:AOI,Inp_PVUncertain,"1=PV Value Not Reliable, 0=OK","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_AIn:AOI,Inp_Sim,"1=Use simulated PV (Set_SimPV); 0=Use Input (Inp_PV)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Inp_Reset,"1=Reset all Alarms requiring reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_AIn:AOI,Cfg_NoSubstPV,"1=Disallow selection of Substitute PV","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_SetTrack,"1=PSets track OSets in Oper, OSets track PSets in Prog, 0=no tracking","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiHiResetReqd,"1=Reset required to clear High-High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiResetReqd,"1=Reset required to clear High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoResetReqd,"1=Reset required to clear Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoLoResetReqd,"1=Reset required to clear Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailResetReqd,"1=Reset required to clear Analog InputFailure Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiHiAckReqd,"1=Acknowledge required for High-High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiAckReqd,"1=Acknowledge required for High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoAckReqd,"1=Acknlowledge required for Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoLoAckReqd,"1=Acknowledge required for Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailAckReqd,"1=Acknowledge required for Analog Input Failure Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiHiSeverity,"High-High Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiSeverity,"High Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoSeverity,"Low Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoLoSeverity,"Low-Low Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailSeverity,"Failure Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_InpRawMin,"Input (unscaled) Minimum for Scaling","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_InpRawMax,"Input (unscaled) Maximum for Scaling","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_PVEUMin,"PV (Output) Minimum for Scaling to EU","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_PVEUMax,"PV (Output) Maximum for Scaling to EU","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FiltTC,"PV Filter Time Constant (sec),$N0.0 = unfiltered","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiHiDB,"High-High Alarm Deadband (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiHiMinDuration,"Minimum time above High-High Limit to raise Alarm (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiDB,"High Alarm Deadband (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_HiMinDuration,"Minimum time above High Limit to raise Alarm (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoDB,"Low Alarm Deadband (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoMinDuration,"Minimum time below Low Limit to raise Alarm (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoLoDB,"Low-Low Alarm Deadband (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_LoLoMinDuration,"Minimum time below Low-Low Limit to raise Alarm (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailHiLim,"Out-of-Range (fail) High Limit (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailLoLim,"Out-of-Range (fail) Low Limit (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailDB,"Out-of-Range (fail) High/Low Deadband (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Cfg_FailMinDuration,"Minimum time Bad or Out of Range to raise Fail Alarm (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PSet_Owner,"Program Owner Request ID (non-zero) or Release (zero)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PSet_HiHiLim,"Program-Entered High-High Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PSet_HiLim,"Program-Entered High Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PSet_LoLim,"Program-Entered Low Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PSet_LoLoLim,"Program-Entered Low-Low Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,MSet_SubstPV,"Maintenance-Entered Substitute PV (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,OSet_HiHiLim,"Operator-Entered High-High Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,OSet_HiLim,"Operator-Entered High Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,OSet_LoLim,"Operator-Entered Low Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,OSet_LoLoLim,"Operator-Entered Low-Low Alarm Threshold (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Set_SimPV,"PV used in Simulation (Inp_Sim=1) (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_Acq,"Program Command to Acquire ownership (Oper to Prog)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_Rel,"Program Command to Release ownership (Prog to Oper)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_Lock,"Program Command to Lock Mode in Prog","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_Unlock,"Program Command to Unlock Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_Reset,"Program Command to Reset all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiHiAck,"Program Command to Acknowledge High-High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiHiInhibit,"Program Command to Inhibit High-High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiHiUninhibit,"Program Command to UninhibitHigh-High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiAck,"Program Command to Acknowledge High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiInhibit,"Program Command to Inhibit High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_HiUninhibit,"Program Command to Uninhibit High Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoAck,"Program Command to Acknowledge Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoInhibit,"Program Command to Inhibit Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoUninhibit,"Program Command to Uninhibit Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoLoAck,"Program Command to Acknowledge Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoLoInhibit,"Program Command to Inhibit Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_LoLoUninhibit,"Program Command to Uninhibit Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_FailAck,"Program Command to Acknowldege Analog Input Failure Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_FailInhibit,"Program Command to Inhibit Analog Input Failure Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,PCmd_FailUninhibit,"Program Command to Uninhibit Analog Input Failure Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,MCmd_SubstPV,"Maintenance Command to use Substitute PV (override input)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,MCmd_InpPV,"Maintenance Command to use Input PV (normal)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,OCmd_Reset,"Operator Command to Reset all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_AIn:AOI,Val,"Analog Value (after Substitute PV, if used)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Val_InpPV,"Analog Input Value (actual, before Substitute PV selection)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Val_PVEUMin,"Minimum of scaled range = MIN (Cfg_PVEUMin, Cfg_PVEUMax)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Val_PVEUMax,"Maximum of scaled rante = MAX (Cfg_PVEUMin, Cfg_PVEUMax)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Val_Owner,"Current Object Owner ID (0=not owned)","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Val_Notify,"Current Alarm Level and Acknowledgement (enumeration)","SINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Val_HiHiLim,"Current High-High Alarm Threshold","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Val_HiLim,"Current High Alarm Threshold","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Val_LoLim,"Current Low Alarm Threshold","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Val_LoLoLim,"Current Low-Low Alarm Threshold","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Sts_SubstPV,"1=Using Substitute PV (Input being overridden)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_InpPV,"1=Using Input PV (normal)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_PVBad,"1=PV Bad quality or Out of Range","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Sts_PVUncertain,"1=PV Value is Uncertain (quality)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Sts_Err,"1=Error in Config, see detail Err_ bits for reason","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Err_Raw,"1=Error in Config: Raw Input Scaling Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Err_EU,"1=Error in Config: Scaled EU Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Err_Filt,"1=Error in Config: PV filter params (RateTime, TC)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Err_DB,"1=Error in Config: an Alarm Deadband is < 0.0","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Err_Alarm,"1=Error in Config: Invalid Alarm Min Duration or Severity","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Maint,"1=Mode is Maintenance (supersedes Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Prog,"1=Mode is Program","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Oper,"1=Mode is Operator","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_ProgOperLock,"1=Program or Operator has requested Mode Lock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiHi,"1=Analog Input is above High-High limit","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Alm_HiHi,"1=Analog Input is in High-High Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Ack_HiHi,"1=High-High Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Sts_HiHiDisabled,"1=High-High Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiHiInhibited,"1=High-High Alarm is Inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiHiSuppressed,"1=High-High Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Hi,"1=Analog Input is above High limit","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Alm_Hi,"1=Analog Input is in High Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Ack_Hi,"1=High Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Sts_HiDisabled,"1=High Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiInhibited,"1=High Alarm is Inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_HiSuppressed,"1=High Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Lo,"1=Analog Input is below Low limit","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Alm_Lo,"1=Analog Input is in Low Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Ack_Lo,"1=Low Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Sts_LoDisabled,"1=Low Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoInhibited,"1=Low Alarm is Inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoSuppressed,"1=Low Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoLo,"1=Analog Input is below Low-Low limit","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Alm_LoLo,"1=Analog Input is in Low-Low Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Ack_LoLo,"1=Low-Low Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Sts_LoLoDisabled,"1=Low-Low Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoLoInhibited,"1=Low-Low Alarm is Inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_LoLoSuppressed,"1=Low-Low Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_Fail,"1=Analog Input is Out of Range or PV Bad","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Alm_Fail,"1=Analog Input Failure Alarm (Bad or Out of Range)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Ack_Fail,"1=Analog Input Failure Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_AIn:AOI,Sts_FailDisabled,"1=Analog input Failure Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_FailInhibited,"1=Analog Input Failure Alarm is inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Sts_FailSuppressed,"1=Analog Input Failure Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Rdy_SubstPV,"1=Ready for MCmd_SubstPV","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Rdy_InpPV,"1=Ready for MCmd_InpPV","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,Rdy_Reset,"1=At least one Alarm requires Reset","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_AIn:AOI,LoLo,"Low-Low Alarm","P_Alarm","","(Usage := Local)"
TAG,P_AIn:AOI,Lo,"Low Alarm","P_Alarm","","(Usage := Local)"
TAG,P_AIn:AOI,Hi,"High Alarm","P_Alarm","","(Usage := Local)"
TAG,P_AIn:AOI,HiHi,"High-High Alarm","P_Alarm","","(Usage := Local)"
TAG,P_AIn:AOI,Mode,"Analog Input Mode Selection","P_Mode","","(Usage := Local)"
TAG,P_AIn:AOI,Cfg_EU,"Engineering Units for display on HMI","STRING_8","","(Usage := Local)"
TAG,P_AIn:AOI,Cfg_Tag,"Tagname for display on HMI","STRING_20","","(Usage := Local)"
TAG,P_AIn:AOI,Cfg_Label,"Label for graphic symbol displayed on HMI","STRING_20","","(Usage := Local)"
TAG,P_AIn:AOI,Cfg_Desc,"Description for display on HMI","STRING_40","","(Usage := Local)"
TAG,P_AIn:AOI,Fail,"Analog Input Failure Alarm (bad quality or out of range)","P_Alarm","","(Usage := Local)"
TAG,P_AIn:AOI,Wrk_Notify,"Buffer for building Val_Notify","SINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_AIn:AOI,Wrk_SubstPV,"Internal flag: Using Substitute PV","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_AIn:AOI,Wrk_UnfiltPV,"Unfiltered PV, input to 1st order filter","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_AIn:AOI,Wrk_Alpha,"Filter multiplier = (1 / (1+TC/dT) )","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_AIn:AOI,Wrk_ScanT,"Scan Timer (milliseconds, always runs)","TIMER","","(Usage := Local)"
TAG,P_AIn:AOI,Wrk_ScanTime,"Time since this instance was last scanned","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_AIn:AOI,Wrk_FiltPV,"Filtered PV","REAL","","(RADIX := Float, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Alarm:AOI,Inp,"Alarm Condition Input 1=Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Inp_Reset,"1=Reset Alarm requiring reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Cfg_ResetReqd,"1=Reset required to clear Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Cfg_AckReqd,"1=Acknowledge required for Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Cfg_Severity,"1=Info Only; 2=Warning; 3=Process Exception; 4=Fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Cfg_MinDuration,"Minimum time (sec) Input must stay on to generate Alarm","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,PCmd_Reset,"Program Command to Reset latched alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,PCmd_Ack,"Program Command to Acknowledge alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,PCmd_Inhibit,"Program Command to Inhibit alarm (force Alm to 0)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,PCmd_Uninhibit,"Program Command to Uninhibit alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,OCmd_Reset,"Operator Command to Reset latched alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,OCmd_Ack,"Operator Command to Acknowledge alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,OCmd_Disable,"Operator Command to Disable alarm (force Alm to 0)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,OCmd_Enable,"Operator Command to Enable alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Val_Notify,"Current Alarm Level and Acknowledgement (enumeration)","SINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Alm,"Alarm output 1=In Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Ack,"Alarm acknowledged status: 1=Ack rcvd","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Disabled,"1=Alarm has been Disabled by Operator (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Inhibited,"1=Alarm has been Inhibited by logic (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Suppressed,"1=Alarm has been suppressed (not visible on HMI)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Alarm:AOI,Sts_Err,"1=Error in Config: see detail Err_ bits for reason","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Err_MinDuration,"1=Error in Config: Invalid Min Duration (use 0.0 to 2147483.647)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Err_Severity,"1=Error in Config: Invalid Severity (use 1 to 4)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Rdy_Reset,"Ready to receive OCmd_Reset (enable button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Rdy_Ack,"Ready to receive OCmd_Ack (enable button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Rdy_Disable,"Ready to receive OCmd_Disable (enable button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Rdy_Enable,"Ready to receive OCmd_Enable (enable button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Alarm:AOI,Wrk_MinDurationT,"Alarm Condition Minimum Duration Timer","TIMER","","(Usage := Local)"
TAG,P_Alarm:AOI,Wrk_Alm,"Internal Alarm Status","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Alarm:AOI,Wrk_Inhibited,"Internal Alarm Inhibit Status","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Alarm:AOI,Wrk_AlmMinOnT,"Alarm output minimum ON time to be seen by alarm server","TIMER","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_DIn:AOI,Inp_PV,"Input Signal (process variable) from Sensor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_DIn:AOI,Inp_Target,"Target State of Input (Alarm if not in Target State)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_DIn:AOI,Inp_Gate,"Gate Condition (=1 to enable Alarm)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_DIn:AOI,Inp_IOFault,"I/O Communication Status 1=Fault, 0=OK","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_DIn:AOI,Inp_Sim,"1=Use simulated PV (Set_SimPV); 0=Use Input (Inp_PV)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Inp_Reset,"1=Reset Alarm requiring reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_DIn:AOI,Cfg_NoSubstPV,"1=Disallow selection of Substitute PV","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_NormTextVis,"1=Display state text in $Qnormal$Q state (= target), 0=hide (some HMI objects)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_AlarmResetReqd,"1=Alarm is latched in, requires Reset Command to clear","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_AlarmAckReqd,"1=Alarm must be acknowledged","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_AlarmSeverity,"Alarm Severity: 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_GateDly,"Time Inp_Gate must be true before Alarm is checked (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_Debounce,"Minimum time Status must maintain state, (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Cfg_AlarmMinDuration,"Minimum time Input must stay in Alarm state to generate an Alarm","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,MSet_SubstPV,"Maintenance-Entered Substitute PV","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Set_SimPV,"PV used in Simulation (Inp_Sim=1)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,PCmd_Reset,"Program Command to Reset all latched Alarms","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,PCmd_AlarmAck,"Program Command to Acknowledge the Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,PCmd_AlarmInhibit,"Program Command to Inhibit Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,PCmd_AlarmUninhibit,"Program Command to Uninhibit the Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,MCmd_SubstPV,"Maintenance Command to use Substitute PV (override input)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,MCmd_InpPV,"Maintenance Command to use Input PV (normal)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,OCmd_Reset,"Operator Command to Reset all latched Alarms","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_DIn:AOI,Val_Notify,"Current Alarm Level and Acknowledgement (enumeration)","SINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts,"Discrete Input Status (incl. Debounce, Manual Override, if used)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_DIn:AOI,Sts_PV,"Discrete Input Status (actual, not subject to Override)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_DIn:AOI,Sts_SubstPV,"1=Using Substitute PV (Input being overridden)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_InpPV,"1=Using Input PV (normal)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_IOFault,"I/O Comm Fault Status (0=OK, 1=Bad)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_Err,"1=Error in Config: see detail bits for reason","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_DIn:AOI,Err_Timer,"1=Error in Config: Invalid Timer Preset (use 0.0 to 2147483.647)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Err_Alarm,"1=Error in Config: Invalid Alarm Min Duration or Severity","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Alm,"1=Discrete Input is in Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_DIn:AOI,Ack,"1=Discrete Input Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_DIn:AOI,Sts_AlarmDisabled,"1=Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_AlarmInhibited,"1=Alarm is Inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Sts_AlarmSuppressed,"1=Alarm is Suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Rdy_SubstPV,"1=Ready for MCmd_SubstPV","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Rdy_InpPV,"1=Ready for MCmd_InpPV","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Rdy_Reset,"1=Ready for Operator Alarm Reset Command","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_DIn:AOI,Wrk_GateDlyT,"Gate Delay timer","TIMER","","(Usage := Local)"
TAG,P_DIn:AOI,Cfg_Tag,"Tagname for display on HMI","STRING_20","","(Usage := Local)"
TAG,P_DIn:AOI,Cfg_Desc,"Description for display on HMI","STRING_40","","(Usage := Local)"
TAG,P_DIn:AOI,Cfg_Label,"Label for graphic symbol displayed on HMI","STRING_20","","(Usage := Local)"
TAG,P_DIn:AOI,Wrk_Sts,"Internal Status (after Manual Override selection)","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_DIn:AOI,Alarm,"Discrete Input Alarm","P_Alarm","","(Usage := Local)"
TAG,P_DIn:AOI,Wrk_FallT,"Timer to ensure Status LOW time on falling edge","TIMER","","(Usage := Local)"
TAG,P_DIn:AOI,Wrk_RiseT,"Timer to ensure Status HIGH time on rising edge","TIMER","","(Usage := Local)"
TAG,P_DIn:AOI,Wrk_SubstPV,"Internal flag: Using Substitute PV","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_DIn:AOI,Cfg_1StText,"Text to display in PV=1 State","STRING_8","","(Usage := Local)"
TAG,P_DIn:AOI,Cfg_0StText,"Text to display in PV=0 State","STRING_8","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Intlk:AOI,Inp_Intlk00,"Interlock Cond. 00 (1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk01,"Interlock Cond. 01$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk02,"Interlock Cond. 02$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk03,"Interlock Cond. 03$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk04,"Interlock Cond. 04$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk05,"Interlock Cond. 05$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk06,"Interlock Cond. 06$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk07,"Interlock Cond. 07$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Inp_Intlk08,"Interlock Cond. 08$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk09,"Interlock Cond. 09$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk10,"Interlock Cond. 10$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk11,"Interlock Cond. 11$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk12,"Interlock Cond. 12$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk13,"Interlock Cond. 13$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk14,"Interlock Cond. 14$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Intlk15,"Interlock Cond. 15$N(1=Stop, 0=OK)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Inp_Reset,"1=Reset Latched Interlocks and First-Out","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Cfg_Latched,"Set bits indicate which conditions are latched (sealed in)","INT","","(RADIX := Binary, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Cfg_Bypassable,"Set bits indicate which conditions can be bypassed","INT","","(RADIX := Binary, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,PCmd_Reset,"Program Command to Reset Latched Interlocks","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,OCmd_Reset,"Operator Command to Reset Latched Interlocks","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Sts_IntlkOK,"Overall Interlock Status (1=OK to run, 0=Stop)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Sts_NBIntlkOK,"Non-Bypassable Interlock Status (1=All NB Interlocks OK to run)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Sts_Intlk,"Individual Interlock Status (1=Stop, 0=OK)","INT","","(RADIX := Binary, Usage := Output, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Sts_FirstOut,"Interlock First Out Status (bit 1 is First Not-OK condition)","INT","","(RADIX := Binary, Usage := Output, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Sts_NBFirstOut,"Non-bypassable Interlock First-Out Status (bit=1 is First NB Not-OK condition)","INT","","(RADIX := Binary, Usage := Output, Required := false, Visible := true)"
TAG,P_Intlk:AOI,Rdy_Reset,"1=Ready to receive OCmd_Reset (reset required)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Intlk:AOI,Cfg_CondTxt,"Short HMI description of Interlock Conditions","STRING_20[16]","","(Usage := Local)"
TAG,P_Intlk:AOI,Wrk_Inp,"Collection copy of Inp_IntlkXXs","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_NB,"Working register for Non-Bypassable Interlock ogic","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_Intlk,"Working register for Interlock logic","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_FirstOut,"Working register for First Out logic","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_Sts,"Working register for generating Interlock status","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_NBFirstOut,"Working register for Non-Bypassable First Out logic","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_PrevSts,"Interlock Status previous scan","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Intlk:AOI,Wrk_PrevNB,"Non-Bypassable Status previous scan","INT","","(RADIX := Binary, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Mode:AOI,Inp_Hand,"1=Select Hand (typ. hardwired)  Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Mode:AOI,Inp_Ovrd,"1=Select Override (typ. Process/Safety Interlock) Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Mode:AOI,Cfg_PCmdClear,"1=Clear Program Command on receipt; 0=Use Level-based (maintained) PCmds","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,Cfg_OvrdOverLock,"1=Override supersedes Prog/Oper Lock, 0=don$'t override Lock","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,PCmd_Acq,"Program Command to Acquire Ownership (Oper to Prog)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,PCmd_Rel,"Program Command to Release Ownership (Prog to Oper)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,PCmd_Lock,"Program Command to Lock Mode in Prog","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,PCmd_Unlock,"Program Command to Unlock Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,MCmd_Acq,"Maintenance Command to Acquire Ownership (Oper/Prog/Ovrd to Maint)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,MCmd_Rel,"Maintenance Command to Release Ownership (Maint to Oper/Prog/Ovrd)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,OCmd_AcqLock,"Operator Command to Acquire and Lock Mode in Oper","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,OCmd_Unlock,"Operator Command to Unlock Operator Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Mode:AOI,Sts_Hand,"1=Mode is Hand (supersedes Maint, Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_Maint,"1=Mode is Maintenance (supersedes Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_Ovrd,"1=Mode is Override (supersedes Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_Prog,"1=Mode is Program","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_Oper,"1=Mode is Operator","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_ProgOperLock,"1=Program or Operator has requested Mode Lock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Mode:AOI,Sts_ProgOperSel,"Prog/Oper selection 1=Program, 0=Operator","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Mode:AOI,Rdy_Acq,"1=Ready for MCmd_Acq","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Mode:AOI,Rdy_Rel,"1=Ready for MCmd_Rel","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Mode:AOI,Rdy_AcqLock,"1=Ready for OCmd_AcqLock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Mode:AOI,Rdy_Unlock,"1=Ready for OCmd_Unlock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Mode:AOI,Wrk_Locked,"1=Program/Operator Mode selection is Locked","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Mode:AOI,Wrk_Prog,"Internal Program (1) / Operator (0) Mode selection","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Mode:AOI,Wrk_Maint,"Internal Maintenance Mode","BOOL","","(RADIX := Decimal, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Motor:AOI,Inp_RunFdbk,"Input Signal: RUN feedback from motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_PermOK,"1=Permissives OK, motor can start","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_NBPermOK,"1=Non-Bypassable Permissives OK, motor can start","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_IntlkOK,"1=Interlocks OK, motor can start/run","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_NBIntlkOK,"1=Non-Bypassable Interlocks OK, motor can start/run","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_IOFault,"Input Communication Status 0=OK, 1=fail","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Inp_Sim,"1=Simulate working motor; 0=Start/Stop/ Monitor actual motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Inp_Hand,"1=Select Hand (hardwired) Control Strategy","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Inp_Ovrd,"1=Select Override control strategy","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Inp_OvrdState,"1=Override to RUN, 0=Override to STOP","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Inp_Reset,"1=Reset all fault conditions and latched Alarms","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Motor:AOI,Cfg_HasRunFdbk,"1=Motor provides a run feedback signal","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_UseRunFdbk,"1=Motor run feedback should be used for failure checking","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasPermObj,"1=Tells HMI a P_Perm is connected to Inp_Perm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasIntlkObj,"1=Tells HMI a P_Intlk is connected to Inp_Intlk","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasResInhObj,"1=Tells HMI a P_ResInh Restart Inhibit is connected","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_HasRunTimeObj,"1=Tells HMI a P_RunTime is connected","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_OvrdPermIntlk,"1=Override ignores Bypassable Perm/ Intlk; 0=always use Perm/Intlk","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStartResetReqd,"1=Reset required to clear Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStopResetReqd,"1=Reset required to clear Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IntlkTripResetReqd,"1=Reset required to clear Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IOFaultResetReqd,"1=Reset required to clear I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStartAckReqd,"1=Acknowledge required for Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStopAckReqd,"1=Acknowledge required for Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IntlkTripAckReqd,"1=Acknowledge required for Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IOFaultAckReqd,"1=Acknowledge required for I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStartSeverity,"Fail To Start Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStopSeverity,"Fail To Stop Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IntlkTripSeverity,"Interlock Trip Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_IOFaultSeverity,"I/O Fault Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_SimFdbkT,"Delay to echo back  of Running/Stopped status when in Simulation (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStartT,"Time after Start to get Run Feedback before Fault (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Cfg_FailToStopT,"Time after Stop to drop Run Feedback before Fault (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PSet_Owner,"Program Owner Request ID (non-zero) or Release (zero)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Start,"Program Command to Start Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Stop,"Program Command to Stop Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Acq,"Program Command to Acquire ownership (Oper/OOS to Prog)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Rel,"Program Command to Release ownership (Prog to OOS)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Lock,"Program Command to Lock Mode in Prog","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Unlock,"Program Command to Unlock Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_Reset,"Program Command to Reset all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStartAck,"Program Command to Acknowledge Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStartInhibit,"Program Command to Inhibit Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStartUninhibit,"Program Command to Uninhibit Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStopAck,"Program Command to Acknowledge Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStopInhibit,"Program Command to Inhibit Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_FailToStopUninhibit,"Program Command to Uninhibit Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IntlkTripAck,"Program Command to Acknowledge Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IntlkTripInhibit,"Program Command to Inhibit Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IntlkTripUninhibit,"Program Command to Uninhibit Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IOFaultAck,"Program Command to Acknowledge I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IOFaultInhibit,"Program Command to Inhibit I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,PCmd_IOFaultUninhibit,"Program Command to Uninhibit I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,OCmd_Start,"Operator Command to Start Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,OCmd_Stop,"Operator Command to Stop Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,OCmd_Bypass,"Operator Command to Bypass all Bypassable Interlocks and Permissives","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,OCmd_Check,"Operator Command to Check (not bypass) all Interlocks and Permissives","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,MCmd_Disable,"Maintenance Command to Disable Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,MCmd_Enable,"Maintenance Command to Enable (allow to run) Motor","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,OCmd_Reset,"Operator Command to Reset all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Motor:AOI,Out_Run,"1=Run Motor, 0=Stop Motor","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Out_Start,"1=Start Motor, 0=Motor left in current state","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Out_Stop,"1=Stop Motor, 0=Motor left in current state","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Val_Owner,"Current Object Owner ID (0=not owned)","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Val_Notify,"Current Alarm Level and Acknowledgement (enumeration)","SINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_Stopped,"1=Motor requested to stop and is confirmed stopped","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Starting,"1=Motor requested to run and awaiting run feedback","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Running,"1=Motor requested to run and is confirmed running","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Stopping,"1=Motor requested to stop and awaiting stopped feedback","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Available,"1=Motor available for control by automation (Prog)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_Bypass,"1=Bypassable Interlocks and Permissives are Bypassed","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_Disabled,"1=Motor is Disabled","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IOFault,"I/O Comm Fault Status (0=OK, 1=Bad)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_Err,"1=Error in Config: see detail bits for reason","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Err_Sim,"1=Error in Config: Simulation timer preset (use 0.0 to 2147483.647)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Err_Alarm,"1=Error in Config: Invalid Alarm Delay or Severity","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_Hand,"1=Mode is Hand (supersedes Maint, Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Maint,"1=Mode is Maintenance (supersedes Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Ovrd,"1=Mode is Override (supersedes Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Prog,"1=Mode is Program (auto)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_Oper,"1=Mode is Operator (manual)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Sts_ProgOperLock,"1=Program or Operator has requested Mode Lock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Alm_FailToStart,"1=Motor Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Ack_FailToStart,"1=Fail to Start Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStartDisabled,"1=Fail to Start Alarm has been disabled (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStartInhibited,"1=Fail to Start Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStartSuppressed,"1=Fail to Start Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Alm_FailToStop,"1=Motor Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Ack_FailToStop,"1=Fail to Stop Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStopDisabled,"1=Fail to Stop Alarm has been disabled (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStopInhibited,"1=Fail to Stop Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_FailToStopSuppressed,"1=Fail to Stop Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Alm_IntlkTrip,"1=Alarm: Motor stopped by an Interlock NOT OK","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Ack_IntlkTrip,"1=Interlock Trip Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IntlkTripDisabled,"1=Interlock Trip Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IntlkTripInhibited,"1=Interlock Trip Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IntlkTripSuppressed,"1=Interlock Trip Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Alm_IOFault,"1=I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Motor:AOI,Ack_IOFault,"1=I/O Fault Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IOFaultDisabled,"1=I/O Fault Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IOFaultInhibited,"1=I/O Fault Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Sts_IOFaultSuppressed,"1=I/O Fault Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Start,"1=Ready to receive OCmd_Start (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Stop,"1=Ready to receive OCmd_Stop (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Bypass,"1=Ready to receive OCmd_Bypass (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Check,"1=Ready to receive OCmd_Check (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Disable,"1=Ready to receive MCmd_Disable (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Enable,"1=Ready to receive MCmd_Enable (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Rdy_Reset,"1=Ready to receive OCmd_Reset (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Motor:AOI,Mode,"Motor Mode Selection","P_Mode","","(Usage := Local)"
TAG,P_Motor:AOI,IOFault,"I/O Fault Alarm","P_Alarm","","(Usage := Local)"
TAG,P_Motor:AOI,IntlkTrip,"Interlock Trip Alarm","P_Alarm","","(Usage := Local)"
TAG,P_Motor:AOI,FailToStop,"Motor Failed to Stop Alarm","P_Alarm","","(Usage := Local)"
TAG,P_Motor:AOI,FailToStart,"Motor Failed to Start Alarm","P_Alarm","","(Usage := Local)"
TAG,P_Motor:AOI,Cfg_Tag,"Tagname for display on HMI","STRING_20","","(Usage := Local)"
TAG,P_Motor:AOI,Cfg_Label,"Label for graphic symbol displayed on HMI","STRING_20","","(Usage := Local)"
TAG,P_Motor:AOI,Cfg_Desc,"Description for display on HMI","STRING_40","","(Usage := Local)"
TAG,P_Motor:AOI,Wrk_Run,"1=Motor should be $Qrunning$Q, 0=should be $Qstopped$Q","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_SimRunT,"Simulation Delay until Running","TIMER","","(Usage := Local)"
TAG,P_Motor:AOI,Wrk_Fault,"1=a Motor Fault has been detected","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_SimStopT,"Simulation Delay until Stopped","TIMER","","(Usage := Local)"
TAG,P_Motor:AOI,Wrk_RunFdbk,"Run Feedback based on mode, simulation, etc. 1=running","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_IntlkTrip,"1=Interlock Not OK Tripped Running Motor","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_Notify,"Buffer for building Val_Notify","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_Bypass,"Internal Bypassable Permissives and Interlocks are Bypassed flag","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Motor:AOI,Wrk_Disabled,"Internal Motor is Disabled","BOOL","","(RADIX := Decimal, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Perm:AOI,Inp_Perm00,"Permissive Cond 00$N(1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm01,"Permissive Cond 01 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm02,"Permissive Cond 02 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm03,"Permissive Cond 03 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm04,"Permissive Cond 04 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm05,"Permissive Cond 05$N(1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm06,"Permissive Cond 06 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm07,"Permissive Cond 07 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Perm:AOI,Inp_Perm08,"Permissive Cond 08 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm09,"Permissive Cond 09 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm10,"Permissive Cond 10$N(1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm11,"Permissive Cond 11 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm12,"Permissive Cond 12 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm13,"Permissive Cond 13 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm14,"Permissive Cond 14 (1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Inp_Perm15,"Permissive Cond 15$N(1=OK,0=don$'t start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Cfg_Bypassable,"Set bits indicate which conditions can be bypassed","INT","","(RADIX := Binary, Usage := Input, Required := false, Visible := false)"
TAG,P_Perm:AOI,Sts_PermOK,"Overall Permissive Status (1=OK to start)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Perm:AOI,Sts_NBPermOK,"Non-Bypassable Permissive Status (1 =all non- bypassable Permissives OK to start)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Perm:AOI,Sts_Perm,"Individual Permissive Status (1=OK, 0=don$'t start)","INT","","(RADIX := Binary, Usage := Output, Required := false, Visible := true)"
TAG,P_Perm:AOI,Cfg_CondTxt,"Short HMI description of Permissive Conditions","STRING_20[16]","","(Usage := Local)"
TAG,P_Perm:AOI,Wrk_Inp,"Collection copy of Inp_PermXXs","INT","","(RADIX := Binary, Usage := Local)"
TAG,P_Perm:AOI,Wrk_Bypass,"Working Register for Bypassable Permissives","INT","","(RADIX := Binary, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_Reset:AOI,Inp_Reset,"Reset Input, 1=Reset, from pushbutton or another object","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Reset:AOI,Inp_ResetReqd,"1=Reset Required, enable Reset button","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_Reset:AOI,Cfg_MinHoldTime,"Minimum Time to hold Reset Output true (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_Reset:AOI,PCmd_Reset,"Program Command to Reset, from other object","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Reset:AOI,OCmd_Reset,"Operator Command to Reset, from HMI","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_Reset:AOI,Out_Reset,"1=Reset received for this P_Reset$'s scope","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_Reset:AOI,Rdy_Reset,"1=Ready to receive OCmd_Reset (enable button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_Reset:AOI,Wrk_HoldT,"Reset Output Hold Timer (TOF)","TIMER","","(Usage := Local)"
TAG,P_Reset:AOI,Wrk_EnableInONS,"EnableIn transition detection to pulse Reset Output","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Reset:AOI,Wrk_HoldONS,"One-Shot to fire Hold Timer to ensure min. output ON time.","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_Reset:AOI,Wrk_ResetCond,"Any incoming Reset condition is TRUE","BOOL","","(RADIX := Decimal, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_ResInh:AOI,Inp_Stopped,"Equipment is confirmed Stopped","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Inp_Starting,"Equipment is Starting, indicating a start attempt","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Inp_Running,"Equipment is confirmed Running","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Cfg_ThreeColdStarts,"Sec within which three starts are allowed if cold","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_FirstFailCold,"Sec for cold motor to wait after 1st start failure before ready to start","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_SubseqFailCold,"Sec for cold motor to wait after 2nd and subsequent start failure before ready","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_FirstFailHot,"Sec for hot motor to wait after 1st start failure before ready to start","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_SubseqFailHot,"Sec for hot motor to wait after 2nd and subsequent start failure before ready","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_HotRestartOK,"Sec for hot motor to run so it can immediately restart after stop","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_RestartHot,"Sec for hot motor to wait after stop if stopped before Hot Restart OK time","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Cfg_HotToCold,"Sec for a stopped hot motor to become cold","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Val_MinToReady,"Minutes yet inhibited before ready to start (mmm:ss)","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Val_SecToReady,"Seconds yet inhibited before ready to start$N(mmm:ss)","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Val_State,"State Number (see State Diagram in docs) for HMI","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_ResInh:AOI,Sts_Ready,"Permissive for unit to start 1=ready, 0=not ready","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Sts_Err,"1=Error in Config: Invalid Time (use 0.0 to 2147483)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_ResInh:AOI,Wrk_FirstColdStartT,"Time since first cold start","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_FirstFailColdT,"Time for cold motor to wait after 1st start failure before ready","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_SubsFailColdT,"Time for cold motor to wait after 2nd and subs. failures before ready","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_FirstFailHotT,"Time for hot motor to wait after 1st start failure before ready","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_SubsFailHotT,"Time for hot motor to wait after 2nd and subs. failures before ready","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_HotRestartOKT,"Time for hot motor to run so it can restart immediately when stopped","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_RestartHotT,"Time for hot motor to wait after stop after running less than Hot Restart OK time","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_HotToColdT,"Time for a stopped hot motor to become cold","TIMER","","(Usage := Local)"
TAG,P_ResInh:AOI,Wrk_FailCount,"Number of failed start attempts","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_ResInh:AOI,Wrk_mSecUntilReady,"Milliseconds until the inhibit time is done and the unit is ready to start","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_ResInh:AOI,Wrk_SecUntilReady,"Seconds until inhibit time is done and the unit is ready to start","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_ResInh:AOI,Wrk_State,"Instruction State (see state diagram in design docs)","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_ResInh:AOI,Wrk_Ready,"Internal storage of Sts_Ready:$N1 = OK to start","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_ResInh:AOI,Wrk_SecondColdStartT,"Time since second cold start","TIMER","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_RunTime:AOI,Inp_Starting,"1=Motor is Starting (from motor instruction)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Inp_Running,"1=Motor is Running (from motor instruction)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,PCmd_ClearStarts,"Program Command to Clear Count of Starts (attempts)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,PCmd_ClearMaxHrs,"Program Command to Clear Maximum (continuous) Run Time for any start","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,PCmd_ClearTotHrs,"Program Command to Clear Total Running Time","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,MCmd_ClearStarts,"Maintenance Command to Clear Count of Starts (attempts)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,MCmd_ClearMaxHrs,"Maintenance Command to Clear Maximum (continuous) Run Time for any start","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,MCmd_ClearTotHrs,"Maintenance Command to Clear Total Running Time","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_RunTime:AOI,Val_Starts,"Total number of motor starts or attempts","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Val_CurRunHrs,"Current running time this start (hours)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Val_MaxRunHrs,"Maximum continuous running time for a given start (hours)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Val_TotRunHrs,"Total accumulated running time (hours)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_RunTime:AOI,Wrk_CurHours,"Whole hours of current run time","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_RunTime:AOI,Wrk_CurRunT,"Timer for timing current run time","TIMER","","(Usage := Local)"
TAG,P_RunTime:AOI,Wrk_TotTenths,"Tenths of hours of total run time","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_RunTime:AOI,Wrk_Starts,"Counter for counting motor starts","COUNTER","","(Usage := Local)"
TAG,P_RunTime:AOI,Wrk_TotRunT,"Retentive timer for timing 0.1 hour total run time","TIMER","","(Usage := Local)"
TAG,P_RunTime:AOI,Wrk_MaxHours,"Internal Maximum Run Hours","REAL","","(RADIX := Float, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,P_VSD:AOI,Inp_SpeedFdbk,"Speed Feedbak in Drive Units (typ. 0-32767 = 0 to max freq.)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_FaultCode,"Current Drive Fault Code (enumeration)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Inp_Datalink,"Auxiliary Signal (datalink) Input in Drive (raw) Units","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Ready,"1=Drive is ready to run","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Running,"1=Drive is Running (active)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_CommandDir,"1=Drive is commanded Forward, 0=Drive is commanded Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_ActualDir,"1=Drive is running Forward, 0=Drive is running Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Accelerating,"1=Drive is accelerating","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Decelerating,"1=Drive is decelerating","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Alarm,"1=Drive has an Alarm Condition (see drive display or manual)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Faulted,"1=Drive has Faulted (see drive display or manual)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_AtSpeed,"1=Drive is at commanded speed","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_FwdPermOK,"1=Permissives OK, drive can start Forward","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_FwdNBPermOK,"1=Non-Bypassable Permissives OK, drive can start Forward","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_RevPermOK,"1=Permissives OK, drive can start Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_RevNBPermOK,"1=Non-Bypassable Permissives OK, motor can start Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_IntlkOK,"1=Interlocks OK, drive can start/run","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_NBIntlkOK,"1=Non-Bypassable Interlocks OK, drive can start/run","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_IOFault,"Input Communication Status 0=OK, 1=fail","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Sim,"1=Simulate working drive; 0=Start/Stop/ Monitor actual drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Inp_Hand,"1=Select Hand (hardwired) Control Strategy","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Ovrd,"1=Select Override control strategy","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_OvrdState,"1=Override to RUN, 0=Override to STOP","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_OvrdSpeed,"Speed at which to run drive in Override if Overriding to RUN","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Inp_Reset,"1=Reset drive fault conditions and latched Alarms","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,P_VSD:AOI,Cfg_HasReverse,"1=Drive can be run reverse, 0=Forward only","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasJog,"1=Drive Jog Command enabled/visible, 0=Drive Jog Command not allowed","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasRunFdbk,"1=Drive provides speed feedback and run signal","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_UseRunFdbk,"1=Drive run feedback should be used for failure checking","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasInpDatalink,"1=A signal is connected to Inp_Datalink1","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasOutDatalink,"1=A signal is connected to Out_Datalink1","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasFwdPermObj,"1=Tells HMI a P_Perm is connected to Inp_FwdPerm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasRevPermObj,"1=Tells HMI a P_Perm is connected to Inp_RevPerm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasIntlkObj,"1=Tells HMI a P_Intlk is connected to Inp_Intlk","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasResInhObj,"1=Tells HMI a P_ResInh Restart Inhibit is connected","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_HasRunTimeObj,"1=Tells HMI a P_RunTime is connected","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SetTrack,"1=PSets track OSets in Oper, OSets track PSets in Prog, 0=no tracking","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SetTrackOvrdHand,"1=Prog/Oper Settings track Override/Hand speed reference","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_PCmdClear,"1=Clear Program Commands on receipt$N0=Leave Set","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OvrdPermIntlk,"1=Override ignores Bypassable Perm/ Intlk; 0=always use Perm/Intlk","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStartResetReqd,"1=Reset requied to clear Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStopResetReqd,"1=Reset required to clear Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IntlkTripResetReqd,"1=Reset required to clear Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_DriveFaultResetReqd,"1=Reset required to clear Drive Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IOFaultResetReqd,"1=Reset required to clear I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStartAckReqd,"1=Acknowledge required for Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStopAckReqd,"1=Acknowledge required for Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IntlkTripAckReqd,"1=Acknowledge required for Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_DriveFaultAckReqd,"1=Acknowledge required for Drive Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IOFaultAckReqd,"1=Acknowledge required for I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStartSeverity,"Fail To Start Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStopSeverity,"Fail To Stop Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IntlkTripSeverity,"Interlock Trip Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_DriveFaultSeverity,"Drive Fault Alarm Severity 1=info, 2=warn, 3=excep, 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_IOFaultSeverity,"I/O Fault Alarm Severity 1=info 2=warn 3=excep 4=fault","SINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_MinSpdRef,"Minimum Speed Reference in EU (for limiting)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_MaxSpdRef,"Maximum Speed Reference in EU (for limiting)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedRefRawMin,"Speed Reference Minimum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedRefRawMax,"Speed Reference Maximum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedRefEUMin,"Speed Reference Minimum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedRefEUMax,"Speed Reference Maximum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedFdbkRawMin,"Speed Feedback Minimum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedFdbkRawMax,"Speed Feedback Maximum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedFdbkEUMin,"Speed Feedback Minimum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SpeedFdbkEUMax,"Speed Feedback Maximum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_InpDatalinkRawMin,"Input Datalink Minimum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_InpDatalinkRawMax,"Input Datalink Maximum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_InpDatalinkEUMin,"Input Datalink Minimum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_InpDatalinkEUMax,"Input Datalink Maximum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkMin,"Minimum Output Datalink in EU (for limiting)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkMax,"Maximum Output Datalink in EU (for limiting)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkRawMin,"Output Datalink Minimum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkRawMax,"Output Datalink Maximum in Drive (raw) Units (for scaling)","INT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkEUMin,"Output Datalink Minimum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_OutDatalinkEUMax,"Output Datalink Maximum in Engineering Units (for scaling)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_SimRampT,"Time to ramp speed fdbk when in Simulation (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStartT,"Time after Start to get Run Feedback before Fault (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_FailToStopT,"Time after Stop to drop Run Feedback before Fault (sec)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Cfg_ResetPulseT,"Time to pulse Out_Reset to clear drive fault","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PSet_SpeedRef,"Program Setting of Speed Reference (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PSet_OutDatalink,"Program Setting of Output Datalink (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PSet_Owner,"Program Owner Request ID (non-zero) or Release (zero)","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OSet_SpeedRef,"Operator Setting of Speed Reference (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OSet_OutDatalink,"Operator Setting of Output Datalink (EU)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Start,"Program Command to Start Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Stop,"Program Command to Stop Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Fwd,"Program Command to set direction to Fowrard","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Rev,"Program Command to set direction to Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Acq,"Program Command to Acquire ownership (Oper/OOS to Prog)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Rel,"Program Command to Release ownership (Prog to OOS)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Lock,"Program Command to Lock Mode in Prog","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Unlock,"Program Command to Unlock Mode","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_Reset,"Program Command to Reset drive fault and all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStartAck,"Program Command to Acknowledge Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStartInhibit,"Program Command to Inhibit Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStartUninhibit,"Program Command to Uninhibit Fail to Start Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStopAck,"Program Command to Acknowledge Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStopInhibit,"Program Command to Inhibit Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_FailToStopUninhibit,"Program Command to Uninhibit Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IntlkTripAck,"Program Command to Acknowledge Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IntlkTripInhibit,"Program Command to Inhibit Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IntlkTripUninhibit,"Program Command to Uninhibit Interlock Trip Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_DriveFaultAck,"Program Command to Acknowledge Drive Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_DriveFaultInhibit,"Program Command to Inhibit Drive Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_DriveFaultUninhibit,"Program Command to Uninhibit Drive Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IOFaultAck,"Program Command to Acknowledge I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IOFaultInhibit,"Program Command to Inhibit I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,PCmd_IOFaultUninhibit,"Program Command to Uninhibit I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Start,"Operator Command to Start Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Stop,"Operator Command to Stop Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Jog,"Operator Command to Jog Drive (not cleared by P_VSD!)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Fwd,"Operator Command to set direction to Forward","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Rev,"Operator Command to set direction to Reverse","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Bypass,"Operator Command to Bypass all Bypassable Interlocks and Permissives","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Check,"Operator Command to Check (not bypass) all Interlocks and Permissives","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,MCmd_Disable,"Maintenance Command to Disable Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,MCmd_Enable,"Maintenance Command to Enable (allow to run) Drive","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,OCmd_Reset,"Operator Command to Reset all Alarms requiring Reset","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,P_VSD:AOI,Out_SpeedRef,"Drive Speed Reference in Drive Units (typ. 0-32767 = 0 to max freq.)","INT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Datalink,"Auxiliary Signal (datalink) Output in Drive (raw) Units","INT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Run,"1=Start/Run Drive, 0=Stop Drive (for held starter type)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Out_Stop,"1=Stop Drive, 0=drive left in current state","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Start,"1=Start Drive, 0=drive left in current state","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Jog,"1=Jog drive at Jog Speed, -->0=stop jogging","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_ClearFault,"1=Attempt to clear Drive Fault","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Fwd,"1=Set drive direction to Forward","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Out_Rev,"1=Set drive direction to Reverse","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Val_SpeedRef,"Speed Reference (target) to drive","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Val_SpeedFdbk,"Speed Feedback (actual) from drive","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Val_InpDatalink,"Input Datalink value from drive","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Val_OutDatalink,"Output Datalink value to drive","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Val_SpeedFdbkEUMin,"Minimum of Speed Feedback = MIN (Cfg_SpeedFdbkEUMin, Cfg_SpeedFdbkEUMax)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Val_SpeedFdbkEUMax,"Maximum of Speed Feedback = MAX (Cfg_SpeedFdbkEUMin, Cfg_SpeedFdbkEUMax)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Val_Owner,"Current Object Owner ID (0=not owned)","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Val_Notify,"Current Alarm Level and Acknowledgement (enumeration)","SINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Stopped,"1=Drive requested to stop and is confirmed stopped","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Starting,"1=Drive requested to run and awaiting run feedback","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Running,"1=Drive requested to run and is confirmed running","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Stopping,"1=Drive requested to stop and awaiting stopped feedback","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Jogging,"1=Drive requested to Jog","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_CommandDir,"1=Drive commanded to Forward, 0=Reverse","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_ActualDir,"1=Drive Actual direction is Forward, 0=Reverse","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Accel,"1=Drive is Accelerating","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Decel,"1=Drive is Decelerating","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_NotReady,"1=Drive is Not Ready (cannot be started)$NCheck alarms, stops, faults","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Alarm,"1=Drive has an Alarm (see drive display or manual)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_AtSpeed,"1=Drive is running at reference speed","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_SpeedLimited,"1=Speed Reference Setting exceeds configured Max/Min limit","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Available,"1=Drive available for control by automation (Prog)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Bypass,"1=Bypassable Interlocks and Permissives are Bypassed","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Disabled,"1=Drive is Disabled","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IOFault,"I/O Comm Fault Status (0=OK, 1=Bad)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Err,"1=Error in Config: see detail bits for reason","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Err_Sim,"1=Error in Config: simulation data (timer preset: use 0.0 to 2147483.647)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_Timer,"1=Error in Config: Invalid Reset Pulse Time (use 0.0 to 2147483.647)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_Alarm,"1=Error in Config: Invalid Alarm Delay or Severity","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_FdbkRaw,"1=Erron in Config: Speed Fdbk Raw Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_FdbkEU,"1=Error in Config: Speed Fdbk EU Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_RefLim,"1=Error in Config: Speed Ref Limit Min > Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_RefEU,"1=Error in Config: Speed Ref EU Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_RefRaw,"1=Error in Config: Speed Ref Raw Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_InpDLRaw,"1=Error in Config: Input Datalink Raw Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_InpDLEU,"1=Error in Config: Input Datalink EU Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_OutDLLim,"1=Error in Config: Output Datalink Limits Min > Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_OutDLEU,"1=Error in Config: Output Datalink EU Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Err_OutDLRaw,"1=Error in Config: Output Datalink Raw Min = Max","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_Hand,"1=Mode is Hand (supersedes Maint, Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Maint,"1=Mode is Maintenance (supersedes Ovrd, Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Ovrd,"1=Mode is Override (supersedes Prog, Oper)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Prog,"1=Mode is Program (auto)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_Oper,"1=Mode is Operator (manual)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Sts_ProgOperLock,"1=Program or Operator has requested Mode Lock","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Alm_FailToStart,"1=Drive Fail to tart Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Ack_FailToStart,"1=Fail to Start Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStartDisabled,"1=Fail to Start Alarm has been disabled (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStartInhibited,"1=Fail to Start Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStartSuppressed,"1=Fail to Start Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Alm_FailToStop,"1=Drive Fail to Stop Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Ack_FailToStop,"1=Fail to Stop Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStopDisabled,"1=Fail to Stop Alarm has been disabled (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStopInhibited,"1=Fail to Stop Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_FailToStopSuppressed,"1=Fail to Stop Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Alm_IntlkTrip,"1=Alarm: Drive stopped by an Interlock NOT OK","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Ack_IntlkTrip,"1=Interlock Trip Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IntlkTripDisabled,"1=Interlock Trip Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IntlkTripInhibited,"1=Interlock Trip Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IntlkTripSuppressed,"1=Interlock Trip Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Alm_DriveFault,"1=Alarm: Drive Fault (see drive display or manual)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Ack_DriveFault,"1=Drive Fault Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_DriveFaultDisabled,"1-=Drive Fault Alarm has been disabled (will not be sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_DriveFaultInhibited,"1=Drive Fault Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_DriveFaultSuppressed,"1-Drive Fault Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Alm_IOFault,"1=I/O Fault Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,P_VSD:AOI,Ack_IOFault,"1=I/O Fault Alarm has been acknowledged","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IOFaultDisabled,"1=I/O Fault Alarm is Disabled (not saved or sent)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IOFaultInhibited,"1=I/O Fault Alarm has been inhibited by logic","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Sts_IOFaultSuppressed,"1=I/O Fault Alarm has been suppressed (logged only)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Start,"1=Ready to receive OCmd_Start (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Stop,"1=Ready to receive OCmd_Stop (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Jog,"1=Ready to receive OCmd_Jog (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Fwd,"1=Ready to receive OCmd_Fwd (enabled HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Rev,"1=Ready to receive OCmd_Rev (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Bypass,"1=Ready to receive OCmd_Bypass (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Check,"1=Ready to receive OCmd_Check (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Disable,"1=Ready to receive MCmd_Disable (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Enable,"1=Ready to receive MCmd_Enable (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Rdy_Reset,"1=Ready to receive OCmd_Reset (enables HMI button)","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := false)"
TAG,P_VSD:AOI,Mode,"Drive Mode Selection","P_Mode","","(Usage := Local)"
TAG,P_VSD:AOI,IOFault,"I/O Fault Alarm","P_Alarm","","(Usage := Local)"
TAG,P_VSD:AOI,IntlkTrip,"Interlock Trip Alarm","P_Alarm","","(Usage := Local)"
TAG,P_VSD:AOI,FailToStop,"Drive Failed to Stop Alarm","P_Alarm","","(Usage := Local)"
TAG,P_VSD:AOI,FailToStart,"Drive Failed to Start Alarm","P_Alarm","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_Tag,"Tagname for display on HMI","STRING_20","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_Label,"Label for graphic symbol displayed on HMI","STRING_20","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_Desc,"Description for display on HMI","STRING_40","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_Run,"1=Drive should be $Qrunning$Q, 0=should be $Qstopped$Q","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_AccelT,"Simulation Accel Ramp timer until Running at speed","TIMER","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_StopT,"Stop Check Timer","TIMER","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_StartT,"Start Check Timer","TIMER","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_Fault,"1=any Fault has been detected","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_DecelT,"Simulation Decel Ramp time until fully stopped","TIMER","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_RunFdbk,"Run Feedback based on mode, simulation, etc. 1=running","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_IntlkTrip,"1=Interlock Not OK Tripped Running Drive","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_Notify,"Buffer for building Val_Notify","DINT","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_Bypass,"Internal Bypassable Permissives and Interlocks are Bypassed flag","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_Disabled,"Internal Drive is Disabled","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,DriveFault,"Drive Faulted Alarm","P_Alarm","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_SpeedRefEU,"Speed Reference Engineering Units for display on HMI","STRING_8","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_SpeedRef,"Working copy of Speed Reference (for limiting)","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_VSD:AOI,Wrk_Rev,"Working (internal) Direction 1=Reverse 0=Forward (default)","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_Jog,"1=Jog Drive, 0=Drive not jogging","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_ResetT,"Reset Output Pulse Timer","TIMER","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_ResetCond,"Any incoming Reset condition is TRUE","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Wrk_ResetONS,"One-Shot to fire Reset Timer to ensure min. output ON time.","BOOL","","(RADIX := Decimal, Usage := Local)"
TAG,P_VSD:AOI,Cfg_SpeedFdbkEU,"Speed Feedback Engineering Units for display on HMI","STRING_8","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_OutDatalinkLabel,"Datalink Output Label displayed on faceplate","STRING_20","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_InpDatalinkLabel,"Datalink Input Label displayed on faceplate","STRING_20","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_OutDatalinkEU,"Datalink Output Engineering Units for display on HMI","STRING_8","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_InpDatalinkEU,"Datalink Input Engineering Units for display on HMI","STRING_8","","(Usage := Local)"
TAG,P_VSD:AOI,Wrk_OutDatalink,"Selected Output Datalink setting","REAL","","(RADIX := Float, Usage := Local)"
TAG,P_VSD:AOI,Cfg_RevText,"Name for Reverse Direction, e.g., $QDown$Q, $QReverse$Q","STRING_16","","(Usage := Local)"
TAG,P_VSD:AOI,Cfg_FwdText,"Name for Forward Direction, e.g., $QUp$Q, $QForward$Q","STRING_16","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,U_FlowPacing:AOI,Inp_Chemical,"Chemical","U_Chemical","","(Usage := InOut, Required := true, Visible := true)"
TAG,U_FlowPacing:AOI,Inp_Pump,"Chemical Pump","P_VSD","","(Usage := InOut, Required := true, Visible := true)"
TAG,U_FlowPacing:AOI,Inp_PacedFlow,"Paced Flow","U_Flow","","(Usage := InOut, Required := true, Visible := true)"
TAG,U_FlowPacing:AOI,Inp_On,"Turn Flow Pacing On/Off$N1 = On$N0= Off","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,OSet_Dosage,"Operator Setpoint Pump Dosage (PPM)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,OSet_PumpCapacityGPH,"Operator Setpoint Max Pump Capacity (GPH)","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,OSet_PumpLength,"Operator Setpoint Pump Length Setpoint","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Alm_Prog,"Flow pacing is in Alarm","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Sts_Prog,"Flow Pacing is in Program Mode","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Sts_Intlk,"Flow pacing is interlocked","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Rdy_Flow,"Flow Ready for Flow Pacing","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Rdy_Pump,"Pump Ready for Flow Pacing","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Sts_PumpStartReqCmd,"Pump Start Request Command","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Val_PumpSpeedRef,"Pump Speed Reference","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Val_PacedFlowMGD,"Paced Flow","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Val_ExpectedMaxPacedFlowMGD,"Calculated Max Paced Flow pump can handle at current Pump Capacity","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Val_ExpectedPumpCapacityGPH,"Calculated Pump Capacity (GPH)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Val_ExpectedFlowRateGPH,"Calculated Expected Chemical Flow Rate (GPH)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Val_ChemPercentSolution,"Chemical Solution (%)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,Val_ChemWeightLbPGal,"Chemical Weight (lb/Gal)","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowPacing:AOI,TempSpeed,"Internal Speed Variable","REAL","","(RADIX := Float, Usage := Local)"
TAG,U_FlowPacing:AOI,ExpectedMaxPacedFlowMGD,"Calculated Max Paced Flow pump can handle at current Pump Capacity","REAL","","(RADIX := Float, Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,U_FlowTot:AOI,Inp_AIn,"Flow Analog Input AOI","P_AIn","","(Usage := InOut, Required := true, Visible := true)"
TAG,U_FlowTot:AOI,Inp_WallClock,"PLC Wall Clock","U_WallClock","","(Usage := InOut, Required := true, Visible := true)"
TAG,U_FlowTot:AOI,Inp_ProgStartReq,"Prog Start Request.  If needed map to turn on totalizer, (ex. pump running) else Defaults to 1 (always start)","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,U_FlowTot:AOI,Val_FlowRate,"Current Flow Rate","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowTot:AOI,Val_DailyTot,"Todays Total Flow","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowTot:AOI,Val_YestTot,"Yesterday Total Flow","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowTot:AOI,Val_YearlyTot,"This Year Total Flow","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowTot:AOI,Val_LastYearTot,"Last Year Total Flow","REAL","","(RADIX := Float, Usage := Output, Required := false, Visible := true)"
TAG,U_FlowTot:AOI,YearlyTotalizer,"","TOTALIZER","","(Usage := Local)"
TAG,U_FlowTot:AOI,DailyTotalizer,"","TOTALIZER","","(Usage := Local)"
TAG,U_FlowTot:AOI,FlowRateLowLimit_SSUM,"","SELECTED_SUMMER","","(Usage := Local)"
TAG,U_FlowTot:AOI,LowCutoff_BNOT,"","FBD_BOOLEAN_NOT","","(Usage := Local)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,U_WallClock:AOI,OCmd_SetTime,"Set the Date and Time Bit","BOOL","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Year,"Year To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Month,"Month To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Day,"Day To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Hour,"Hour To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Minute,"Minute To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,OSet_Second,"Second To Set","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := true)"
TAG,U_WallClock:AOI,DOW_Century,"Century or upper two digits from the year","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Day,"Day of the Month 1-31","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Month,"Month 1 = March, 10=december, 11=Jan and 12=Feb","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW,"Day of Week$N 0 = Sun, 1=Mon, 2=Tues, 3=Wed, 4=Thur, 5=Fri, 6=Sat","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,DOW_Temp00,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp01,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp02,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp03,"Intermediate Math Value","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp04,"Intermediate Math Value","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp05,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp06,"Intermediate Math Value","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp07,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp08,"Intermediate Math Value","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp09,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp10,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp11,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp12,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp13,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp14,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Temp15,"Intermediate Math Value","REAL","","(RADIX := Float, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,DOW_Year,"Year within the century or last two digits in year","DINT","","(RADIX := Decimal, Usage := Input, Required := false, Visible := false)"
TAG,U_WallClock:AOI,Val_CurrentYear,"Current Year","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentMonth,"Current Month","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentDay,"Current Day","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentHour,"Current Hour","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentMinute,"Current Minute","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_CurrentSecond,"Current Second","DINT","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_HourlyReset,"Hourly Reset","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_DailyReset,"Daily Reset","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_MonthlyReset,"Monthly Reset","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,Val_YearlyReset,"Yearly Reset","BOOL","","(RADIX := Decimal, Usage := Output, Required := false, Visible := true)"
TAG,U_WallClock:AOI,ONS,"","BOOL[32]","","(RADIX := Decimal, Usage := Local)"
TAG,U_WallClock:AOI,Set_Date,"","DINT[7]","","(RADIX := Decimal, Usage := Local)"
TAG,U_WallClock:AOI,DOW_Input,"","DINT[7]","","(RADIX := Decimal, Usage := Local)"
COMMENT,U_WallClock:AOI,DOW_Input,"Year",,"DOW_Input[0]"
COMMENT,U_WallClock:AOI,DOW_Input,"Month",,"DOW_Input[1]"
COMMENT,U_WallClock:AOI,DOW_Input,"Day",,"DOW_Input[2]"
COMMENT,U_WallClock:AOI,DOW_Input,"Hour",,"DOW_Input[3]"
COMMENT,U_WallClock:AOI,DOW_Input,"Minute",,"DOW_Input[4]"
COMMENT,U_WallClock:AOI,DOW_Input,"Second",,"DOW_Input[5]"
COMMENT,U_WallClock:AOI,DOW_Input,"Microsecond",,"DOW_Input[6]"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"FeedP1","A01_Alarms","===============================================================$NDISCRETE INPUTS$N===============================================================$NDEVICE  ALARM 0 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Device_Alm0)","0"
RCOMMENT,"FeedP1","A01_Alarms","DEVICE ALARM 1 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Device_Alm1)","1"
RCOMMENT,"FeedP1","A01_Alarms","DEVICE ALARM 2 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Device_Alm2)","2"
RCOMMENT,"FeedP1","A01_Alarms","DEVICE ALARM 3 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Device_Alm3)","3"
RCOMMENT,"FeedP1","A01_Alarms","DEVICE ALARM 4 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Device_Alm4)","4"
RCOMMENT,"FeedP1","A02_Control","===============================================================$NDEVICE$N===============================================================$NDevice with interlocks, $Nstart permissives (restart inhibit), and run time accumulator.$NRevision 0.1-00-01 (DER)  First Draft","NOP()","0"
RCOMMENT,"FeedP1","A02_Control","===============================================================$NDEVICE  SIMULATION$N===============================================================$NGlobal on/off inputs simulation to Pump","OTE(Device.Motor.Inp_Sim)","1"
RCOMMENT,"FeedP1","A02_Control","===============================================================$NRESET$N===============================================================$NDEVICE RESET$NResets all alarms, interlocks and faults for the P1 motor and related signals. $NIt also receives and forwards a site-wide reset.  ","Reset(Device.Reset)","2"
RCOMMENT,"FeedP1","A02_Control","===============================================================$NDEVICE PERMISSIVES$N===============================================================$NPerm 00 = Restart Inhibit (P_ResInh, below)$NPerm 01 through Perm 07 = Configurable","Perm(Device.Perm)","3"
RCOMMENT,"FeedP1","A02_Control","===============================================================$NDEVICE MOTOR$N===============================================================$NThis rung actually monitors and controls the Device motor.$NMapping inputs:  Run Feedback$NHand Mode selection (local operation)$NPermissives OK$NProtectives OK,$NI/O Fault signals$NPump Reset (above)$N$NDEVICE$N$NOutput Mapping: Starter output","MOV(Device.Motor.Out_SpeedRef,Device_SpeedRef)","5"
RCOMMENT,"FeedP1","A02_Control","===============================================================$NDEVICE  RUN TIME$N===============================================================$NMonitor Pump  and accumulate run time and start statistics.","RunTime(Device.RunTime)","6"
RCOMMENT,"FeedP1","A02_Control","===============================================================$NDEVICE RESTART INHIBIT$N===============================================================$NMonitor Pump Starts and Running; do not allow a Start if doing so$Nwould be harmful to the motor (e.g., overheating windings).","ResInh(Device.ResInh)","7"
RCOMMENT,"FeedP1","A02_Control","===============================================================$NDEVICE  PROG MODE$N===============================================================$NWhen operator mode is unlocked, enable automatic control (PCmd_Acq)$NUnlatch PCmdClear to accept maintained verses momentary command signals for prog mode","OTU(Device.Motor.Cfg_PCmdClear)","8"
RCOMMENT,"FeedP1","Main","===============================================================$NSUB ROUTINE$N===============================================================","JSR(A01_Alarms,0)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"FeedP2","A01_Alarms","===============================================================$NDISCRETE INPUTS$N===============================================================$NDEVICE  ALARM 0 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Device_Alm0)","0"
RCOMMENT,"FeedP2","A01_Alarms","DEVICE ALARM 1 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Device_Alm1)","1"
RCOMMENT,"FeedP2","A01_Alarms","DEVICE ALARM 2 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Device_Alm2)","2"
RCOMMENT,"FeedP2","A01_Alarms","DEVICE ALARM 3 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Device_Alm3)","3"
RCOMMENT,"FeedP2","A01_Alarms","DEVICE ALARM 4 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Device_Alm4)","4"
RCOMMENT,"FeedP2","A02_Control","===============================================================$NDEVICE$N===============================================================$NDevice with interlocks, $Nstart permissives (restart inhibit), and run time accumulator.$NRevision 0.1-00-01 (DER)  First Draft","NOP()","0"
RCOMMENT,"FeedP2","A02_Control","===============================================================$NDEVICE  SIMULATION$N===============================================================$NGlobal on/off inputs simulation to Pump","OTE(Device.Motor.Inp_Sim)","1"
RCOMMENT,"FeedP2","A02_Control","===============================================================$NRESET$N===============================================================$NDEVICE RESET$NResets all alarms, interlocks and faults for the P1 motor and related signals. $NIt also receives and forwards a site-wide reset.  ","Reset(Device.Reset)","2"
RCOMMENT,"FeedP2","A02_Control","===============================================================$NDEVICE PERMISSIVES$N===============================================================$NPerm 00 = Restart Inhibit (P_ResInh, below)$NPerm 01 through Perm 07 = Configurable","Perm(Device.Perm)","3"
RCOMMENT,"FeedP2","A02_Control","===============================================================$NDEVICE MOTOR$N===============================================================$NThis rung actually monitors and controls the Device motor.$NMapping inputs:  Run Feedback$NHand Mode selection (local operation)$NPermissives OK$NProtectives OK,$NI/O Fault signals$NPump Reset (above)$N$NDEVICE$N$NOutput Mapping: Starter output","MOV(Device.Motor.Out_SpeedRef,Device_SpeedRef)","5"
RCOMMENT,"FeedP2","A02_Control","===============================================================$NDEVICE  RUN TIME$N===============================================================$NMonitor Pump  and accumulate run time and start statistics.","RunTime(Device.RunTime)","6"
RCOMMENT,"FeedP2","A02_Control","===============================================================$NDEVICE RESTART INHIBIT$N===============================================================$NMonitor Pump Starts and Running; do not allow a Start if doing so$Nwould be harmful to the motor (e.g., overheating windings).","ResInh(Device.ResInh)","7"
RCOMMENT,"FeedP2","A02_Control","===============================================================$NDEVICE  PROG MODE$N===============================================================$NWhen operator mode is unlocked, enable automatic control (PCmd_Acq)$NUnlatch PCmdClear to accept maintained verses momentary command signals for prog mode","OTU(Device.Motor.Cfg_PCmdClear)","8"
RCOMMENT,"FeedP2","Main","===============================================================$NSUB ROUTINE$N===============================================================","JSR(A01_Alarms,0)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"FeedPSys","A01_Control","===============================================================$NPump Selection$N===============================================================$NSelector Switch at HMI selects Primary Pump, If Primary is not available, than Backup is called.","OTE(P1_FlowPacing.Inp_On)","0"
RCOMMENT,"FeedPSys","A01_Control","===============================================================$NFlow Pacing - Meter Pump #1$N===============================================================","FlowPacing(P1_FlowPacing,Chemical,P1_Motor,PacedFlow)","2"
RCOMMENT,"FeedPSys","A01_Control","===============================================================$NFlow Pacing - Meter Pump #2$N===============================================================","FlowPacing(P2_FlowPacing,Chemical,P2_Motor,PacedFlow)","3"
RCOMMENT,"FeedPSys","Main","===============================================================$NSUB ROUTINE$N===============================================================","JSR(A01_Control,0)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"MainProgram","A01_DiscreteInputs","===============================================================$NDISCRETE INPUTS$N===============================================================$NDEVICE  ALARM 0 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Alm00)","0"
RCOMMENT,"MainProgram","A01_DiscreteInputs","DEVICE ALARM 1 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Alm01)","1"
RCOMMENT,"MainProgram","A01_DiscreteInputs","DEVICE ALARM 2 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Alm02)","2"
RCOMMENT,"MainProgram","A01_DiscreteInputs","DEVICE ALARM 3 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Alm03)","3"
RCOMMENT,"MainProgram","A01_DiscreteInputs","DEVICE ALARM 4 CONTACT$N1 = OK (target = 1 at all times)$N0 = Alarm$NALWAYS checked (Gate = 1 at all times)","DIn(Alm04)","4"
RCOMMENT,"MainProgram","A02_AnalogInputs","===============================================================$NAlum Tank Level$N==============================================================","AIn(WWTP_AlumTk1Lv)","0"
RCOMMENT,"MainProgram","A02_AnalogInputs","===============================================================$NAeration Tank Influent Flow$N==============================================================","FlowTot(WWTP_AerTk_InflFlow.Tot,WWTP_AerTk_InflFlow.AIn,PLC_WallClock)","1"
RCOMMENT,"MainProgram","A03_Outputs","===============================================================$NOUTPUT MAPPING$N===============================================================","NOP()","0"
RCOMMENT,"MainProgram","Main","===============================================================$NPUMP  SIMULATION$N===============================================================$NGlobal on/off inputs simulation","OTL(PLC_Simulation)","0"
RCOMMENT,"MainProgram","Main","===============================================================$NWALL CLOCK$N==============================================================","WallClock(PLC_WallClock)","1"
RCOMMENT,"MainProgram","Main","===============================================================$NSUB ROUTINE$N===============================================================","JSR(A01_DiscreteInputs,0)","2"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_AIn:AOI","EnableInFalse","============================================================$NOFF-SCAN (EnableIn is False) STATUS$N============================================================$N$NIf this Analog Input is OFF-SCAN (rung is false or EnableIn is false in FBD), then:$N$NClear the Alarms$NShow the Analog Input as $QStale$Q ( [ S ]  MISO indicator ) (Same as I/O Comm Fail)$N$NWARNING:  When OFF-SCAN, all other data elements (except Val_InpPV, see below) are left in their last state !!!","OTL(Sts_PVBad)","0"
RCOMMENT,"P_AIn:AOI","EnableInFalse","============================================================$NANALOG INPUT PROCESSING$N============================================================$N$NThe Process Variable Input Value (Val_InpPV) shows the scaled input,$Nregardless of the settings of Mode, Substitute PV, etc., EVEN WHEN OUT OF SERVICE!$N$NIf NOT in simulation, if the scaling configuration is valid, the Raw Input is scaled to Engineering Units.$NIn Simulation the Simulated Input must be provided in Engineering Units.","MOV(Set_SimPV,Val_InpPV)","1"
RCOMMENT,"P_AIn:AOI","EnableInFalse","This rung publishes the Values for the scaled range.$NIf this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$Nthe values are swapped so the the EUMax Value is always greater than the EUMin Value.$NThis makes the HMI bargraph and trend coding easier, and provides values$Nthat can be pinned to the configuration of a PID, so the AIn and PID ranges are in lockstep.","MOV(Cfg_PVEUMax,Val_PVEUMin)","2"
RCOMMENT,"P_AIn:AOI","EnableInFalse","The first-order filter$'s scan timer must run and clear every scan, whether the Instruction$Nis true or not.  Doing so here avoids a bump in the Value on transition to EnableIn TRUE.","CLR(Wrk_ScanT.ACC)","3"
RCOMMENT,"P_AIn:AOI","EnableInFalse","Alarms are turned off when off-scan or out of service, so clear the Notification Level.","CLR(Val_Notify)","4"
RCOMMENT,"P_AIn:AOI","EnableInFalse","$QLurking$Q Operator Commands are cleared, as well as the Program Reset.","OTU(PCmd_Reset)","5"
RCOMMENT,"P_AIn:AOI","EnableInFalse","Operator Commands are not accepted, so turn off the command Readies.","OTU(Rdy_Reset)","6"
RCOMMENT,"P_AIn:AOI","EnableInFalse","$QLurking$Q Program Commands are cleared if they are set as $QEdge$Q triggered$N(cleared by this object as received).$N(Lurking Acknowledge Commands are left to perform their action.)","OTU(PCmd_FailUninhibit)","7"
RCOMMENT,"P_AIn:AOI","EnableInFalse","Handle $QNO MODE$Q Selection using the standard P_Mode AOI (EnableInFalse Routine, AFI required!).","OTU(Sts_ProgOperLock)","8"
RCOMMENT,"P_AIn:AOI","Logic","============================================================$NP_AIn:  Process Library:  Analog Input (Basic)$N============================================================$NRevision 0.30-01 Draft:  2009-03-02, DER$NChanged OCmd_SubstPV, OCmd_InpPV to MCmds (comments, etc.)$N============================================================$NThis Instruction monitors an Analog Input from a flow, level, pressure,$Ntemperature, or any other analog sensor, and provides:$N$N*  Scaling, from Input (Raw) to PV (Engineering) Units$N*  High-High, High, Low and Low-Low Alarms with configurable delay times and deadbands$N*  Monitoring of input bad/uncertain variable/communication status and out-of-range conditions with alarm$N*  Setting of a simulated input signal for process simulation$N$NModes of operation: Operator, Program, Maintenance$N$N*  Program and Operator Settings for Alarm Thresholds$N*  Maintenance Commands to allow manual override of the input signal (Substitute PV)$N============================================================$NPOWERUP / INVALID STATE HANDLING$N============================================================$NSee Prescan routine for powerup code required for this object.$N============================================================$NMODE PROCESSING$N============================================================$NThese rungs handle received Mode Inputs and Commands:$N$NNOTE:  Operator Commands for Mode, Alarm are sent directly to the contained P_Mode and P_Alarm AOIs.$N$NPCmd_Acq: Program Command to Acquire ownership","OTU(Mode.PCmd_Acq)","0"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_Rel: Program Command to Release ownership (to OOS)","OTL(Mode.PCmd_Rel)","1"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_Lock: Program Command to Lock ownership in Prog Mode","OTU(Mode.PCmd_Lock)","2"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_Unlock: Program Command to Unlock Mode","OTL(Mode.PCmd_Unlock)","3"
RCOMMENT,"P_AIn:AOI","Logic","ALLOWABLE MODES CONFIGURATION$N$NThis object does NOT have the following Modes:$NHand$NOverride","OTU(Mode.Inp_Ovrd)","4"
RCOMMENT,"P_AIn:AOI","Logic","Handle Mode Selection using the standard P_Mode AOI","Mode(Mode)","5"
RCOMMENT,"P_AIn:AOI","Logic","This rung handles simple First-Come First-Served Ownership Arbitration.$NIf a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$NOwnership is assigned to the requesting ID.  When that requestor sets the Owner ID back$Nto zero, Ownership is relinquished back to NONE.","MOV(PSet_Owner,Val_Owner)","6"
RCOMMENT,"P_AIn:AOI","Logic","============================================================$NCOMMAND PROCESSING$N============================================================$NThese rungs handle received Commands:$N$NMCmd_SubstPV: Maintenance Command to select Maintenance-entered substitute PV$N$NDo not allow this Commands if Cfg_NoSubstPV is set.","OTL(Wrk_SubstPV)","7"
RCOMMENT,"P_AIn:AOI","Logic","MCmd_InpPV: Maintenance Command to cancel Substitute PV and return to Live Input PV.","OTU(Wrk_SubstPV)","8"
RCOMMENT,"P_AIn:AOI","Logic","============================================================$NSETTINGS PROCESSING$N============================================================$NThis rung handles received Settings:$N$NWhen the Mode is Program, use the Program Settings for the$NAlarm Thresholds, and copy the Program Settings to the Operator Settings$Nfor bumpless transition from Program to Operator.$N$NWhen the Mode is Operator, use the Operator Settings for the$NAlarm Thresholds, and copy the Operator Settings to the Program Settings$Nfor bumpless transition from Operator to Program.","MOV(Val_LoLoLim,PSet_LoLoLim)","9"
RCOMMENT,"P_AIn:AOI","Logic","============================================================$NANALOG INPUT PROCESSING$N============================================================$N$NThe Process Variable Input Value (Val_InpPV) shows the scaled input,$Nregardless of the settings of Mode, Substitute PV, etc., EVEN WHEN OUT OF SERVICE!$N$NIf NOT in simulation, if the scaling configuration is valid, the Raw Input is scaled to Engineering Units.$NIn Simulation the Simulated Input must be provided in Engineering Units.","MOV(Set_SimPV,Val_InpPV)","10"
RCOMMENT,"P_AIn:AOI","Logic","When this Analog Input is not simulated and tracking is configured ON (default),$Nthe Simulated PV Setting tracks the selected PV for bumpless transfer into Simulation.","MOV(Val_InpPV,Set_SimPV)","11"
RCOMMENT,"P_AIn:AOI","Logic","The Value shows the selected PV.$NWith Substitute PV enabled, it$'s the value of the entered OSet_SubstPV.$NIn normal operation, it$'s the value (Val_InpPV) selected above:$Nthe scaled Input (Inp_PV) or Simulatied PV (Set_SimPV).","MOV(Wrk_UnfiltPV,MSet_SubstPV)","12"
RCOMMENT,"P_AIn:AOI","Logic","In preparation for calculating the Filtered PV, this rung$Ndetermines the time since the previous scan, using a non-stop TON timer.$NWhen we get here, we read the accumulator (in milliseconds, so$Ndivide by 1000.0 to get seconds), then clear the accumulator.  Next scan the accumulator will have$Nincremented up to the number of milliseconds since last scan.  (Works for scan times up to 2 million seconds.....)","CLR(Wrk_ScanT.ACC)","13"
RCOMMENT,"P_AIn:AOI","Logic","Calculate the FILTERED PV. $NFirst, calculate $Qalpha$Q, the portion of the difference between input and previous value to move toward the input.$NThen calculate the new value.","CPT(Wrk_FiltPV,(Wrk_Alpha*Wrk_FiltPV)+((1.0-Wrk_Alpha)*Wrk_UnfiltPV))","14"
RCOMMENT,"P_AIn:AOI","Logic","The Filtered PV becomes the final Value (Val) for the Analog Input block.","MOV(Wrk_FiltPV,Val)","15"
RCOMMENT,"P_AIn:AOI","Logic","This rung publishes the Values for the scaled range.$NIf this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$Nthe values are swapped so the the EUMax Value is always greater than the EUMin Value.$NThis makes the HMI bargraph and trend coding easier, and provides values$Nthat can be pinned to the configuration of a PID, so the AIn and PID ranges are in lockstep.","MOV(Cfg_PVEUMax,Val_PVEUMin)","16"
RCOMMENT,"P_AIn:AOI","Logic","============================================================$NALARM RESET COMMAND HANDLING$N============================================================$NThis rung handles the Alarm Reset Input and Commands.","OTL(Fail.PCmd_Reset)","17"
RCOMMENT,"P_AIn:AOI","Logic","============================================================$NANALOG ALARM PROCESSING$N============================================================$NThe following rungs process the High-High Analog Alarm.$NIf the Analog Value exceeds the High-High limit, or has not fallen back$Nbelow the limit minus deadband, issue a High-High Alarm to the contained P_Alarm block.$N(The contained block takes care of the alarm delay, acknowledgement, reset, etc.)","OTE(HiHi.Inp)","18"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_HiHiAck: Program Command to Acknowledge the High-High Alarm","OTL(HiHi.PCmd_Ack)","19"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_HiHiInhibit: Program Command to Inhibit the High-High Alarm","OTL(HiHi.PCmd_Uninhibit)","20"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_HiHiUninhibit: Program Command to Uninhibit the High-High Alarm","OTL(HiHi.PCmd_Uninhibit)","21"
RCOMMENT,"P_AIn:AOI","Logic","Move High-High Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","MOV(Cfg_HiHiMinDuration,HiHi.Cfg_MinDuration)","22"
RCOMMENT,"P_AIn:AOI","Logic","Handle High-High Alarm Processing using the standard P_Alarm AOI","Alarm(HiHi)","23"
RCOMMENT,"P_AIn:AOI","Logic","The following rungs process the High Analog Alarm.$NIf the Analog Value exceeds the High limit, or has not fallen back$Nbelow the limit minus deadband, issue a High Alarm to the contained P_Alarm block.$N(The contained block takes care of the alarm delay, acknowledgement, reset, etc.)","OTE(Hi.Inp)","24"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_HiAck: Program Command to Acknowledge the High Alarm","OTL(Hi.PCmd_Ack)","25"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_HiInhibit: Program Command to Inhibit the High Alarm","OTL(Hi.PCmd_Uninhibit)","26"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_HiUninhibit: Program Command to Uninhibit the High Alarm","OTL(Hi.PCmd_Uninhibit)","27"
RCOMMENT,"P_AIn:AOI","Logic","Move High Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","MOV(Cfg_HiMinDuration,Hi.Cfg_MinDuration)","28"
RCOMMENT,"P_AIn:AOI","Logic","Handle High Alarm Processing using the standard P_Alarm AOI","Alarm(Hi)","29"
RCOMMENT,"P_AIn:AOI","Logic","The following rungs process the Low Analog Alarm.$NIf the Analog Value falls below the Low limit, or has not risen back$Nabove the limit plus deadband, issue a Low Alarm to the contained P_Alarm block.$N(The contained block takes care of the alarm delay, acknowledgement, reset, etc.)","OTE(Lo.Inp)","30"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_LoAck: Program Command to Acknowledge the Low Alarm","OTL(Lo.PCmd_Ack)","31"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_LoInhibit: Program Command to Inhibit the Low Alarm","OTL(Lo.PCmd_Uninhibit)","32"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_LoUninhibit: Program Command to Uninhibit the Low Alarm","OTL(Lo.PCmd_Uninhibit)","33"
RCOMMENT,"P_AIn:AOI","Logic","Move Low Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","MOV(Cfg_LoMinDuration,Lo.Cfg_MinDuration)","34"
RCOMMENT,"P_AIn:AOI","Logic","Handle Low Alarm Processing using the standard P_Alarm AOI","Alarm(Lo)","35"
RCOMMENT,"P_AIn:AOI","Logic","The following rungs process the Low-Low Analog Alarm.$NIf the Analog Value falls below the Low-Low limit, or has not risen back$Nabove the limit plus deadband, issue a Low-Low Alarm to the contained P_Alarm block.$N(The contained block takes care of the alarm delay, acknowledgement, reset, etc.)","OTE(LoLo.Inp)","36"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_LoLoAck: Program Command to Acknowledge the Low-Low Alarm","OTL(LoLo.PCmd_Ack)","37"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_LoLoInhibit: Program Command to Inhibit the Low-Low Alarm","OTL(LoLo.PCmd_Uninhibit)","38"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_LoLoUninhibit: Program Command to Uninhibit the Low-Low Alarm","OTL(LoLo.PCmd_Uninhibit)","39"
RCOMMENT,"P_AIn:AOI","Logic","Move Low-Low Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","MOV(Cfg_LoLoMinDuration,LoLo.Cfg_MinDuration)","40"
RCOMMENT,"P_AIn:AOI","Logic","Handle Low-Low Alarm Processing using the standard P_Alarm AOI","Alarm(LoLo)","41"
RCOMMENT,"P_AIn:AOI","Logic","The following rungs process the Analog Input Failure Alarm.$NIf the Input PV Value rises above the Fail High Limit, or has not come back$Nbelow the limti (with deadband), or if the Analog Value falls below the Fail Low$NLimit, or nas not combe back above the limit (with deadband), or if the Input$Nquality is bad or I/O communication is faulted (except in Simulation),$Nissue the Analog Input Failure Alarm to the contained P_Alarm block.$N(The contained block takes care of the alarm delay, acknowledgement, reset, etc.)","OTE(Fail.Inp)","42"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_FailAck: Command to Acknowledge the Analog Input Failure Alarm","OTL(Fail.PCmd_Ack)","43"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_FailInhibit: Program Command to Inhibit the Analog Input Failure Alarm","OTL(Fail.PCmd_Uninhibit)","44"
RCOMMENT,"P_AIn:AOI","Logic","PCmd_FailUninhibit: Program Command to Uninhibit the Analog Input Failure Alarm","OTL(Fail.PCmd_Uninhibit)","45"
RCOMMENT,"P_AIn:AOI","Logic","Move Analog Input Failure Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","MOV(Cfg_FailMinDuration,Fail.Cfg_MinDuration)","46"
RCOMMENT,"P_AIn:AOI","Logic","Handle Analog Input Failure Alarm Processing using the standard P_Alarm AOI","Alarm(Fail)","47"
RCOMMENT,"P_AIn:AOI","Logic","============================================================$NSTATUS GENERATION$N============================================================$N$NThe following rung generates Status bits for this object.$N$NThe Mode Status bits are a copy of the internal Mode AOI bits for Oper, Prog, Maint and Prog/Oper Lock.$N$NRemaining status bits are those not covered in the rungs above.","OTE(Sts_PVUncertain)","48"
RCOMMENT,"P_AIn:AOI","Logic","This rung handles the reports of all Bad Configuration Status.$NIndividual bits are provided for various status:$NBad Raw Scaling configs$NBad Engineering Units Scaling configs$NBad 1st-Order Filter configs$NBad Alarm Deadband configs$NBad Alarm Minimum Duration configs$N$NThen a summary Bad Config status is provided, simply an OR of the individual bits.$N","OTE(Sts_Err)","49"
RCOMMENT,"P_AIn:AOI","Logic","These Status bits are a copy of the internal Alarm AOI bits for Alm, Ack,$NSts_Disabled, Sts_Inhibited and Sts_Suppressed bits for the five alarms.","OTE(Sts_FailSuppressed)","50"
RCOMMENT,"P_AIn:AOI","Logic","============================================================$NNOTIFICATION VALUE$N============================================================$NIndicate the current alarm notification level as the max of any of the alarms:$N0 = none$N2 = info or prompt only$N4 = warning$N6 = exception (equipment impact)$N8 = fault (equipment failure)$NAdd one for any unsuppressed alarm that is not acknowledged (for blink).","MOV(Wrk_Notify,Val_Notify)","51"
RCOMMENT,"P_AIn:AOI","Logic","============================================================$NCOMMAND READIES$N============================================================$NIn Maintenance Mode, commands for Substitue PV and Input PV are available$Nbased on the current state of the internal toggle bit.","OTE(Rdy_InpPV)","52"
RCOMMENT,"P_AIn:AOI","Logic","This object requires a Reset if any of its Alarms requires a Reset.","OTE(Rdy_Reset)","53"
RCOMMENT,"P_AIn:AOI","Prescan","============================================================$NPRESCAN (POWERUP) HANDLING$N============================================================$NOn Prescan, set the Ownership to NO OWNER (0).","CLR(Val_Owner)","0"
RCOMMENT,"P_AIn:AOI","Prescan","$QLurking$Q Operator Commands are cleared, as well as the Program Reset.","OTU(PCmd_Reset)","1"
RCOMMENT,"P_AIn:AOI","Prescan","$QLurking$Q Program Commands are cleared if they are set as $QEdge$Q triggered$N(cleared by this object as received).$N(Lurking Acknowledge Commands are left to perform their action.)","OTU(PCmd_FailUninhibit)","2"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_Alarm:AOI","EnableInFalse","============================================================$NP_Alarm: EnableInFalse (False Rung) Handling$N============================================================$NWhen EnableIn is FALSE (False Rung), the Input$N($QInp$Q) is inverted.  This allows the P_Alarm instruction$Nto be used on a simple Ladder Diagram rung:$N$NXIC  (condition)   P_Alarm (Alarm)$N$NAll processing is identical to the normal Logic$Nroutine, except references to Inp are inverted!$N============================================================$NCOMMAND PROCESSING$N============================================================$NThese rungs handle received Commands:$NOperator Commands (OCmd_xx) from the HMI and$NProgram Command (PCmd_xx) from other objects.$N$NNOTE:  ALARM COMMANDS ARE ACCEPTED REGARDLESS OF COMMAND POINT SELECTION$N$NThis rung receives the Operator Alarm Disable Command","OTL(Disabled)","0"
RCOMMENT,"P_Alarm:AOI","EnableInFalse","This rung receives the Operator Alarm Enable Command (Enable wins over Disable)$N$NNOTE: Disable can also be set/cleared directly by the HMI (FTA&E support).","OTU(Disabled)","1"
RCOMMENT,"P_Alarm:AOI","EnableInFalse","This rung receives the Program Alarm Inhibit Command","OTL(Wrk_Inhibited)","2"
RCOMMENT,"P_Alarm:AOI","EnableInFalse","This rung receives the Operator Alarm Uninhibit Command (Uninhibit wins over Inhibit)","OTU(Wrk_Inhibited)","3"
RCOMMENT,"P_Alarm:AOI","EnableInFalse","This rung receives the Alarm Acknowledge Commands$N$NNOTE: Acknowledge can also be set/cleared directly by the HMI.","OTL(Ack)","4"
RCOMMENT,"P_Alarm:AOI","EnableInFalse","This rung receives the Alarm Reset Commands.$N$NIf the Alarm Reset Command is received and the Input condition is no longer true$N(NOTE the inverted $QInp$Q !!!),$Nthe Alarm is CLEARED and ACKNOWLEDGED (to match ALMD behavior!!!).","OTL(Ack)","5"
RCOMMENT,"P_Alarm:AOI","EnableInFalse","============================================================$NCONFIGURATION$N============================================================$NThis rung gets the Minimum Duration Configuration and sets the$Npreset of the Minimum Duration Timer.  If the preset is inavlid (negative),$Nthe Minimum Duration is set to zero (immediate) and the bad Config is flagged.$NBad Config is also flagged if the Cfg_Severity is out of range (valid = 1..4)","OTE(Sts_Err)","6"
RCOMMENT,"P_Alarm:AOI","EnableInFalse","============================================================$NALARM GENERATION$N============================================================$NThis rung CLEARS the Alarm if Reset is NOT Required and the$NAlarm condition CLEARS.   (NOTE the inverted  $QInp$Q!!!!)","OTU(Wrk_Alm)","7"
RCOMMENT,"P_Alarm:AOI","EnableInFalse","This rung sets the Alarm (Alm) bit if the Input is true for the Minimum Duration time,$Nand sets (if Ack not required) or clears (if Ack required) the Acknowledge (Ack) bit$Nwhen the Alarm initially occurs, or when the Alarm is active and$Nbecomes Enabled or Uninhibited.$N(NOTE the inverted $QInp$Q!!!)","OTL(Wrk_Alm)","8"
RCOMMENT,"P_Alarm:AOI","EnableInFalse","============================================================$NSTATUS GENERATION$N============================================================$NThis rung copies the internal working status to public Status, Alarm and Ack bits.$NNote that internal working bits are used so that outside objects cannot manipulate$Nthe state of this object by setting/clearing its Status and Alarm bits.$N$NPublic Status is generated for:$NAlarm$NNotify Level (color, blink)$NAlarm Inhibited$N(Ack, Suppressed and Disabled can be set/cleared by the HMI directly.)","OTE(Inhibited)","9"
RCOMMENT,"P_Alarm:AOI","EnableInFalse","============================================================$NOPERATOR COMMAND READIES$N============================================================$NThis Alarm is ready for (requires) an Acknowledgement if the Alarm$Nis not Acknowledged and Acknowledgement is Required.$NThis Alarm is ready for (requires) a Reset if there is an Alarm, Reset is Required$Nand the Alarm Condition is CLEARED (NOTE the inverted $QInp$Q!!!).$NIf the Alarm is NOT Disabled, it is ready for Disable.$NIf the Alarm IS Disabled, it is ready for Enable.","OTE(Rdy_Enable)","10"
RCOMMENT,"P_Alarm:AOI","Logic","============================================================$NP_Alarm:  Control Module Library Alarm Sub-block$N============================================================$NRevision 0.20-00 For Test:  2009-02-23, DER$NAdded Cfg_Severity, Val_Notify$N============================================================$NThis instruction provides standard Alarm handling for a given input Alarm condition.$NThis instruction should be imbedded in any instruction that generates alarms,$None instance per alarm generated.$N============================================================$NPOWERUP / INVALID STATE HANDLING$N============================================================$NAll internal Work (state) bits maintain states through a power cycle and are$Nindependent.  No Powerup / Invalid State Handling logic is required.$N============================================================$NCOMMAND PROCESSING$N============================================================$NThese rungs handle received Commands:$NOperator Commands (OCmd_xx) from the HMI and$NProgram Command (PCmd_xx) from other objects.$N$NNOTE:  ALARM COMMANDS ARE ACCEPTED REGARDLESS OF COMMAND POINT SELECTION$N$NThis rung receives the Operator Alarm Disable Command","OTL(Disabled)","0"
RCOMMENT,"P_Alarm:AOI","Logic","This rung receives the Operator Alarm Enable Command (Enable wins over Disable)$N$NNOTE: Disable can also be set/cleared directly by the HMI (FTA&E support).","OTU(Disabled)","1"
RCOMMENT,"P_Alarm:AOI","Logic","This rung receives the Program Alarm Inhibit Command","OTL(Wrk_Inhibited)","2"
RCOMMENT,"P_Alarm:AOI","Logic","This rung receives the Operator Alarm Uninhibit Command (Uninhibit wins over Inhibit)","OTU(Wrk_Inhibited)","3"
RCOMMENT,"P_Alarm:AOI","Logic","This rung receives the Alarm Acknowledge Commands$N$NNOTE: Acknowledge can also be set/cleared directly by the HMI.","OTL(Ack)","4"
RCOMMENT,"P_Alarm:AOI","Logic","This rung receives the Alarm Reset Commands.$N$NIf the Alarm Reset Command is received and the Input condition is no longer true,$Nthe Alarm is CLEARED and ACKNOWLEDGED (to match ALMD behavior!!!).","OTL(Ack)","5"
RCOMMENT,"P_Alarm:AOI","Logic","============================================================$NCONFIGURATION$N============================================================$NThis rung gets the Minimum Duration Configuration and sets the$Npreset of the Minimum Duration Timer.  If the preset is inavlid (negative),$Nthe Minimum Duration is set to zero (immediate) and the bad Config is flagged.$NBad Config is also flagged if the Cfg_Severity is out of range (valid = 1..4)","OTE(Sts_Err)","6"
RCOMMENT,"P_Alarm:AOI","Logic","============================================================$NALARM GENERATION$N============================================================$NThis rung CLEARS the Alarm if Reset is NOT Required and the$NAlarm condition CLEARS.","OTU(Wrk_Alm)","7"
RCOMMENT,"P_Alarm:AOI","Logic","This rung sets the Alarm (Alm) bit if the Input is true for the Minimum Duration time,$Nand sets (if Ack not required) or clears (if Ack required) the Acknowledge (Ack) bit$Nwhen the Alarm initially occurs, or when the Alarm is active and$Nbecomes Enabled or Uninhibited.","OTL(Wrk_Alm)","8"
RCOMMENT,"P_Alarm:AOI","Logic","============================================================$NSTATUS GENERATION$N============================================================$NThis rung copies the internal working status to public Status, Alarm and Ack bits.$NNote that internal working bits are used so that outside objects cannot manipulate$Nthe state of this object by setting/clearing its Status and Alarm bits.$N$NPublic Status is generated for:$NAlarm$NNotify Level (color, blink)$NAlarm Inhibited$N(Ack, Suppressed and Disabled can be set/cleared by the HMI directly.)","OTE(Inhibited)","9"
RCOMMENT,"P_Alarm:AOI","Logic","============================================================$NOPERATOR COMMAND READIES$N============================================================$NThis Alarm is ready for (requires) an Acknowledgement if the Alarm$Nis not Acknowledged and Acknowledgement is Required.$NThis Alarm is ready for (requires) a Reset if there is an Alarm, Reset is Required,$Nand the alarm condition has CLEARED.$NIf the Alarm is NOT Disabled, it is ready for Disable.$NIf the Alarm IS Disabled, it is ready for Enable.","OTE(Rdy_Enable)","10"
RCOMMENT,"P_Alarm:AOI","Prescan","============================================================$NPRESCAN (POWERUP) HANDLING$N============================================================$NOn Prescan, clear any $Qlurking$Q Commands.","OTU(PCmd_Reset)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_DIn:AOI","EnableInFalse","============================================================$NENABLE_IN_FALSE ROUTINE$N============================================================$NThis logic is identical to the main LOGIC Routine, except that the$NInp_PV signal is inverted.  This is to support Ladder Diagram instances$Nof the form:    XIC (discrete input)   P_DIn (P_DIn Tag)$N============================================================$NPOWERUP / INVALID STATE HANDLING$N============================================================$NAll internal Work (state) bits maintain states through a power cycle and are$Nindependent.  No Powerup / Invalid State Handling logic is required.$N============================================================$NCOMMAND PROCESSING$N============================================================$NThese rungs handle received Commands:$N$NNOTE:  Operator Commands for P_Alarm are sent directly to the contained P_Alarm AOI.$N$NMCmd_SubstPV: Maintenance Command to select Maintenance-entered substitute PV$N$NDo not allow this Commands if Cfg_NoSubstPV is set.","OTL(Wrk_SubstPV)","0"
RCOMMENT,"P_DIn:AOI","EnableInFalse","MCmd_InpPV: Maintenance Command to cancel Substitute PV and return to Live Input PV.","OTU(Wrk_SubstPV)","1"
RCOMMENT,"P_DIn:AOI","EnableInFalse","============================================================$NCONFIGURATION$N============================================================$N$NThese rungs get Configuration data (such as timer presets) and distribute as needed.$NNote that some Configuration data are used directly in-place.$N$NEnter the time (in seconds) the Status must remain in each state (debounce time).$NThis time is used in a rising-edge debounce timer and a falling-edge debounce timer.$N$NEnter the time (in seconds) the alarm Gate must be true before alarm detection is activated.$N$NIf the timer preset calcuated wraps negative (more than 2.14... million seconds), then establish$Na valid limit value for the Preset.  Note that a negative timer preset will fault the controller!!!","MOV(Wrk_RiseT.PRE,Wrk_FallT.PRE)","2"
RCOMMENT,"P_DIn:AOI","EnableInFalse","============================================================$NDISCRETE INPUT PROCESSING$N============================================================$N$NSts_IOFault:  If the I/O communication is OK, or in Simulation or substituted, show NO I/O Fault.$NIf the I/O communication is faulted and we$'re NOT in Simulation or using substitute PV, show the I/O Fault.$N$NNOTE: Latch and Unlatch are used to avoid verification warnings because$Nof logic in the PreScan routine.","OTL(Sts_IOFault)","3"
RCOMMENT,"P_DIn:AOI","EnableInFalse","FOR THE ENABLE_IN_FALSE ROUTINE, the Process Variable Status (Sts_PV) bit shows$Nthe INVERSE of the state of the Inp_PV Input, to support the   XIC (discrete input)  P_DIn (P_DIn Tag)$Nconstruct for instantiation and I/O mapping.  This will typically use Inp_PV = 1, making Sts_PV $Nfollow the rung condition.","OTE(Sts_PV)","4"
RCOMMENT,"P_DIn:AOI","EnableInFalse","The Simulated PV Setting tracks the selected PV for bumpless transfer into Simulation.$N$NNOTE:  Tracking must be done with latch/unlatch instructions to keep the $NSet_SimPV setting retentive through a power cycle.$NIn order to avoid overwriting asynchronous inputs, the Set_SimPV bit is only written$Nwhen Simulation is NOT selected (live PV is used).","OTU(Set_SimPV)","5"
RCOMMENT,"P_DIn:AOI","EnableInFalse","The Status (Sts) bit shows the state of the selected input.$NIn normal operation, it$'s the state of the Input (Sts_PV).$NIn Substitute PV, it$'s the state of the entered Substitute PV (Oper or Prog).","OTE(Wrk_Sts)","6"
RCOMMENT,"P_DIn:AOI","EnableInFalse","These two rungs debounce the selected PV, ensuring the Status stays in$Neach state a minimum time, while not delaying the Status on transition after an$Nextended period of time in the prior state.","TON(Wrk_RiseT,?,?)","7"
RCOMMENT,"P_DIn:AOI","EnableInFalse","The Rising Edge triggered timer ENABLE bit (sealed in using the Timing bit)$Nis our debounced input.  Pass it along as the Status.","OTU(Sts)","9"
RCOMMENT,"P_DIn:AOI","EnableInFalse","Finally, if we are NOT using the Substitute PV, have it track the$Ndebounced Status for bumpless transfer to Substitute.","OTL(MSet_SubstPV)","10"
RCOMMENT,"P_DIn:AOI","EnableInFalse","============================================================$NALARM RESET COMMAND HANDLING$N============================================================$NThis rung handles the Alarm Reset Commands","OTL(Alarm.PCmd_Reset)","11"
RCOMMENT,"P_DIn:AOI","EnableInFalse","============================================================$NALARM GENERATION$N============================================================$N$NThe Discrete Input Alarm is $Qgated$Q by a signal such as $Qpump running$Q, which must$Nbe true for a certain period of time before alarm checking is activated.$N$NFor example, a Flow Loss alarm for a pump is only checked when the pump has$Nbeen running long enough to establish flow.  The Flow is expected to be$Nlost when the pump isn$'t running!$N$NIf no gating signal is available, set Inp_Gate to 1 and Cfg_GateT to 0.","TON(Wrk_GateDlyT,?,?)","12"
RCOMMENT,"P_DIn:AOI","EnableInFalse","Alarm:  This object is not Out of Service, the gate is true, the gate delay is done, the (Process) input$Nis in the alarm state (opposite of the Target state), the alarm is not disabled (all from the rungs above),$Nand the alarm delay is done.  (This last function is done by the Cfg_MinDuration in the P_Alarm instruction!)","OTE(Alarm.Inp)","13"
RCOMMENT,"P_DIn:AOI","EnableInFalse","PCmd_AlmAck: Program Command to Acknowledge the Alarm","OTL(Alarm.PCmd_Ack)","14"
RCOMMENT,"P_DIn:AOI","EnableInFalse","PCmd_AlmInhibit: Program Command to Inhibit the Alarm","OTL(Alarm.PCmd_Uninhibit)","15"
RCOMMENT,"P_DIn:AOI","EnableInFalse","PCmd_AlmUninhibit: Program Command to Uninhibit the Alarm","OTL(Alarm.PCmd_Uninhibit)","16"
RCOMMENT,"P_DIn:AOI","EnableInFalse","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","MOV(Cfg_AlarmMinDuration,Alarm.Cfg_MinDuration)","17"
RCOMMENT,"P_DIn:AOI","EnableInFalse","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(Alarm)","18"
RCOMMENT,"P_DIn:AOI","EnableInFalse","============================================================$NSTATUS GENERATION$N============================================================$N$NThe following rung generates Status bits for this object.$N$NThe Status bits are a copy of the internal Alarm AOI bits for Alm, AlmAck, AlmDisa and AlmSuppr.","OTE(Sts_AlarmSuppressed)","19"
RCOMMENT,"P_DIn:AOI","EnableInFalse","This rung handles the reports of all Bad Configuration Status.$NIndividual bits are provided for various status:$NBad timer presets are determined in the Configuration logic above.$NBad Alarm configuration is determined by the P_Alarm instruction.$N$NThen a summary Bad Config status is provided, simply an OR of the individual bits.","OTE(Sts_Err)","20"
RCOMMENT,"P_DIn:AOI","EnableInFalse","============================================================$NNOTIFICATION VALUE$N============================================================$NIndicate the current alarm notification level as the max of any of the alarms:$N0 = none$N2 = info or prompt only$N4 = warning$N6 = exception (equipment impact)$N8 = fault (equipment failure)$NAdd one for any unsuppressed alarm that is not acknowledged (for blink).","MOV(Alarm.Val_Notify,Val_Notify)","21"
RCOMMENT,"P_DIn:AOI","EnableInFalse","============================================================$NCOMMAND READIES$N============================================================$NCommands for Substitue PV and Input PV are available$Nbased on the current state of the internal toggle bit.","OTE(Rdy_InpPV)","22"
RCOMMENT,"P_DIn:AOI","EnableInFalse","This object requires a Reset if any of its Alarms requires a Reset.","OTE(Rdy_Reset)","23"
RCOMMENT,"P_DIn:AOI","Logic","============================================================$NP_DIn:  Control Module Library Discrete Input$N============================================================$NRevision 0.27-01 Draft:  2009-03-02, DER$NChanged OCmd_SubstPV, OCmd_InpPV to MCmds (comments, etc.)$N============================================================$NThis Instruction monitors a Discrete Input from a flow switch, motor overload,$Nor any other discrete signal, and provides:$N$N*  Status, with configurable names for the 0- and 1-states$N*  An Alarm $QGate$Q signal (with delay), used to enable an Alarm under appropriate process conditions$N*  A $QTarget$Q input -- the Alarm is raised when the input is not in the same$Nstate as the Target for a configurable period of time$N* Input debounce for both the rising and falling transitions$N* Commands to inhibit or enable alarms$N* Monitoring of input communication status$N* Setting of a simulated input signal for process simulation$N* Selection of Substitute PV (by Maintenance personnel) or normal PV$N============================================================$NPOWERUP / INVALID STATE HANDLING$N============================================================$NAll internal Work (state) bits maintain states through a power cycle and are$Nindependent.  No Powerup / Invalid State Handling logic is required.$N============================================================$NCOMMAND PROCESSING$N============================================================$NThese rungs handle received Commands:$N$NNOTE:  Operator Commands for P_Alarm are sent directly to the contained AOI.$N$NMCmd_SubstPV: Maintenance Command to select Maintenance-entered substitute PV$N$NDo not allow this Commands if Cfg_NoSubstPV is set.","OTL(Wrk_SubstPV)","0"
RCOMMENT,"P_DIn:AOI","Logic","MCmd_InpPV: Maintenance Command to cancel Substitute PV and return to Live Input PV.","OTU(Wrk_SubstPV)","1"
RCOMMENT,"P_DIn:AOI","Logic","============================================================$NCONFIGURATION$N============================================================$N$NThese rungs get Configuration data (such as timer presets) and distribute as needed.$NNote that some Configuration data are used directly in-place.$N$NEnter the time (in seconds) the Status must remain in each state (debounce time).$NThis time is used in a rising-edge debounce timer and a falling-edge debounce timer.$N$NEnter the time (in seconds) the alarm Gate must be true before alarm detection is activated.$N$NIf the timer preset calcuated wraps negative (more than 2.14... million seconds), then establish$Na valid limit value for the Preset.  Note that a negative timer preset will fault the controller!!!","MOV(Wrk_RiseT.PRE,Wrk_FallT.PRE)","2"
RCOMMENT,"P_DIn:AOI","Logic","============================================================$NDISCRETE INPUT PROCESSING$N============================================================$N$NSts_IOFault:  If the I/O communication is OK, or in Simulation or substituted, show NO I/O Fault.$NIf the I/O communication is faulted and we$'re NOT in Simulation or using substitute PV, show the I/O Fault.$N$NNOTE: Latch and Unlatch are used to avoid verification warnings because$Nof logic in the PreScan routine.","OTL(Sts_IOFault)","3"
RCOMMENT,"P_DIn:AOI","Logic","The Process Variable Status (Sts_PV) bit shows the state of the selected input,$Nregardless of the settings of Mode.","OTE(Sts_PV)","4"
RCOMMENT,"P_DIn:AOI","Logic","The Simulated PV Setting tracks the selected PV for bumpless transfer into Simulation.$N$NNOTE:  Tracking must be done with latch/unlatch instructions to keep the $NSet_SimPV setting retentive through a power cycle.$NIn order to avoid overwriting asynchronous inputs, the Set_SimPV bit is only written$Nwhen Simulation is NOT selected (live PV is used).","OTU(Set_SimPV)","5"
RCOMMENT,"P_DIn:AOI","Logic","The Status (Sts) bit shows the state of the selected input.$NIn normal operation, it$'s the state of the Input (Sts_PV).$NIn Substitute PV, it$'s the state of the entered Substitute PV (Oper or Prog).","OTE(Wrk_Sts)","6"
RCOMMENT,"P_DIn:AOI","Logic","These two rungs debounce the selected PV, ensuring the Status stays in$Neach state a minimum time, while not delaying the Status on transition after an$Nextended period of time in the prior state.","TON(Wrk_RiseT,?,?)","7"
RCOMMENT,"P_DIn:AOI","Logic","The Rising Edge triggered timer ENABLE bit (sealed in using the Timing bit)$Nis our debounced input.  Pass it along as the Status.","OTU(Sts)","9"
RCOMMENT,"P_DIn:AOI","Logic","Finally, if we are NOT using the Substitute PV, have it track the$Ndebounced Status for bumpless transfer to Substitute.","OTL(MSet_SubstPV)","10"
RCOMMENT,"P_DIn:AOI","Logic","============================================================$NALARM RESET COMMAND HANDLING$N============================================================$NThis rung handles the Alarm Reset Commands","OTL(Alarm.PCmd_Reset)","11"
RCOMMENT,"P_DIn:AOI","Logic","============================================================$NALARM GENERATION$N============================================================$N$NThe Discrete Input Alarm is $Qgated$Q by a signal such as $Qpump running$Q, which must$Nbe true for a certain period of time before alarm checking is activated.$N$NFor example, a Flow Loss alarm for a pump is only checked when the pump has$Nbeen running long enough to establish flow.  The Flow is expected to be$Nlost when the pump isn$'t running!$N$NIf no gating signal is available, set Inp_Gate to 1 and Cfg_GateT to 0.","TON(Wrk_GateDlyT,?,?)","12"
RCOMMENT,"P_DIn:AOI","Logic","Alarm:  This object is not Out of Service, the gate is true, the gate delay is done, the (Process) input$Nis in the alarm state (opposite of the Target state), the alarm is not disabled (all from the rungs above),$Nand the alarm delay is done.  (This last function is done by the Cfg_MinDuration in the P_Alarm instruction!)","OTE(Alarm.Inp)","13"
RCOMMENT,"P_DIn:AOI","Logic","PCmd_AlmAck: Program Command to Acknowledge the Alarm","OTL(Alarm.PCmd_Ack)","14"
RCOMMENT,"P_DIn:AOI","Logic","PCmd_AlmInhibit: Program Command to Inhibit the Alarm","OTL(Alarm.PCmd_Uninhibit)","15"
RCOMMENT,"P_DIn:AOI","Logic","PCmd_AlmUninhibit: Program Command to Uninhibit the Alarm","OTL(Alarm.PCmd_Uninhibit)","16"
RCOMMENT,"P_DIn:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","MOV(Cfg_AlarmMinDuration,Alarm.Cfg_MinDuration)","17"
RCOMMENT,"P_DIn:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(Alarm)","18"
RCOMMENT,"P_DIn:AOI","Logic","============================================================$NSTATUS GENERATION$N============================================================$N$NThe following rung generates Status bits for this object.$N$NThe Status bits are a copy of the internal Alarm AOI bits for Alm, AlmAck, AlmDisa and AlmSuppr.","OTE(Sts_AlarmSuppressed)","19"
RCOMMENT,"P_DIn:AOI","Logic","This rung handles the reports of all Bad Configuration Status.$NIndividual bits are provided for various status:$NBad timer presets are determined in the Configuration logic above.$NBad Alarm configuration is determined by the P_Alarm instruction.$N$NThen a summary Bad Config status is provided, simply an OR of the individual bits.","OTE(Sts_Err)","20"
RCOMMENT,"P_DIn:AOI","Logic","============================================================$NNOTIFICATION VALUE$N============================================================$NIndicate the current alarm notification level as the max of any of the alarms:$N0 = none$N2 = info or prompt only$N4 = warning$N6 = exception (equipment impact)$N8 = fault (equipment failure)$NAdd one for any unsuppressed alarm that is not acknowledged (for blink).","MOV(Alarm.Val_Notify,Val_Notify)","21"
RCOMMENT,"P_DIn:AOI","Logic","============================================================$NCOMMAND READIES$N============================================================$NCommands for Substitue PV and Input PV are available$Nbased on the current state of the internal toggle bit.","OTE(Rdy_InpPV)","22"
RCOMMENT,"P_DIn:AOI","Logic","This object requires a Reset if any of its Alarms requires a Reset.","OTE(Rdy_Reset)","23"
RCOMMENT,"P_DIn:AOI","Prescan","============================================================$NPRESCAN (POWERUP) HANDLING$N============================================================$NOn Prescan, clear any $Qlurking$Q Commands.","OTU(PCmd_AlarmUninhibit)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_Intlk:AOI","EnableInFalse","============================================================$NOFF-SCAN (EnableIn is False) STATUS$N============================================================$N$NIf this Interlocks instruction is OFF-SCAN (rung is false or EnableIn is false in FBD),$Nthen set the summary Interlock OK Status bits to FALSE (0).","OTU(Sts_NBIntlkOK)","0"
RCOMMENT,"P_Intlk:AOI","EnableInFalse","Clear $QLurking$Q Commands (received while on false rung).","OTU(PCmd_Reset)","1"
RCOMMENT,"P_Intlk:AOI","Logic","============================================================$NP_Intlk:  PROCESS -- INTERLOCKS$N============================================================$NRevision 0.10-03 Draft:  2009-03-02, DER$NRemoved AFI and dead code in First-Out logic$N============================================================$NThis Instruction monitors up to 16 Interlock conditions.  It provides these features:$N$N*  Interlocks may be configured as Latched.  Latched Interlocks$Nrequire a Reset Command to clear.$N*  Interlocks may be configured as Bypassable.  Bypassable Interlocks are reported$Nseparately; the destination object can use this information to bypass these$NInterlocks in Maintenance Mode or upon command.$N*  First-Out reporting indicates the first condition that caused the running equipment$Nto be tripped.  Separate First-Out for Non-Bypassable Interlocks.$N============================================================$NPOWERUP / INVALID STATE HANDLING$N============================================================$NInterlock, bypass and lock states are maintained through a power cycle or$Nrun/prog/run cycle. No special powerup code is required for this object.$N============================================================$NINPUT GATHERING$N============================================================$NThis object uses word-wise logic.  The first 16 rungs collect the individual$NInterlock Inputs together into a 16-bit integer word for word-wise processing.","OTE(Wrk_Inp.0)","0"
RCOMMENT,"P_Intlk:AOI","Logic","============================================================$NCOMMAND PROCESSING$N============================================================$NOn receipt of a Reset Command, the First Out Status and the output$NInterlock Status (internal copies, actually) are cleared.$N(Later logic may fill these in again if some Interlock conditions are true...)$N$NNOTE:  This object is $QModeless$Q -- Operator and Program Commands$Nare accepted at any time.","CLR(Wrk_Sts)","16"
RCOMMENT,"P_Intlk:AOI","Logic","============================================================$NINTERLOCK PROCESSING$N============================================================$NThis rung clears any bits in the stored Interlock status for which the$NInput bit is OFF and the bit is NOT configured as Latched.","AND(Wrk_Sts,Wrk_Intlk,Wrk_Sts)","17"
RCOMMENT,"P_Intlk:AOI","Logic","This rung SETS Interlock status bits for any Interlock condition Input that is true.","OR(Wrk_Sts,Wrk_Inp,Wrk_Sts)","18"
RCOMMENT,"P_Intlk:AOI","Logic","If the stored Interlock status is now clear (all bits 0), then the$NFirst Out storage is cleared.","CLR(Wrk_FirstOut)","19"
RCOMMENT,"P_Intlk:AOI","Logic","The internal Non-Bypassable Interlocks word has bits set only if the Input is TRUE$NAND the bit is configured as a NON-bypassable Interlock.","AND(Wrk_Sts,Wrk_NB,Wrk_NB)","20"
RCOMMENT,"P_Intlk:AOI","Logic","If the stored Interlock status is now clear (all bits 0), then the$NFirst Out storage is cleared.","CLR(Wrk_NBFirstOut)","21"
RCOMMENT,"P_Intlk:AOI","Logic","Now that we have the final Interlock Status bits, if the First Out status is clear,$Nthis rung will SET the First Out status for any Interlock conditions that$Nmade it this far.  (Ideally there would only be ONE: the $Qfirst$Q condition!)","CPT(Wrk_FirstOut,(Wrk_Sts)AND(NOT(Wrk_PrevSts)))","22"
RCOMMENT,"P_Intlk:AOI","Logic","We have the final Non-Bypassable Interlock Status bits, if the NB First Out status is clear,$Nthis rung will SET the NB First Out status for any Non-Bypassable Interlock conditions that$Nmade it this far.  (Ideally there would only be ONE: the $Qfirst$Q condition!)","CPT(Wrk_NBFirstOut,(Wrk_NB)AND(NOT(Wrk_PrevNB)))","23"
RCOMMENT,"P_Intlk:AOI","Logic","============================================================$NSTATUS GENERATION$N============================================================$NThis rung generates the public Status for this object.$NIf all the Interlock Status bits are zero, there is no condition to$Nshut down the affected equipment.  In that case, show the Interlock Status as $QOK$Q$N$NSimilar logic applies for the Non-Bypassable Interlocks OK Status.$N$NAlso show the individual Interlock Status bits and the First Out Status bits.$N$NNOTE:  Working registers are used to prevent outside writes to the Sts_xxx$Nparameters from affecting the state of this object!","MOV(Wrk_NBFirstOut,Sts_NBFirstOut)","25"
RCOMMENT,"P_Intlk:AOI","Logic","============================================================$NCOMMAND READIES$N============================================================$NThis Interlock ojbect is ready for (needs) a RESET Command$Nif any Latched Interlocks are SET.","OTE(Rdy_Reset)","26"
RCOMMENT,"P_Intlk:AOI","Prescan","============================================================$NPRESCAN (POWERUP) HANDLING$N============================================================$NOn Prescan, clear any $Qlurking$Q Commands.","OTU(PCmd_Reset)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_Mode:AOI","EnableInFalse","============================================================$NP_Mode:  EnableInFalse Handling$N============================================================$NFor EnableInFalse (false rung), handle all received Commands behind the scenes$N(as in Hand Mode), but show NO owner.   !!!$N============================================================$NCOMMAND HANDLING$N============================================================$NNOTE:  These rungs MUST be in the order given to meet the following$Nmultiple-actions-at-the-same-time scenarios:$N$N* Maintenance Release beats Maintenance Acquire$N* Program Release beats Program Acquire$N* Program Unlock beats Program Lock$N* Operator Unlock beats Operator Acquire and Lock (results in Oper Unlocked)$N* Operator Acquire/Lock must come after Program Unlock$N* Program Acquire must come after Operator Unlock$N$NMCmd_Acq: Acquire for Maintenance Mode","OTL(Wrk_Maint)","0"
RCOMMENT,"P_Mode:AOI","EnableInFalse","MCmd_Rel: Release from Maintenance Mode","OTU(Wrk_Maint)","1"
RCOMMENT,"P_Mode:AOI","EnableInFalse","PCmd_Lock: Lock Program Mode","OTL(Wrk_Locked)","2"
RCOMMENT,"P_Mode:AOI","EnableInFalse","PCmd_Unlock: Unlock Program Mode","OTU(Wrk_Locked)","3"
RCOMMENT,"P_Mode:AOI","EnableInFalse","OCmd_AcqLock: Operator Acquire and Lock (take from Program if not locked)","OTL(Wrk_Locked)","4"
RCOMMENT,"P_Mode:AOI","EnableInFalse","OCmd_Unlock: Unlock Operator Mode","OTU(Wrk_Locked)","5"
RCOMMENT,"P_Mode:AOI","EnableInFalse","PCmd_Acq: Acquire for Program Mode","OTL(Wrk_Prog)","6"
RCOMMENT,"P_Mode:AOI","EnableInFalse","PCmd_Rel: Release from Program Mode","OTU(Wrk_Prog)","7"
RCOMMENT,"P_Mode:AOI","EnableInFalse","============================================================$NSTATUS GENERATION$N============================================================$NWith EnableIn False, there is NO owner !!!  ALL Mode Status bits are CLEARED!","OTU(Sts_Oper)","8"
RCOMMENT,"P_Mode:AOI","EnableInFalse","Public Status for:$NSts_ProgOperSel:    Program/Operator substate selection (Prog = 1, Oper = 0)$NSts_ProgOperLock:    Program/Operator Lock substate selection (Locked = 1, Unlocked = 0)","OTE(Sts_ProgOperLock)","9"
RCOMMENT,"P_Mode:AOI","EnableInFalse","============================================================$NOPERATOR COMMAND READIES$N============================================================$NReady for OPERATOR ACQUIRE AND LOCK comand if the Mode is$N is NOT Locked. (Oper $Qacquire and lock$Q when in Prog Mode is a $Qgrab$Q!)$N$NReady fpr OPERATOR UNLOCK command if the Lock is set and the$Ninternal Program bit is cleared (Operator has the lock, even if in Ovrd, Maint or Hand!)$N$NReady for MAINTENANCE ACQUIRE if internal Maintenance latch is NOT set.$N$NReady for MAINTENANCE RELEASE if internal Maintenance latch IS set.","OTE(Rdy_Rel)","10"
RCOMMENT,"P_Mode:AOI","Logic","============================================================$NP_Mode:  PROCESS -- MODE SELECTOR$N============================================================$NRevision 0.20-01  For Test:  2008-11-26, DER$NAdded Prescan code to clear $Qlurking$Q Commands.$N============================================================$NThis instruction provides selection of Mode (owner) for a Device (CM) level object:$N*  Hand (typ. hardwired)  (highest priority)$N*  Maint (taken out of service for maintenance)$N*  Ovrd (typ. process or soft safety interlock)$N*  Prog  (automated control)$N*  Oper (manual control)  (lowest priority owner)$N============================================================$NCOMMAND HANDLING$N============================================================$NNOTE:  These rungs MUST be in the order given to meet the following$Nmultiple-actions-at-the-same-time scenarios:$N$N* Maintenance Release beats Maintenance Acquire$N* Program Release beats Program Acquire$N* Program Unlock beats Program Lock$N* Operator Unlock beats Operator Acquire and Lock (results in Oper Unlocked)$N* Operator Acquire/Lock must come after Program Unlock$N* Program Acquire must come after Operator Unlock$N$NMCmd_Acq: Acquire for Maintenance Mode","OTL(Wrk_Maint)","0"
RCOMMENT,"P_Mode:AOI","Logic","MCmd_Rel: Release from Maintenance Mode","OTU(Wrk_Maint)","1"
RCOMMENT,"P_Mode:AOI","Logic","PCmd_Lock: Lock Program Mode","OTL(Wrk_Locked)","2"
RCOMMENT,"P_Mode:AOI","Logic","PCmd_Unlock: Unlock Program Mode","OTU(Wrk_Locked)","3"
RCOMMENT,"P_Mode:AOI","Logic","OCmd_AcqLock: Operator Acquire and Lock (take from Program if not locked)","OTL(Wrk_Locked)","4"
RCOMMENT,"P_Mode:AOI","Logic","OCmd_Unlock: Unlock Operator Mode","OTU(Wrk_Locked)","5"
RCOMMENT,"P_Mode:AOI","Logic","PCmd_Acq: Acquire for Program Mode","OTL(Wrk_Prog)","6"
RCOMMENT,"P_Mode:AOI","Logic","PCmd_Rel: Release from Program Mode","OTU(Wrk_Prog)","7"
RCOMMENT,"P_Mode:AOI","Logic","============================================================$NSTATUS GENERATION$N============================================================$NThis rung determines the Mode based on the states of the inputs and internal working bits.$NThe logic here does the vast mahority of the implementation of the Mode selection rules.$N$NBetween the internal working bits used above and the rules implemented here,$Noutside objects cannot manipulate the state of this object by setting/clearing its Status bits.$N$NPublic Status is generated for:$N*  Hand Mode$N*  Maintenance Mode$N*  Override Mode$N*  Program Mode$N*  Operator Mode","OTE(Sts_Oper)","8"
RCOMMENT,"P_Mode:AOI","Logic","Public Status for:$NSts_ProgOperSel:    Program/Operator substate selection (Prog = 1, Oper = 0)$NSts_ProgOperLock:    Program/Operator Lock substate selection (Locked = 1, Unlocked = 0)","OTE(Sts_ProgOperLock)","9"
RCOMMENT,"P_Mode:AOI","Logic","============================================================$NOPERATOR COMMAND READIES$N============================================================$NReady for OPERATOR ACQUIRE AND LOCK comand if the Mode is$N is NOT Locked. (Oper $Qacquire and lock$Q when in Prog Mode is a $Qgrab$Q!)$N$NReady fpr OPERATOR UNLOCK command if the Lock is set and the$Ninternal Program bit is cleared (Operator has the lock, even if in Ovrd, Maint or Hand!)$N$NReady for MAINTENANCE ACQUIRE if internal Maintenance latch is NOT set.$N$NReady for MAINTENANCE RELEASE if internal Maintenance latch IS set.","OTE(Rdy_Rel)","10"
RCOMMENT,"P_Mode:AOI","Prescan","============================================================$NPRESCAN (POWERUP) HANDLING$N============================================================$NOn Prescan, clear any $Qlurking$Q Commands.","OTU(PCmd_Unlock)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_Motor:AOI","EnableInFalse","============================================================$NOFF-SCAN (EnableIn is False) STATUS$N============================================================$N$NIf this Motor is OFF-SCAN (rung is false or EnableIn is false in FBD), then:$N$NReset the Alarm Timers$NClear the Alarms$NShow the Motor as $QDisabled$Q$NShow the Motor as Running or Stopped, based on the feedback input$NTurn off the Outputs$N$NOther data are left in Last State!","OTU(Out_Stop)","0"
RCOMMENT,"P_Motor:AOI","EnableInFalse","The Process Variable Status (Sts_PV) bit shows the state of the selected input,$Nregardless of the settings of Command Point, Manual Override, etc., EVEN IF OFF-SCAN!","OTE(Sts_Running)","1"
RCOMMENT,"P_Motor:AOI","EnableInFalse","The Process Variable Status (Sts_PV) bit shows the state of the selected input,$Nregardless of the settings of Command Point, Manual Override, etc., EVEN IF OFF-SCAN!","OTE(Sts_Stopped)","2"
RCOMMENT,"P_Motor:AOI","EnableInFalse","Alarms are turned off when off-scan or out of service, so clear the Notification Level.","CLR(Val_Notify)","3"
RCOMMENT,"P_Motor:AOI","EnableInFalse","$QLurking$Q Operator Commands are cleared, as well as Program Reset.","OTU(PCmd_Reset)","4"
RCOMMENT,"P_Motor:AOI","EnableInFalse","$QLurking$Q Program Commands are cleared if they are set as $QEdge$Q triggered$N(cleared by this object as received).$N(Lurking Acknowledge Commands are left to perform their action.)","OTU(PCmd_IOFaultUninhibit)","5"
RCOMMENT,"P_Motor:AOI","EnableInFalse","Handle $QNO MODE$Q Selection using the standard P_Mode AOI (EnableInFalse Routine, AFI required!).","OTU(Sts_ProgOperLock)","6"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NP_Motor:  PROCESS -- MOTOR (single speed, on/off)$N============================================================$NRevision 0.33-02 Draft:  2009-03-03, DER$NRemoved separate timers, using Alarm timers for Fail to Start, Fail to Stop$N============================================================$NThis Instruction controls and monitors a single-speed motor$N(FVNR, soft-start, etc.) and provides:$N$N*  Monitoring of run feedback, display of actual motor status$N*  Detection of Failure to Start, Failure to Stop$N*  Monitoring of a Permissive condition to allow starting$N* Monitoring of an Interlock condition to stop / prevent starting$N* Simulation, providing feedback of a working motor while disabling outputs$N* Monitoring of I/O communication faults$N* Alarms for Fail to Start, Fail to Stop, Interlock Trip, I/O Fault$N* Operation in Hand, Maintenance, Override, Program and Operator Modes$N* $QAvailable$Q status for use by automation logic to know whether motor$Ncan be controlled by other objects.$N============================================================$NPOWERUP / INVALID STATE HANDLING$N============================================================$NMode states are retained through a power cycle.$NMotor $Qrun$Q request is cleared on first scan, in the rung which unlatches $QWrk_Run$Q, below$N============================================================$NMODE PROCESSING$N============================================================$NThese rungs handle received Mode Inputs and Commands:$N$NNOTE:  Operator Commands for Mode, Alarm are sent directly to the contained P_Mode and P_Alarm AOIs.$N$NInp_Hand: forward the Hand Input directly to the Mode instruction.","OTE(Mode.Inp_Hand)","0"
RCOMMENT,"P_Motor:AOI","Logic","Inp_Ovrd: forward the Override Input directly to the Mode instruction.","OTE(Mode.Inp_Ovrd)","1"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_Acq: Program Command to Acquire ownership","OTU(Mode.PCmd_Acq)","2"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_Rel: Program Command to Release ownership (to OOS)","OTL(Mode.PCmd_Rel)","3"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_Lock: Program Command to Lock ownership in Prog Mode","OTU(Mode.PCmd_Lock)","4"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_Unlock: Program Command to Unlock Mode","OTL(Mode.PCmd_Unlock)","5"
RCOMMENT,"P_Motor:AOI","Logic","Handle Mode Selection using the standard P_Mode AOI","Mode(Mode)","6"
RCOMMENT,"P_Motor:AOI","Logic","This rung handles simple First-Come First-Served Ownership Arbitration.$NIf a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$NOwnership is assigned to the requesting ID.  When that requestor sets the Owner ID back$Nto zero, Ownership is relinquished back to NONE.","MOV(PSet_Owner,Val_Owner)","7"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NCONFIGURATION$N============================================================$N$NThese rungs get Configuration data (such as timer presets) and distribute as needed.$NNote that some Configuration data are used directly in-place.$N$NEnter the time (in seconds) for the motor to successfully start before declaring a fault.$NEnter the time (in seconds) for the motor to successfully stop before declaring a fault.$N$NIf the timer preset calcuated wraps negative (more than 2.14... million seconds), then use a default$Nlimit value and report Bad Configuration.  Note that a negative timer preset will fault the controller!!!","MOV(Cfg_FailToStopT,FailToStop.Cfg_MinDuration)","8"
RCOMMENT,"P_Motor:AOI","Logic","Enter the time (in seconds) to echo back the desired state when running in simulation$N$NHandle timer preset invalid values as above.","MOV(Wrk_SimRunT.PRE,Wrk_SimStopT.PRE)","9"
RCOMMENT,"P_Motor:AOI","Logic","If the motor does not even have a Run Feedback input,$Nit cannot be used for motor feedback checking!","OTU(Cfg_UseRunFdbk)","10"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NRUN FEEDBACK DETERMINATION$N============================================================$NIf the motor is being simulated or has no run feedback, use the Sim Timers to provide$Na $Qfake$Q feedback signal based on the simulation time to start and time to stop.$N$NIf the motor is NOT being simulated and it HAS and IS USING a run feedback,$Nuse the state of the run feedback input as the motor run state.","OTU(Wrk_RunFdbk)","11"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NCOMMAND HANDLING$N============================================================$NThese rungs receive and handle the Commands for this motor.$N$NThe Bypass Command bypasses only the Bypassable Permissives and Interlocks.","OTL(Wrk_Bypass)","12"
RCOMMENT,"P_Motor:AOI","Logic","The Check Command enables checking of ALL$NPermissives and Interlocks (cancels the bypass).","OTU(Wrk_Bypass)","13"
RCOMMENT,"P_Motor:AOI","Logic","The Disable Command disables the motor so it cannot be run.","OTL(Wrk_Disabled)","14"
RCOMMENT,"P_Motor:AOI","Logic","The Enable Command cancels the Disable and allows the motor to run.","OTU(Wrk_Disabled)","15"
RCOMMENT,"P_Motor:AOI","Logic","These next several rungs, in priority order, determine whether$Nthe Motor should be running, jogging or stopped.$N$NIf a Motor START command is received in Operator, Program or Maintenance$NMode, or if in Override Mode and the Override State is RUN, mark the Motor to RUN.$NPermissives must be OK or bypassed to start the Motor (Interlocks are checked below...).$N(Modes are mutually exclusive, thus handling the priority.)","OTL(Wrk_Run)","16"
RCOMMENT,"P_Motor:AOI","Logic","If a Motor STOP command is received in Operator, Program or Maintenance$NMode, or if in Override Mode and the Override State is STOP,$Nmark the Motor TO STOP (jogging or running).","OTU(Wrk_Run)","17"
RCOMMENT,"P_Motor:AOI","Logic","Higher Priority:$NIf Interlocks are not OK (Non-Bypassable not OK, or bypassable not OK$Nand not bypassed by Maintenance, Override or Bypass Command), $NOR if the Motor is DISABLED or FAULTED, set it to STOP.$N$NIf we tripped on an Interlock while running or jogging, also issue the Interlock Trip Alarm.","OTU(Wrk_Run)","18"
RCOMMENT,"P_Motor:AOI","Logic","Highest Priority: HAND always wins:$NIf in Hand, have the Motor follow the RunFeedback.","OTU(Wrk_Run)","19"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NALARM RESET COMMAND HANDLING$N============================================================$NThis rung handles the Alarm Reset Commands","OTL(IOFault.PCmd_Reset)","20"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NMOTOR FAIL TO START ALARMING$N============================================================$NIf the motor SHOULD BE RUNNING, run a Start Timer to check for Fail to Start, and run a$NSimulation Timer to provide simulated run feedback if needed.","TON(Wrk_SimRunT,?,?)","21"
RCOMMENT,"P_Motor:AOI","Logic","If the Start Timer times out and the motor run feedback (or simulated feedback) never showed up,$Nshow the motor as $QFAILED TO START$Q and issue an Alarm.","OTE(FailToStart.Inp)","22"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_FailToStartAck: Program Command to Acknowledge the Fail to Start Alarm","OTL(FailToStart.PCmd_Ack)","23"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_FailToStartInhibit: Program Command to Inhibit the Fail to Start Alarm","OTL(FailToStart.PCmd_Uninhibit)","24"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_FailToStartUninhibit: Program Command to Uninhibit the Fail to Start Alarm","OTL(FailToStart.PCmd_Uninhibit)","25"
RCOMMENT,"P_Motor:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","MOV(Cfg_FailToStartSeverity,FailToStart.Cfg_Severity)","26"
RCOMMENT,"P_Motor:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(FailToStart)","27"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NMOTOR FAIL TO STOP ALARMING$N============================================================$NIf the motor SHOULD BE STOPPED, run a Stop Timer to check for Fail to Stop, and run a$NSimulation Timer to provide simulated run feedback off (stop feedback) if needed.","TON(Wrk_SimStopT,?,?)","28"
RCOMMENT,"P_Motor:AOI","Logic","If the Stop Timer times out and the motor run feedback (or simulated feedback) never showed $Qstopped$Q,$Nshow the motor as $QFAILED TO STOP$Q and issue an Alarm.","OTE(FailToStop.Inp)","29"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_FailToStopAck: Program Command to Acknowledge the Fail to Stop Alarm","OTL(FailToStop.PCmd_Ack)","30"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_FailToStopInhibit: Program Command to Inhibit the Fail to Stop Alarm","OTL(FailToStop.PCmd_Uninhibit)","31"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_FailToStopUninhibit: Program Command to Uninhibit the Fail to Stop Alarm","OTL(FailToStop.PCmd_Uninhibit)","32"
RCOMMENT,"P_Motor:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","MOV(Cfg_FailToStopSeverity,FailToStop.Cfg_Severity)","33"
RCOMMENT,"P_Motor:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(FailToStop)","34"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NMOTOR INTERLOCK TRIP ALARMING$N============================================================$NIf the INTERLOCKS NOT OK caused the motor to stop in the  ---( U )---- Wrk_Run$Nrung above, raise an INTERLOCK TRIP ALARM.","OTE(IntlkTrip.Inp)","35"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_IntlkTripAck: Program Command to Acknowledge the Interlock Trip Alarm","OTL(IntlkTrip.PCmd_Ack)","36"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_IntlkTripInhibit: Program Command to Inhibit the Interlock Trip Alarm","OTL(IntlkTrip.PCmd_Uninhibit)","37"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_IntlkTripUninhibit: Program Command to Uninhibit the Interlock trip Alarm","OTL(IntlkTrip.PCmd_Uninhibit)","38"
RCOMMENT,"P_Motor:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","CLR(IntlkTrip.Cfg_MinDuration)","39"
RCOMMENT,"P_Motor:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(IntlkTrip)","40"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NMOTOR I/O FAULT ALARMING$N============================================================$NIf the I/O FAULT input is true and the I/O are not being SIMULATED,\$Nthen there is an I/O Fault.  Raise an Alarm and stop the motor.","OTE(IOFault.Inp)","41"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_IOFaultAck: Program Command to Acknowledge the I/O Fault Alarm","OTL(IOFault.PCmd_Ack)","42"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_IOFaultInhibit: Program Command to Inhibit the I/O Fault Alarm","OTL(IOFault.PCmd_Uninhibit)","43"
RCOMMENT,"P_Motor:AOI","Logic","PCmd_IOFaultUninhibit: Program Command to Uninhibit the I/O Fault Alarm","OTL(IOFault.PCmd_Uninhibit)","44"
RCOMMENT,"P_Motor:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","CLR(IOFault.Cfg_MinDuration)","45"
RCOMMENT,"P_Motor:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(IOFault)","46"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NOUTPUT GENERATION$N============================================================$N$NIf the motor is NOT SIMULATED and NOT OUT OF SERVICE, generate the$Nappropriate outputs for the motor.$NIf the motor should be running, is not faulted and not in hardwired control, energice Out_Run.$NAlso, energize Out_Start until we get feedback that the motor is running.$N$NIf the motor should be stopped and is not in hardwired control and the feedback shows the motor$Nis NOT stopped, or if the motor is Faulted, energize the Out_Stop output to stop the motor.","OTE(Out_Stop)","48"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NSTATUS GENERATION$N============================================================$N$NThe following rungs generates Status bits for this object.$N$NThese Status bits are a copy of the internal Mode AOI bits for$NHand, Maint, Ovrd, Prog, Oper, and mode Locked.$N$NNOTE for Sts_Maint:  This Motor is in Maintenance (Out Of Service, no able to run normally)$Nif this instruction is on a False Rung (Enable In False).  See the Enable In False Routine.","OTE(Sts_ProgOperLock)","49"
RCOMMENT,"P_Motor:AOI","Logic","This rung generates a summary Bad Config status, simply an OR of the individual bits provided above$N(in the Configuration handling section).","OTE(Sts_Err)","50"
RCOMMENT,"P_Motor:AOI","Logic","This rung generates Alarm Status bits by copying the internal Alarm$NAOI bits for Alm, Ack, Sts_Disabled, Sts_Inhibited and Sts_Suppressed$Nfor each of the Alarms: Fail to Start, Fail to Stop, Interlock Trip and I/O Fault.","OTE(Sts_IOFaultSuppressed)","51"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NNOTIFICATION VALUE$N============================================================$NIndicate the current alarm notification level as the max of any of the alarms:$N0 = none$N2 = info or prompt only$N4 = warning$N6 = exception (equipment impact)$N8 = fault (equipment failure)$NAdd one for any unsuppressed alarm that is not acknowledged (for blink).","MOV(Wrk_Notify,Val_Notify)","52"
RCOMMENT,"P_Motor:AOI","Logic","These rungs generate the Starting, Running, Stopping and Stopped Status bits.$N$NIf the motor is in HAND and HAS NO RUN FEEDBACK, its state is meaningless;$Nturn off ALL the Sts_xxx states!!!!!$N$NIf the motor is commanded to run (Output on) and the feedback doesn$'t yet show it running,$Nthe motor is STARTING.$N$NIf the motor is commanded to run (Output on) and the feedback shows it running,$Nthe motor is RUNNING.$N$NIf the motor is commanded to stoop (Output off) and the feedback still shows it running,$Nthe motor is STOPPING.$N$NIf the motor is commanded to stop (Output off) and the feedback shows it has stopped,$Nthe motor is STOPPED.","OTE(Sts_Stopped)","53"
RCOMMENT,"P_Motor:AOI","Logic","The motor is AVAILABLE to be run by automation (either in Automatic or in $NProgram Manual) if interlocks are OK, and if stopped, permissives are also OK.","OTE(Sts_Available)","54"
RCOMMENT,"P_Motor:AOI","Logic","If the internal Bypass flag is set, Bypassable Permissives and Interlocks ARE BYPASSED.","OTE(Sts_Bypass)","55"
RCOMMENT,"P_Motor:AOI","Logic","If the internal Disabled flag is set, the motor is DISABLED.","OTE(Sts_Disabled)","56"
RCOMMENT,"P_Motor:AOI","Logic","The I/O Fault Status is generated by the same conditions that feed the$NI/O Fault Alarm: the I/O Fault input is true and I/O are NOT being SIMULATED.","OTE(Sts_IOFault)","57"
RCOMMENT,"P_Motor:AOI","Logic","============================================================$NOPERATOR COMMAND READIES$N============================================================$N$NReady to Start if in Operator Manual, Stopped, and Permissives and Interlocks are OK.$N$NReady to Stop if in Operator Manual and (Running or Starting).","OTE(Rdy_Stop)","58"
RCOMMENT,"P_Motor:AOI","Logic","Ready to Bypass all Bypassable Permissives and Interlocks if not bypassed.","OTE(Rdy_Bypass)","59"
RCOMMENT,"P_Motor:AOI","Logic","Ready to Check Bypassable Permissives and Interlocks if bypassed.","OTE(Rdy_Check)","60"
RCOMMENT,"P_Motor:AOI","Logic","Ready to Disable Motor if not Disabled","OTE(Rdy_Disable)","61"
RCOMMENT,"P_Motor:AOI","Logic","Ready to Enable motor if Disabled.","OTE(Rdy_Enable)","62"
RCOMMENT,"P_Motor:AOI","Logic","This object requires a Reset if any of its Alarms requires a Reset.","OTE(Rdy_Reset)","63"
RCOMMENT,"P_Motor:AOI","Prescan","============================================================$NPRESCAN (POWERUP) HANDLING$N============================================================$NOn Prescan, set the Ownership to NO OWNER (0).","CLR(Val_Owner)","0"
RCOMMENT,"P_Motor:AOI","Prescan","$QLurking$Q Operator Commands are cleared, as well as Program Reset.","OTU(PCmd_Reset)","1"
RCOMMENT,"P_Motor:AOI","Prescan","$QLurking$Q Program Commands are cleared if they are set as $QEdge$Q triggered$N(cleared by this object as received).$N(Lurking Acknowledge Commands are left to perform their action.)","OTU(PCmd_IOFaultUninhibit)","2"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_Perm:AOI","EnableInFalse","============================================================$NOFF-SCAN (EnableIn is False) STATUS$N============================================================$N$NIf this Permissives instruction is OFF-SCAN (rung is false or EnableIn is false in FBD),$Nthen set the summary Permissive OK Status bits to FALSE (0).","OTU(Sts_NBPermOK)","0"
RCOMMENT,"P_Perm:AOI","Logic","============================================================$NP_Perm:  PROCESS -- PERMISSIVES$N============================================================$NRevision 0.8-00 Draft:  2009-02-09, DER$NFixed Revision Number format to aligh with FOMP.$N============================================================$NThis Instruction monitors up to 16 Permissive conditions.  It provides these features:$N$N*  Permissives may be configured as Bypassable.  A separate Sts_NBPermOK $N(Non-Bypassable Permissives OK) status is provided, which the destination$Nobject can use forBypass, Maintenance and other functions,$Nwhere Bypassable Permissives can be ignored.$N============================================================$NPOWERUP / INVALID STATE HANDLING$N============================================================$NNo special powerup code is required for this object.$N============================================================$NINPUT GATHERING$N============================================================$NThis object uses word-wise logic.  The first 16 rungs collect the individual$NPermissive Inputs together into a 16-bit integer word for word-wise processing.","OTE(Wrk_Inp.0)","0"
RCOMMENT,"P_Perm:AOI","Logic","============================================================$NPERMISSIVE PROCESSING$N============================================================$NIf an input is Bypassable, or the input is ON, that bit is OK as far as$NNon-Bypassable Permissives are concerned.","OR(Cfg_Bypassable,Wrk_Inp,Wrk_Bypass)","16"
RCOMMENT,"P_Perm:AOI","Logic","============================================================$NSTATUS GENERATION$N============================================================$NThese rungs generate the public Status for this object.$N$NThe Input Permissive conditions are passed through (wordwise)$Ndirectly to the final Permissive Status","MOV(Wrk_Inp,Sts_Perm)","17"
RCOMMENT,"P_Perm:AOI","Logic","If all the Permissive Status bits are ONE, there is no condition to$Nprevent starting the affected equipment: show the Permissive Status as $QOK$Q$N$NIf all the Non-Bypassable permissives are true, set the NBPermOK Status as $QOK$Q","OTE(Sts_NBPermOK)","18"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_Reset:AOI","EnableInFalse","============================================================$NP_Reset:  RESET EnableIn False Handling$N============================================================$NOn EnableIn False:$N$NClear the bit used to detect EnableIn transition from False to True$Nin preparation for the next transition$N$N(See main Logic Routine for EnableIn False-to-True triggering of Reset.)","OTU(Wrk_EnableInONS)","0"
RCOMMENT,"P_Reset:AOI","EnableInFalse","============================================================$NCONFIGURATION$N============================================================$NThis rung takes the configured Output Hold time and calculates$Nthe appropriate hold timer preset.  A negative preset would fault$Nthe controller and so is disallowed.","CLR(Wrk_HoldT.PRE)","1"
RCOMMENT,"P_Reset:AOI","EnableInFalse","============================================================$NCOMMAND AND INPUT HANDLING$N============================================================$NThis rung processes received Reset Commands from:$N$N1.  Higher-level strategies via Program Command$N2.  The Operator via HMI Operator Command$N3.  Pushbuttons or other block via Input, or$N4.  On transition of rung condition from False to True$N(button or other logic as rung condition).$N$NThe reset starts the Hold Timer (One-Shot Off-Delay)$Nto ensure the output is held on for at least the minimum time.","TOF(Wrk_HoldT,?,?)","2"
RCOMMENT,"P_Reset:AOI","EnableInFalse","The Hold Timer $Qdone$Q bit comes on immediately and stays on$Nfor the hold time.  If it, or any held-on reset initiator, is TRUE, set the Output.","OTE(Out_Reset)","3"
RCOMMENT,"P_Reset:AOI","EnableInFalse","If an associated object is ready to be reset, set the Inp_Reset pin on this object.$NThen, if something needs reset, and we$'re not already resetting it, enable this$Nobject$'s Reset Pushbutton.$N$N(If this function is not wired, the button will generally be enabled.$NIf this function IS wired, it is suggested to make the enabled Reset button$NFLASH to alert the operator that a reset is required!)","OTE(Rdy_Reset)","4"
RCOMMENT,"P_Reset:AOI","Logic","============================================================$NP_Reset:  PROCESS -- RESET$N============================================================$NRevision 0.3-001 Draft:  2008-11-26, DER$NAdded Prescan code to clear $Qlurking$Q Commands.$N============================================================$NThis Instruction provides a command/interface point for resetting$Nalarms, faults or other conditions across a strategy (EM,$NUnit, Cell, Area, Site, etc.).  Its Output is intended to be wired$Nto input, device and interlock instructions to allow a single reset$Ncommand or pushbutton to reset alarms and faults in all objects in its scope.$N============================================================$NPOWERUP OR INVALID STATE$N============================================================$NNo special powerup logic is required.$N$N============================================================$NCONFIGURATION$N============================================================$NThis rung takes the configured Output Hold time and calculates$Nthe appropriate hold timer preset.  A negative preset would fault$Nthe controller and so is disallowed.","CLR(Wrk_HoldT.PRE)","0"
RCOMMENT,"P_Reset:AOI","Logic","============================================================$NCOMMAND AND INPUT HANDLING$N============================================================$NThis rung processes received Reset Commands from:$N$N1.  Higher-level strategies via Program Command$N2.  The Operator via HMI Operator Command$N3.  Pushbuttons or other block via Input, or$N4.  On transition of rung condition from False to True$N(button or other logic as rung condition).$N$NThe reset starts the Hold Timer (One-Shot Off-Delay)$Nto ensure the output is held on for at least the minimum time.","TOF(Wrk_HoldT,?,?)","1"
RCOMMENT,"P_Reset:AOI","Logic","The Hold Timer $Qdone$Q bit comes on immediately and stays on$Nfor the hold time.  If it, or any held-on reset initiator, is TRUE, set the Output.","OTE(Out_Reset)","2"
RCOMMENT,"P_Reset:AOI","Logic","If an associated object is ready to be reset, set the Inp_Reset pin on this object.$NThen, if something needs reset, and we$'re not already resetting it, enable this$Nobject$'s Reset Pushbutton.$N$N(If this function is not wired, the button will generally be enabled.$NIf this function IS wired, it is suggested to make the enabled Reset button$NFLASH to alert the operator that a reset is required!)","OTE(Rdy_Reset)","3"
RCOMMENT,"P_Reset:AOI","Prescan","============================================================$NPRESCAN (POWERUP) HANDLING$N============================================================$NOn Prescan, clear any $Qlurking$Q Commands.","OTU(PCmd_Reset)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_ResInh:AOI","EnableInFalse","============================================================$NP_ResInh:  RESTART INHIBIT EnableIn False Handling$N============================================================$NTreat EnableIn False (False Rung) as if$N Inp_Starting = 0, Inp_Running = 0 and Inp_Stopped = 1,$N($'motor stopped$')$N$NThis logic is identical to the main Logic Routine except that actions with the Motor$NRunning or Starting have been removed, and all actions with the Motor$NStopped have been made unconditional.  Adjacent unconditional rungs$Nhave been combined to save memory.$N$N============================================================$NINVALID STATE$N============================================================$NIf the State number is not valid (valid states are 1..12),$N the various timers are reset (all are retentive), and the State Machine is set to:$N$N*  State S01  ( Cold Motor Ready to Start )  if the pump is NOT Running, or$N*  State S03  ( Cold Motor Running )  if the pump is Running.","MOV(3,Wrk_State)","0"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","===========================================================================$NCONFIGURATION$N===========================================================================$N$NThis rung gets Configuration data.  Timer Configurations are scaled from seconds to$Nmilliseconds and stored in the appropriate timer presets.$NIf a calculated timer preset is negative, it will fault the controller;$Noverwrite it and flag the configuration as bad.","MOV(Wrk_FirstColdStartT.PRE,Wrk_SecondColdStartT.PRE)","1"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","====================================================================================$NRESTART INHIBIT STATE MACHINE$N====================================================================================$N$NThe following code implements the State Machine logic shown in the Design Document.$N$NThis rung dispatches execution to the code for the current state.  This is to keep from scanning$Nthe code for all the states every scan, and so that certain timers can be shared by multiple states.$N(For State = 1, execution just falls through into the State 1 code.)","JMP(S12)","2"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S01:  COLD MOTOR READY TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the motor is cold, but ready to start.  $NThe time since the last cold start attempt is accumulated.$N$NWhen the motor is started:$NIf it has been at least LastColdStart minutes since the last attempt was made to start the motor, $Nthe motor is still considered cold, it has had enough time to cool off.  $NIf it has been less than LastColdStart minutes since the last attempt was made to start the motor, $Nthe motor is considered hot due to multiple re-starts in too short a time period.  ","OTL(Wrk_Ready)","3"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S02:  COLD MOTOR STARTING  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, a Cold motor start attempt has been made.$NThe time since the last Cold start attempt is accumulated.   $NThe motor must confirm that it is running within RestartInhibit.Wrk_StartCheckTime minutes.  $NIf it does, the state will change to S3: Cold Motor Running$NIf it does not start properly within the allowable time, the state will change to either S4: 1st Failed Cold Restart, or S5: Subsequent Cold Failed Restart.","OTL(Wrk_Ready)","5"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S03:  COLD MOTOR RUNNING$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, $NThe time since the last cold start attempt is accumulated.  $NIf the cold motor is turned off, the state will change back to S1: Ready to Start, Cold.","OTL(Wrk_Ready)","8"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S04:  COLD MOTOR FIRST FAILURE TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Cold motor has failed to start for the first time since it was last running properly.$NThe time since the last cold start attempt is accumulated.   $NThe state is changed back to S1: Ready to Start, Cold when RestartInhibit.Wrk_FirstFailCold timer elapses.","SUB(Wrk_FirstFailColdT.PRE,Wrk_FirstFailColdT.ACC,Wrk_mSecUntilReady)","10"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S05:  COLD MOTOR SUBSEQUENT FAILURE TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Cold motor has failed to start at least twice in a row since it was last running properly.$NThe time since the last cold start attempt is accumulated.   $NThe state is changed back to S1: Ready to Start, Cold when RestartInhibit.Wrk_SubsFailCold timer elapses.","SUB(Wrk_SubsFailColdT.PRE,Wrk_SubsFailColdT.ACC,Wrk_mSecUntilReady)","13"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S06:  COLD MOTOR STARTING$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, a Hot motor start attempt has been made.$NThe motor must confirm that it is running within RestartInhibit.Wrk_StartCheckTime minutes.  $NIf it does, the state will change to S7: Hot Motor Running < 4 Hours.$NIf it does not start properly within the allowable time, the state will change to either S10: 1st Failed Hot Restart, or S11: Subsequent Hot Failed Restart.","OTL(Wrk_Ready)","16"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S07:  HOT MOTOR RUNNING  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been started. $NIf it is stopped before RestartInhibit.Wrk_HotRestartOk elapses,$Nit must wait RestartInhibit.Wrk_RestartHot minutes before it can be restarted  (S08).$NIf it is stopped after RestartInhibit.Wrk_HotRestartOk elapses, it can be restarted immediately (S09).","RTO(Wrk_HotRestartOKT,?,?)","19"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S08:  HOT MOTOR SHORT RUN THEN STOPPED$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been stopped before RestartInhibit.Wrk_HotRestartOk elapsed.$NIt must wait RestartInhibit.Wrk_RestartHot minutes before it can be restarted  (S12).","SUB(Wrk_RestartHotT.PRE,Wrk_RestartHotT.ACC,Wrk_mSecUntilReady)","21"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S09:  HOT MOTOR LONG RUN COOLED  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been running long enough to have cooled.$NSince it is stopped (EnableIn is false), it can be restarted immediately  (S1).","OTL(Wrk_Ready)","24"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S10:  HOT MOTOR FIRST FAILURE TO START $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has failed to start for the first time since it was last running properly.$NThe time since the Hot motor stopped is accumulated.   Once it reaches the First Hot Fail time,$Nit can be restarted  (S12).","SUB(Wrk_FirstFailHotT.PRE,Wrk_FirstFailHotT.ACC,Wrk_mSecUntilReady)","26"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S11:  HOT MOTOR SUBSEQUENT FAILURE TO START$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has failed to start at least twice in a row since it was last running properly.$NThe time since the Hot motor stopped is accumulated.   Once it reaches the Subsequent Hot Fail Time,$Nit can be restarted  (S12).","SUB(Wrk_SubsFailHotT.PRE,Wrk_SubsFailHotT.ACC,Wrk_mSecUntilReady)","29"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S12:  HOT MOTOR READY TO START$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the motor is Hot, but ready to start.  $NThe time since the Hot motor stopped is accumulated.   $NRestartInhibit.Wrk_LastColdStart is run so it is properly timed out when changing to S1: Ready to Start, Cold.  $NIf 16 hours have elapsed since the Hot motor was running, the state will be changed to S1: Ready to Start, Cold.  $NThis reflects the fact that the motor has had time to cool off.  $NOtherwise, the logic waits for a Start attempt to change the state to S6: Start Check, Hot.","RTO(Wrk_HotToColdT,?,?)","32"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","This is common return point for ALL states when EnableIn is FALSE.$N$N====================================================================================$NSTART TIMERS$N====================================================================================$N$NThese two rungs run the cold start timers used in the $QThree Starts$Q logic when NOT in State 1.","TON(Wrk_SecondColdStartT,?,?)","35"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","====================================================================================$NVALUES$N====================================================================================$N$NThis rung makes sure that the RestartInhibit.Wrk_mSecsUntilReady value is greater than or equal to zero.$NIf it is not, the register value will be cleared.","CLR(Wrk_mSecUntilReady)","37"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","This rung takes the time remaining until the motor is ready to start (in milliseconds), converts it$Nto seconds, then reports it in  minutes : seconds format for display on the HMI or LAWSDAC.","MOD(Wrk_SecUntilReady,60,Val_SecToReady)","38"
RCOMMENT,"P_ResInh:AOI","EnableInFalse","Finally, copy out the internal State number so the HMI can display an animated state diagram.","MOV(Wrk_State,Val_State)","39"
RCOMMENT,"P_ResInh:AOI","Logic","============================================================$NP_ResInh:  PROCESS -- RESTART INHIBIT$N============================================================$NRevision 0.12-01 Draft:  2009-03-04, DER$NComment / Description fixes only.$N============================================================$NThis Instruction monitors starts, running and stops of a motor and decides, based on$Nsimple criteria for winding heating, when the motor can be started again.$N$NThis Instruction is largely State Machine-based.  It has the following states:$N*  S01:  Cold Motor Ready to Start  $N*  S02:  Cold Motor Starting$N*  S03:  Cold Motor Running$N*  S04:  Cold Motor First Failure to Start$N*  S05:  Cold Motor Subsequent Failure to Start$N*  S06:  Hot Motor Starting$N*  S07:  Hot Motor Running$N*  S08:  Hot Motor Short Run Then Stopped$N*  S09:  Hot Motor Long Run Cooled$N*  S10:  Hot Motor First Failure to Start$N*  S11:  Hot Motor Subsequent Failure to Start$N*  S12:  Hot Motor Ready to Start$N$NRefer to the state diagram in the End User Documentation for details.$NNOTE: The state is stored in a Local Tag and not available outside to other$Ninstructions, but can be shown on an HMI.$N============================================================$NINVALID STATE$N============================================================$NIf the State number is not valid (valid states are 1..12),$N the various timers are reset (all are retentive), and the State Machine is set to:$N$N*  State S01  ( Cold Motor Ready to Start )  if the pump is NOT Running, or$N*  State S03  ( Cold Motor Running )  if the pump is Running.","MOV(3,Wrk_State)","0"
RCOMMENT,"P_ResInh:AOI","Logic","===========================================================================$NCONFIGURATION$N===========================================================================$N$NThis rung gets Configuration data.  Timer Configurations are scaled from seconds to$Nmilliseconds and stored in the appropriate timer presets.$NIf a calculated timer preset is negative, it will fault the controller;$Noverwrite it and flag the configuration as bad.","MOV(Wrk_FirstColdStartT.PRE,Wrk_SecondColdStartT.PRE)","1"
RCOMMENT,"P_ResInh:AOI","Logic","====================================================================================$NRESTART INHIBIT STATE MACHINE$N====================================================================================$N$NThe following code implements the State Machine logic shown in the Design Document.$N$NThis rung dispatches execution to the code for the current state.  This is to keep from scanning$Nthe code for all the states every scan, and so that certain timers can be shared by multiple states.$N(For State = 1, execution just falls through into the State 1 code.)","JMP(S12)","2"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S01:  COLD MOTOR READY TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the motor is cold, but ready to start.  $NThe time since the last cold start attempt is accumulated.$N$NWhen the motor is started:$NIf it has been at least LastColdStart minutes since the last attempt was made to start the motor, $Nthe motor is still considered cold, it has had enough time to cool off.  $NIf it has been less than LastColdStart minutes since the last attempt was made to start the motor, $Nthe motor is considered hot due to multiple re-starts in too short a time period.  ","OTL(Wrk_Ready)","3"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S02:  COLD MOTOR STARTING  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, a Cold motor start attempt has been made.$NThe time since the last Cold start attempt is accumulated.   $NThe motor must confirm that it is running within RestartInhibit.Wrk_StartCheckTime minutes.  $NIf it does, the state will change to S3: Cold Motor Running$NIf it does not start properly within the allowable time, the state will change to either S4: 1st Failed Cold Restart, or S5: Subsequent Cold Failed Restart.","OTL(Wrk_Ready)","9"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S03:  COLD MOTOR RUNNING$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, $NThe time since the last cold start attempt is accumulated.  $NIf the cold motor is turned off, the state will change back to S1: Ready to Start, Cold.","OTL(Wrk_Ready)","13"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S04:  COLD MOTOR FIRST FAILURE TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Cold motor has failed to start for the first time since it was last running properly.$NThe time since the last cold start attempt is accumulated.   $NThe state is changed back to S1: Ready to Start, Cold when RestartInhibit.Wrk_FirstFailCold timer elapses.","SUB(Wrk_FirstFailColdT.PRE,Wrk_FirstFailColdT.ACC,Wrk_mSecUntilReady)","16"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S05:  COLD MOTOR SUBSEQUENT FAILURE TO START  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Cold motor has failed to start at least twice in a row since it was last running properly.$NThe time since the last cold start attempt is accumulated.   $NThe state is changed back to S1: Ready to Start, Cold when RestartInhibit.Wrk_SubsFailCold timer elapses.","SUB(Wrk_SubsFailColdT.PRE,Wrk_SubsFailColdT.ACC,Wrk_mSecUntilReady)","19"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S06:  HOT MOTOR STARTING$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, a Hot motor start attempt has been made.$NThe motor must confirm that it is running within RestartInhibit.Wrk_StartCheckTime minutes.  $NIf it does, the state will change to S7: Hot Motor Running < 4 Hours.$NIf it does not start properly within the allowable time, the state will change to either S10: 1st Failed Hot Restart, or S11: Subsequent Hot Failed Restart.","OTL(Wrk_Ready)","22"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S07:  HOT MOTOR RUNNING  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been started. $NIf it is stopped before RestartInhibit.Wrk_HotRestartOk elapses,$Nit must wait RestartInhibit.Wrk_RestartHot minutes before it can be restarted  (S08).$NIf it is stopped after RestartInhibit.Wrk_HotRestartOk elapses, it can be restarted immediately (S09).","RTO(Wrk_HotRestartOKT,?,?)","26"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S08:  HOT MOTOR SHORT RUN THEN STOPPED$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been stopped before RestartInhibit.Wrk_HotRestartOk elapsed.$NIt must wait RestartInhibit.Wrk_RestartHot minutes before it can be restarted  (S12).","SUB(Wrk_RestartHotT.PRE,Wrk_RestartHotT.ACC,Wrk_mSecUntilReady)","30"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S09:  HOT MOTOR LONG RUN COOLED  $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has been running long enough to have cooled.$NWhen it is eventually stopped, it can be restarted immediately as a cold motor  (S1).","OTL(Wrk_Ready)","33"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S10:  HOT MOTOR FIRST FAILURE TO START $N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has failed to start for the first time since it was last running properly.$NThe time since the Hot motor stopped is accumulated.   Once it reaches the First Hot Fail time,$Nit can be restarted  (S12).","SUB(Wrk_FirstFailHotT.PRE,Wrk_FirstFailHotT.ACC,Wrk_mSecUntilReady)","36"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S11:  HOT MOTOR SUBSEQUENT FAILURE TO START$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the Hot motor has failed to start at least twice in a row since it was last running properly.$NThe time since the Hot motor stopped is accumulated.   Once it reaches the Subsequent Hot Fail Time,$Nit can be restarted  (S12).","SUB(Wrk_SubsFailHotT.PRE,Wrk_SubsFailHotT.ACC,Wrk_mSecUntilReady)","39"
RCOMMENT,"P_ResInh:AOI","Logic","~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$NState S12:  HOT MOTOR READY TO START$N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$N$NIn this state, the motor is Hot, but ready to start.  $NThe time since the Hot motor stopped is accumulated.   $NRestartInhibit.Wrk_LastColdStart is run so it is properly timed out when changing to S1: Ready to Start, Cold.  $NIf 16 hours have elapsed since the Hot motor was running, the state will be changed to S1: Ready to Start, Cold.  $NThis reflects the fact that the motor has had time to cool off.  $NOtherwise, the logic waits for a Start attempt to change the state to S6: Start Check, Hot.","RTO(Wrk_HotToColdT,?,?)","42"
RCOMMENT,"P_ResInh:AOI","Logic","This is common return point for all states except State 1.$N$N====================================================================================$NSTART TIMERS$N====================================================================================$N$NThese two rungs run the cold start timers used in the $QThree Starts$Q logic when NOT in State 1.","TON(Wrk_SecondColdStartT,?,?)","46"
RCOMMENT,"P_ResInh:AOI","Logic","This code is common for ALL states.$N$N====================================================================================$NVALUES$N====================================================================================$N$NThis rung makes sure that the RestartInhibit.Wrk_mSecsUntilReady value is greater than or equal to zero.$NIf it is not, the register value will be cleared.","CLR(Wrk_mSecUntilReady)","48"
RCOMMENT,"P_ResInh:AOI","Logic","This rung takes the time remaining until the motor is ready to start (in milliseconds), converts it$Nto seconds, then reports it in  minutes : seconds format for display on the HMI or LAWSDAC.","MOD(Wrk_SecUntilReady,60,Val_SecToReady)","49"
RCOMMENT,"P_ResInh:AOI","Logic","Finally, copy out the internal State number so the HMI can display an animated state diagram.","MOV(Wrk_State,Val_State)","50"
RCOMMENT,"P_ResInh:AOI","Prescan","============================================================$NPRESCAN / POWERUP$N============================================================$NOn Prescan, the various timers are reset (all are retentive), and the State$NMachine is set to:$N*  State S01  ( Cold Motor Ready to Start )  if the pump is NOT Running, or$N*  State S03  ( Cold Motor Running )  if the pump is Running.","MOV(3,Wrk_State)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_RunTime:AOI","EnableInFalse","============================================================$NENABLE-IN FALSE HANDLING$N============================================================$NEnableIn False is treated the same as $QMotor Stopped$Q --$NCommands are still processed, $Ntotal run time is held (RTO), the Starts counter is prepared for$Nthe next start (.CU clears on CTU with AFI), and the$NCurrent Run Time is cleared (TON false).$N============================================================$NCOMMAND PROCESSING$N============================================================$NThese rungs handle received Commands.  This object has no Modes and$NCommands are accepted regardless of Mode.  Commands should be$Nrestriceted to authorized personnel (typically at a maintenance level).$N$NPCmd_ClearTotHrs: Program Command to Clear Total Runtime Hours$NMCmd_ClearTotHrs: Maintenance Command to Clear Total Runtime Hours","CLR(Wrk_TotTenths)","0"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","PCmd_ClearStarts: Program Command to Clear Count of Starts$NMCmd_ClearStarts: Maintenance Command to Clear Count of Starts","RES(Wrk_Starts)","1"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","PCmd_ClearMaxHrs: Program Command to Clear Maximum Single Run Hours$NMCmd_ClearMaxHrs: Maintenance Command to Clear Maximum Single Run Hours","CLR(Val_MaxRunHrs)","2"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","============================================================$NENABLE-IN FALSE HANDLING$N============================================================$NEnableIn False is treated the same as $QMotor Stopped$Q --$NTotal run time is held (RTO), the Starts counter is prepared for$Nthe next start (.CU clears on CTU with AFI), and the$NCurrent Run Time is cleared (TON false).","TON(Wrk_CurRunT,?,?)","3"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","============================================================$NREPORT VALUES$N============================================================$N$NThe number of starts is directly reported as an integer Value.","MOV(Wrk_Starts.ACC,Val_Starts)","4"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","The current hours working register is cleared, but the Value is left$Nin place for display until the next run begins.$N$NNOTE: The Maximum Run Hours (high-water of Current Run Hours)$Nis also left in place.","CLR(Wrk_CurHours)","5"
RCOMMENT,"P_RunTime:AOI","EnableInFalse","The Total Running Time is reported as a REAL number of Hours.$N(This will always be in $Qcompleted tenths$Q of an hour, like a mechanical hours counter.)","MUL(Wrk_TotTenths,0.1,Val_TotRunHrs)","6"
RCOMMENT,"P_RunTime:AOI","Logic","============================================================$NP_RunTime:  PROCESS -- RUN TIME AND STARTS$N============================================================$NRevision 0.7-02 Draft:  2009-03-02, DER$NChanged OCmd_xxx to MCmd_xxx (comments, etc.)$N============================================================$NThis Instruction monitors the $QRunning$Q and $QStarting$Q Status of a motor or other device and  provides:$N$N*  Total accumulated run time, in 1/10 hour increments (hour meter)$N*  Total number of starts or start attemptes (count)$N*  Maximum continuous run time for any start (hours)$N* Commands to allow clearing of the totals/maximum$N============================================================$NCOMMAND PROCESSING$N============================================================$NThese rungs handle received Commands.  This object has no Modes and$NCommands are accepted regardless of Mode.  Commands should be$Nrestriceted to authorized personnel (typically at a maintenance level).$N$NPCmd_ClearTotHrs: Program Command to Clear Total Runtime Hours$NMCmd_ClearTotHrs: Maintenance Command to Clear Total Runtime Hours","CLR(Wrk_TotTenths)","0"
RCOMMENT,"P_RunTime:AOI","Logic","PCmd_ClearStarts: Program Command to Clear Count of Starts$NMCmd_ClearStarts: Maintenance Command to Clear Count of Starts","RES(Wrk_Starts)","1"
RCOMMENT,"P_RunTime:AOI","Logic","PCmd_ClearMaxHrs: Program Command to Clear Maximum Single Run Hours$NMCmd_ClearMaxHrs: Maintenance Command to Clear Maximum Single Run Hours","CLR(Wrk_MaxHours)","2"
RCOMMENT,"P_RunTime:AOI","Logic","Clear current run hours if stopped.$NNOTE: Val_CurHours is maintained for display!","CLR(Wrk_CurHours)","3"
RCOMMENT,"P_RunTime:AOI","Logic","============================================================$NACCUMULATE TIMES / STARTS$N============================================================$NThis rung runs the Total (retentive) and Maximum (non-retentive) Run Time$Ntimers and increments the Number of Starts counter  whenever$N the motor/device is Starting or Running (contactor energized...).$N$NNOTE:  The counter only counts on the rising edge of the rung.  As long as$Nthere$'s no delay between Starting going OFF and Running coming ON, this will work fine.","TON(Wrk_CurRunT,?,?)","4"
RCOMMENT,"P_RunTime:AOI","Logic","Note that an RTO timer can only time up to 2G milliseconds, about 28 days.$NA pump will accumulate much more run time.  So the RTO is used to time 1/10 hour,$Nwhich is then added to a count of $QTenths of Hours$Q.  Then the RTO accumulator is reduced by 1/10 hour.$N(The timer doesn$'t lose time because it is not reset and keeps running.)","SUB(Wrk_TotRunT.ACC,360000,Wrk_TotRunT.ACC)","5"
RCOMMENT,"P_RunTime:AOI","Logic","The Maximum Run Time TON is treated the same way.  A motor/device$Ncould potentially run continuously for more than 28 days, so an integer count$Nof (up to 2 billion) hours (almost 245,000 years!) is used.  Should be enough...","SUB(Wrk_CurRunT.ACC,3600000,Wrk_CurRunT.ACC)","6"
RCOMMENT,"P_RunTime:AOI","Logic","============================================================$NREPORT VALUES$N============================================================$N$NThe number of starts is directly reported as an integer Value.","MOV(Wrk_Starts.ACC,Val_Starts)","7"
RCOMMENT,"P_RunTime:AOI","Logic","The Current (continuous) Run Time is reported as a REAL number of Hours.$NThis number includes all fractional hours (timer accumulator / 3,600,000 ms/hr),$Nnot just completed tenths like the total run time below.","CPT(Val_CurRunHrs,Wrk_CurHours+(Wrk_CurRunT.ACC/3600000.0))","8"
RCOMMENT,"P_RunTime:AOI","Logic","If the Current Run Time exceeds the stored Maximum Run Time,$Nupdate the Maximum.$NRegardless, report the Maximum Run Time.$N$NNOTE:  The Wrk_MaxHours register is required to prevent writes to Val_MaxHours$Nfrom improperly overwriting this object$'s state.$N","MOV(Wrk_MaxHours,Val_MaxRunHrs)","9"
RCOMMENT,"P_RunTime:AOI","Logic","The Total Running Time is reported as a REAL number of Hours.$N(This will always be in $Qcompleted tenths$Q of an hour, like a mechanical hours counter.)","MUL(Wrk_TotTenths,0.1,Val_TotRunHrs)","10"
RCOMMENT,"P_RunTime:AOI","Prescan","============================================================$NPOWERUP / PRESCAN HANDLING$N============================================================$NTotal run time, Maximum run time and starts count are retained through$Na power cycle.  Current run time is reset (internally only,$NVal_CurHours is maintained for display!).","CLR(Wrk_CurHours)","0"
RCOMMENT,"P_RunTime:AOI","Prescan","On Prescan, clear any $Qlurking$Q Commands.","OTU(PCmd_ClearStarts)","1"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"P_VSD:AOI","EnableInFalse","============================================================$NOFF-SCAN (EnableIn is False) STATUS$N============================================================$N$NIf this Drive is OFF-SCAN (rung is false or EnableIn is false in FBD), then:$N$NReset the Alarm Timers$NClear the Alarms$NShow the Drive as $QDisabled$Q$NShow the Drive as Running or Stopped, based on the feedback input$NTurn off the Outputs, zero the Speed Reference.$N$NOther data are left in Last State!","OTU(Out_Rev)","0"
RCOMMENT,"P_VSD:AOI","EnableInFalse","The Running Status (Sts_Running) bit shows if the drive is running,$Neven though the drive is Disabled by being on a false rung.","OTE(Sts_Running)","1"
RCOMMENT,"P_VSD:AOI","EnableInFalse","The Stopped Status (Sts_Stopped) bit shows if the drive is stopped,$Neven though the drive is Disabled by being on a false rung.","OTE(Sts_Stopped)","2"
RCOMMENT,"P_VSD:AOI","EnableInFalse","The remaining actual drive status bits are passed through to Status,$Neven though the drive is Disabled by being on a false rung.","OTE(Sts_NotReady)","3"
RCOMMENT,"P_VSD:AOI","EnableInFalse","============================================================$NVALUES PROCESSING$N============================================================$NThis rung outputs instruction Values:$N$NVal_SpeedFdbk (actual running speed), if not in simulation,$Nfrom Input.  If in simulation, simulate accel/decel.","CPT(Val_SpeedFdbk,Cfg_SpeedFdbkEUMin+(Cfg_SpeedFdbkEUMax-Cfg_SpeedFdbkEUMin)/(Cfg_SpeedFdbkRawMax-Cfg_SpeedFdbkRawMin)*(Inp_SpeedFdbk-Cfg_SpeedFdbkRawMin))","4"
RCOMMENT,"P_VSD:AOI","EnableInFalse","This rung publishes the Values for the scaled speed feedback range.$NIf this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$Nthe values are swapped so the the EUMax Value is always greater than the EUMin Value.$NThis makes the HMI bargraph and trend coding easier, and provides values$Nthat can be pinned to the configuration of a PID, so the VSD and PID ranges are in lockstep.","MOV(Cfg_SpeedFdbkEUMax,Val_SpeedFdbkEUMin)","5"
RCOMMENT,"P_VSD:AOI","EnableInFalse","Alarms are turned off when off-scan or out of service, so clear the Notification Level.","CLR(Val_Notify)","7"
RCOMMENT,"P_VSD:AOI","EnableInFalse","$QLurking$Q Operator Commands are cleared, as well as Program Reset.","OTU(PCmd_Reset)","8"
RCOMMENT,"P_VSD:AOI","EnableInFalse","$QLurking$Q Program Commands are cleared if they are set as $QEdge$Q triggered$N(cleared by this object as received).$N(Lurking Acknowledge Commands are left to perform their action.)","OTU(PCmd_IOFaultUninhibit)","9"
RCOMMENT,"P_VSD:AOI","EnableInFalse","Handle $QNO MODE$Q Selection using the standard P_Mode AOI (EnableInFalse Routine, AFI required!).","OTU(Sts_ProgOperLock)","10"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NP_VSD :  PROCESS -- VARIABLE-SPEED DRIVE$N============================================================$NRevision 0.14-01 Draft:  2009-03-02, DER$NChanged OCmd_Disable, OCmd_Enable to MCmds (comments, etc.)$N============================================================$NThis Instruction controls and monitors a Variable-Speed Drive (AC or DC) and provides:$N$N*  Starting, stopping, jogging of drive, setting speed reference and direction$N*  Monitoring of run feedback, display of actual drive status, including accel, decel, direction, speed$N*  Detection of Failure to Start, Failure to Stop, Drive Fault$N*  Monitoring of Permissive conditions to allow starting$N* Monitoring of Interlock conditions to stop / prevent starting$N* Simulation, providing feedback of a working drive while disabling outputs$N* Monitoring of I/O communication faults$N* Alarms for Fail to Start, Fail to Stop, Interlock Trip, Drive Fault, I/O Fault$N* Operation in Hand, Maintenance, Override, Program and Operator Modes$N* $QAvailable$Q status for use by automation logic to know whether Drive$Ncan be controlled by other objects.$N============================================================$NPOWERUP / INVALID STATE HANDLING$N============================================================$NMode states are retained through a power cycle.$NDrive $Qrun$Q request is cleared on first scan, in the rung which unlatches $QWrk_Run$Q, below$N============================================================$NMODE PROCESSING$N============================================================$NThese rungs handle received Mode Inputs and Commands:$N$NNOTE:  Operator Commands for Mode, Alarm are sent directly to the contained P_Mode and P_Alarm AOIs.$N$NInp_Hand: forward the Hand Input directly to the Mode instruction.","OTE(Mode.Inp_Hand)","0"
RCOMMENT,"P_VSD:AOI","Logic","Inp_Ovrd: forward the Override Input directly to the Mode instruction.","OTE(Mode.Inp_Ovrd)","1"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_Acq: Program Command to Acquire ownership","OTU(Mode.PCmd_Acq)","2"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_Rel: Program Command to Release ownership (to OOS)","OTL(Mode.PCmd_Rel)","3"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_Lock: Program Command to Lock ownership in Prog Mode","OTU(Mode.PCmd_Lock)","4"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_Unlock: Program Command to Unlock Mode","OTL(Mode.PCmd_Unlock)","5"
RCOMMENT,"P_VSD:AOI","Logic","Handle Mode Selection using the standard P_Mode AOI","Mode(Mode)","6"
RCOMMENT,"P_VSD:AOI","Logic","This rung handles simple First-Come First-Served Ownership Arbitration.$NIf a requestor supplies a non-zero Owner ID and the current owner is NONE (zero),$NOwnership is assigned to the requesting ID.  When that requestor sets the Owner ID back$Nto zero, Ownership is relinquished back to NONE.","MOV(PSet_Owner,Val_Owner)","7"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NCONFIGURATION$N============================================================$N$NThese rungs get Configuration data (such as timer presets) and distribute as needed.$NNote that some Configuration data are used directly in-place.$N$NEnter the time (in seconds) for the Drive to successfully start before declaring a fault.$NEnter the time (in seconds) for the Drive to successfully stop before declaring a fault.$NEnter the time (in seconds) for the Drive Fault Reset output to be pulsed when a reset is received.$N$NIf the timer preset calcuated wraps negative (more than 2.14... million seconds), then max out the$Nor clear the Timer Preset (as appropriate) and flag it.  Note that a negative timer preset will fault the controller!!!","OTE(Err_Alarm)","8"
RCOMMENT,"P_VSD:AOI","Logic","Enter the time (in seconds) to ramp up the simulated speed feedback when starting in simulation.$NThe same time is used for ramping down when stopping.$N$NHandle timer preset invalid values as above.","MOV(Wrk_AccelT.PRE,Wrk_DecelT.PRE)","9"
RCOMMENT,"P_VSD:AOI","Logic","If the Drive does not even have a Run Feedback input,$Nit cannot be used for Drive feedback checking!","OTU(Cfg_UseRunFdbk)","10"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NRUN FEEDBACK DETERMINATION$N============================================================$NIf the Drive is being simulated or has no run feedback, use the Sim Timers to provide$Na $Qfake$Q feedback signal based on the simulation time to start and time to stop.$N$NIf the Drive is NOT being simulated and it HAS and IS USING a run feedback,$Nuse the state of the run feedback input as the Drive run state.","OTU(Wrk_RunFdbk)","11"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NSETTINGS PROCESSING$N============================================================$NThis rung handles received Settings:$N$NWhen the Mode is Program, use the Program Setting for the Speed Reference.$NWhen the Mode is Operator or Maintenance, use the Operator Setting for the Speed Reference.$NWhen the Mode is Override, use the Override Speed Reference input.","MOV(Inp_OvrdSpeed,Wrk_SpeedRef)","12"
RCOMMENT,"P_VSD:AOI","Logic","Check the selected speed reference against the configured Maximum and Minimum$Nallowed reference limits and ensure the speed is within limits.$NBe sure the speed reference is not negative.  This object supports reversing$Nby command only; negative speed reference is NOT supported!","OTE(Sts_SpeedLimited)","13"
RCOMMENT,"P_VSD:AOI","Logic","Check the selected Output Datalink against its configured Maximum and Minimum$Nallowed limits and ensure the setting is within limits.","MOV(Cfg_OutDatalinkMin,Wrk_OutDatalink)","14"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NCOMMAND HANDLING$N============================================================$NThese rungs receive and handle the Commands for this Drive.$N$NThe Bypass Command bypasses only the Bypassable Permissives and Interlocks.","OTL(Wrk_Bypass)","15"
RCOMMENT,"P_VSD:AOI","Logic","The Check Command enables checking of ALL$NPermissives and Interlocks (cancels the bypass).","OTU(Wrk_Bypass)","16"
RCOMMENT,"P_VSD:AOI","Logic","The Disable Command disables the Drive so it cannot be run.","OTL(Wrk_Disabled)","17"
RCOMMENT,"P_VSD:AOI","Logic","The Enable Command cancels the Disable and allows the Drive to run.","OTU(Wrk_Disabled)","18"
RCOMMENT,"P_VSD:AOI","Logic","The Reverse Command sets drive to run in reverse direction.","OTL(Wrk_Rev)","19"
RCOMMENT,"P_VSD:AOI","Logic","The Forward Command sets drive to run in forward direction.","OTU(Wrk_Rev)","20"
RCOMMENT,"P_VSD:AOI","Logic","These next several rungs, in priority order, determine whether$Nthe drive should be running, jogging or stopped.$N$NIf a Drive START command is received in Operator, Program or Maintenance$NMode, or if in Override Mode and the Override State is RUN, mark the Drive to RUN.$NPermissives must be OK or bypassed to start the Drive (Interlocks are checked below...).$NThe drive must be READY (or in simulation), and the drive can$'t already be jogging.$N(Modes are mutually exclusive, thus handling the priority.)","OTL(Wrk_Run)","21"
RCOMMENT,"P_VSD:AOI","Logic","This rung determines if the Drive SHOULD BE JOGGING.  This is when:$N$N* The Operator is requesting to Jog$N* The Drive is in OPER or MAINT$N* Permissives and Interlocks are OK or bypassed if in OPER$N* Non-Bypassable Interlocks and Permissives are OK,$N* The drive is Ready (or in simulation), AND$N* The drive is not otherwise requested to RUN","OTL(Wrk_Jog)","22"
RCOMMENT,"P_VSD:AOI","Logic","If the drive is changed to Override or Program Mode, or if the Jog command$Ngoes away, stop jogging.","OTU(Wrk_Jog)","23"
RCOMMENT,"P_VSD:AOI","Logic","If a Drive STOP command is received in Operator, Program or Maintenance$NMode, or if in Override Mode and the Override State is STOP,$Nmark the Drive TO STOP (jogging or running).","OTU(Wrk_Jog)","24"
RCOMMENT,"P_VSD:AOI","Logic","Higher Priority:$NIf Interlocks are not OK (Non-Bypassable not OK, or bypassable not OK$Nand not bypassed by Maintenance, Override or Bypass Command), $NOR if the Drive is DISABLED or FAULTED, set it to STOP.$N$NIf we tripped on an Interlock while running or jogging, also issue the Interlock Trip Alarm.","OTU(Wrk_Jog)","25"
RCOMMENT,"P_VSD:AOI","Logic","Highest Priority: HAND always wins:$NIf in Hand, have the Drive follow the RunFeedback.","OTU(Wrk_Run)","26"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NALARM AND DRIVE RESET COMMAND HANDLING$N============================================================$NThis rung processes received Reset Commands from:$N$N1.  Higher-level strategies via Program Command$N2.  The Operator via HMI Operator Command$N3.  Pushbuttons or other block via Input, or$N$NThe reset starts the Reset Timer (One-Shot Off-Delay)$Nto ensure the output is held on for at least the minimum time.","TOF(Wrk_ResetT,?,?)","27"
RCOMMENT,"P_VSD:AOI","Logic","The Hold Timer $Qdone$Q bit comes on immediately and stays on$Nfor the hold time.  If it, or any held-on reset initiator, is TRUE, set the Output.","OTL(DriveFault.PCmd_Reset)","28"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NDrive FAIL TO START ALARMING$N============================================================$NIf the Drive SHOULD BE RUNNING, run a Start Timer to check for Fail to Start, and run a$NSimulation Timer to provide simulated run feedback if needed.","TON(Wrk_AccelT,?,?)","29"
RCOMMENT,"P_VSD:AOI","Logic","If the Start Timer times out and the Drive run feedback (or simulated feedback) never showed up,$Nshow the Drive as $QFAILED TO START$Q and issue an Alarm.","OTE(FailToStart.Inp)","30"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStartAck: Program Command to Acknowledge the Fail to Start Alarm","OTL(FailToStart.PCmd_Ack)","31"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStartInhibit: Program Command to Inhibit the Fail to Start Alarm","OTL(FailToStart.PCmd_Uninhibit)","32"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStartUninhibit: Program Command to Uninhibit the Fail to Start Alarm","OTL(FailToStart.PCmd_Uninhibit)","33"
RCOMMENT,"P_VSD:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","CLR(FailToStart.Cfg_MinDuration)","34"
RCOMMENT,"P_VSD:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(FailToStart)","35"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NDrive FAIL TO STOP ALARMING$N============================================================$NIf the Drive SHOULD BE STOPPED, run a Stop Timer to check for Fail to Stop, and run a$NSimulation Timer to provide simulated run feedback off (stop feedback) if needed.","TON(Wrk_DecelT,?,?)","36"
RCOMMENT,"P_VSD:AOI","Logic","If the Stop Timer times out and the Drive run feedback (or simulated feedback) never showed $Qstopped$Q,$Nshow the Drive as $QFAILED TO STOP$Q and issue an Alarm.","OTE(FailToStop.Inp)","37"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStopAck: Program Command to Acknowledge the Fail to Stop Alarm","OTL(FailToStop.PCmd_Ack)","38"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStopInhibit: Program Command to Inhibit the Fail to Stop Alarm","OTL(FailToStop.PCmd_Uninhibit)","39"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_FailToStopUninhibit: Program Command to Uninhibit the Fail to Stop Alarm","OTL(FailToStop.PCmd_Uninhibit)","40"
RCOMMENT,"P_VSD:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","CLR(FailToStop.Cfg_MinDuration)","41"
RCOMMENT,"P_VSD:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(FailToStop)","42"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NDrive INTERLOCK TRIP ALARMING$N============================================================$NIf the INTERLOCKS NOT OK caused the Drive to stop in the  ---( U )---- Wrk_Run$Nrung above, raise an INTERLOCK TRIP ALARM.","OTE(IntlkTrip.Inp)","43"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IntlkTripAck: Program Command to Acknowledge the Interlock Trip Alarm","OTL(IntlkTrip.PCmd_Ack)","44"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IntlkTripInhibit: Program Command to Inhibit the Interlock Trip Alarm","OTL(IntlkTrip.PCmd_Uninhibit)","45"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IntlkTripUninhibit: Program Command to Uninhibit the Interlock trip Alarm","OTL(IntlkTrip.PCmd_Uninhibit)","46"
RCOMMENT,"P_VSD:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","CLR(IntlkTrip.Cfg_MinDuration)","47"
RCOMMENT,"P_VSD:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(IntlkTrip)","48"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NDRIVE FAULT ALARMING$N============================================================$NIf the DRIVE FAULT Input is TRUE or the DRIVE READY  Input is FALSE,$Nand the drive is not being Simulated, raise a DRIVE FAULT ALARM.","OTE(DriveFault.Inp)","49"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_DriveFaultAck: Program Command to Acknowledge the Drive Fault Alarm","OTL(DriveFault.PCmd_Ack)","50"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_DriveFaultInhibit: Program Command to Inhibit the Drive Fault Alarm","OTL(DriveFault.PCmd_Uninhibit)","51"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_DriveFaultUninhibit: Program Command to Uninhibit the Drive Fault Alarm","OTL(DriveFault.PCmd_Uninhibit)","52"
RCOMMENT,"P_VSD:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","CLR(DriveFault.Cfg_MinDuration)","53"
RCOMMENT,"P_VSD:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(DriveFault)","54"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NI/O FAULT ALARMING$N============================================================$NIf the I/O FAULT input is true and the I/O are not being SIMULATED,\$Nthen there is an I/O Fault.  Raise an Alarm and stop the Drive.","OTE(IOFault.Inp)","55"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IOFaultAck: Program Command to Acknowledge the I/O Fault Alarm","OTL(IOFault.PCmd_Ack)","56"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IOFaultInhibit: Program Command to Inhibit the I/O Fault Alarm","OTL(IOFault.PCmd_Uninhibit)","57"
RCOMMENT,"P_VSD:AOI","Logic","PCmd_IOFaultUninhibit: Program Command to Uninhibit the I/O Fault Alarm","OTL(IOFault.PCmd_Uninhibit)","58"
RCOMMENT,"P_VSD:AOI","Logic","Move Alarm configuration data into the P_Alarm Add-On Instruction:$N$NAckReqd: Alarm must be acknowledged to clear$NResetReqd: Alarm latched in, must be cleared via Reset Command$NMinDuration: Alarm must stay on at least this long to be seen by HMI poll","CLR(IOFault.Cfg_MinDuration)","59"
RCOMMENT,"P_VSD:AOI","Logic","Handle Alarm Processing using the standard P_Alarm AOI","Alarm(IOFault)","60"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NOUTPUT GENERATION$N============================================================$N$NIf the Drive is NOT SIMULATED and NOT OUT OF SERVICE, generate the$Nappropriate outputs for the Drive.$NIf the Drive should be running, is not faulted and not in hardwired control, energice Out_Run.$NAlso, energize Out_Start until we get feedback that the Drive is running.$N$NIf the Drive should be stopped and is not in hardwired control and the feedback shows the Drive$Nis NOT stopped, or if the Drive is Faulted, energize the Out_Stop output to stop the Drive.","OTE(Out_Rev)","62"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NSTATUS GENERATION$N============================================================$N$NThe following rungs generates Status bits for this object.$N$NThese Status bits are a copy of the internal Mode AOI bits for$NHand, Maint, Ovrd, Prog, Oper, and mode Locked.$N$NNOTE for Sts_Maint:  This Drive is in Maintenance (Out Of Service, no able to run normally)$Nif this instruction is on a False Rung (Enable In False).  See the Enable In False Routine.","OTE(Sts_ProgOperLock)","65"
RCOMMENT,"P_VSD:AOI","Logic","This rung handles the reports of all Bad Configuration Status.$NIndividual bits are provided for various status:$NBad Raw Scaling configs$NBad Engineering Units Scaling configs$NBad 1st-Order Filter configs$NBad Alarm Deadband configs$NBad Alarm Minimum Duration configs$N$NThen a summary Bad Config status is provided, simply an OR of the individual bits.$N","OTE(Sts_Err)","66"
RCOMMENT,"P_VSD:AOI","Logic","This rung generates Alarm Status bits by copying the internal Alarm$NAOI bits for Alm, Ack, Sts_Disabled, Sts_Inhibited and Sts_Suppressed$Nfor each of the Alarms: Fail to Start, Fail to Stop, Interlock Trip and I/O Fault.","OTE(Sts_IOFaultSuppressed)","67"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NVALUES PROCESSING$N============================================================$NThis rung outputs instruction Values:$N$NVal_SpeedFdbk (actual running speed), if not in simulation,$Nfrom Input.  If in simulation, simulate accel/decel.","CLR(Val_SpeedFdbk)","68"
RCOMMENT,"P_VSD:AOI","Logic","This rung publishes the Values for the scaled speed feedback range.$NIf this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,$Nthe values are swapped so the the EUMax Value is always greater than the EUMin Value.$NThis makes the HMI bargraph and trend coding easier, and provides values$Nthat can be pinned to the configuration of a PID, so the VSD and PID ranges are in lockstep.","MOV(Cfg_SpeedFdbkEUMax,Val_SpeedFdbkEUMin)","69"
RCOMMENT,"P_VSD:AOI","Logic","Val_SpeedRef (commanded speed)$N$NBased on Mode and Tracking settings, copy the Speed$NReference Value back into the Operator and Program Settings.","MOV(Val_SpeedRef,OSet_SpeedRef)","72"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NNOTIFICATION VALUE$N============================================================$NIndicate the current alarm notification level as the max of any of the alarms:$N0 = none$N2 = info or prompt only$N4 = warning$N6 = exception (equipment impact)$N8 = fault (equipment failure)$NAdd one for any unsuppressed alarm that is not acknowledged (for blink).","MOV(Wrk_Notify,Val_Notify)","73"
RCOMMENT,"P_VSD:AOI","Logic","These rungs generate the Starting, Running, Stopping and Stopped Status bits.$N$NIf the Drive is in HAND and HAS NO RUN FEEDBACK, its state is meaningless;$Nturn off ALL the Sts_xxx states!!!!!$N$NIf the Drive is commanded to run (Output on) and the feedback doesn$'t yet show it running,$Nthe Drive is STARTING.$N$NIf the Drive is commanded to run (Output on) and the feedback shows it running,$Nthe Drive is RUNNING.$N$NIf the Drive is commanded to stoop (Output off) and the feedback still shows it running,$Nthe Drive is STOPPING.$N$NIf the Drive is commanded to stop (Output off) and the feedback shows it has stopped,$Nthe Drive is STOPPED.","OTE(Sts_Jogging)","74"
RCOMMENT,"P_VSD:AOI","Logic","The Drive is AVAILABLE to be run by automation (either in Automatic or in $NProgram Manual) if interlocks are OK, and if stopped, permissives are also OK.","OTE(Sts_Available)","76"
RCOMMENT,"P_VSD:AOI","Logic","If the internal Bypass flag is set, Bypassable Permissives and Interlocks ARE BYPASSED.","OTE(Sts_Bypass)","77"
RCOMMENT,"P_VSD:AOI","Logic","If the internal Disabled flag is set, the Drive is DISABLED.","OTE(Sts_Disabled)","78"
RCOMMENT,"P_VSD:AOI","Logic","The I/O Fault Status is generated by the same conditions that feed the$NI/O Fault Alarm: the I/O Fault input is true and I/O are NOT being SIMULATED.","OTE(Sts_IOFault)","79"
RCOMMENT,"P_VSD:AOI","Logic","============================================================$NOPERATOR COMMAND READIES$N============================================================$N$NReady to Start if in Operator Manual, Stopped, and Permissives and Interlocks are OK.$N$NReady to Stop if in Operator Manual and (Running or Starting).","OTE(Rdy_Stop)","80"
RCOMMENT,"P_VSD:AOI","Logic","Ready to Bypass all Bypassable Permissives and Interlocks if not bypassed.","OTE(Rdy_Bypass)","81"
RCOMMENT,"P_VSD:AOI","Logic","Ready to Check Bypassable Permissives and Interlocks if bypassed.","OTE(Rdy_Check)","82"
RCOMMENT,"P_VSD:AOI","Logic","Ready to Disable Drive if not Disabled","OTE(Rdy_Disable)","83"
RCOMMENT,"P_VSD:AOI","Logic","Ready to Enable Drive if Disabled.","OTE(Rdy_Enable)","84"
RCOMMENT,"P_VSD:AOI","Logic","Forward / Reverse direction can be toggled if the drive is in Operator or Maintenance$Nand is not Disabled, and if configured to allow reversing.","OTE(Rdy_Fwd)","85"
RCOMMENT,"P_VSD:AOI","Logic","This object requires a Reset if the drive is Faulted$Nor if any of its Alarms requires a Reset.","OTE(Rdy_Reset)","86"
RCOMMENT,"P_VSD:AOI","Prescan","============================================================$NPRESCAN (POWERUP) HANDLING$N============================================================$NOn Prescan, set the Ownership to NO OWNER (0).","CLR(Val_Owner)","0"
RCOMMENT,"P_VSD:AOI","Prescan","On powerup (prescan), set drive to stop.","OTU(Wrk_Jog)","1"
RCOMMENT,"P_VSD:AOI","Prescan","$QLurking$Q Operator Commands are cleared, as well as Program Reset.","OTU(PCmd_Reset)","2"
RCOMMENT,"P_VSD:AOI","Prescan","$QLurking$Q Program Commands are cleared if they are set as $QEdge$Q triggered$N(cleared by this object as received).$N(Lurking Acknowledge Commands are left to perform their action.)","OTU(PCmd_IOFaultUninhibit)","3"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"U_FlowPacing:AOI","Logic","Auto Enable","OTE(Sts_Prog)","0"
RCOMMENT,"U_FlowPacing:AOI","Logic","Expose Chemical properties","MOV(Inp_Chemical.OSet_ChemWeightLbPGal,Val_ChemWeightLbPGal)","1"
RCOMMENT,"U_FlowPacing:AOI","Logic","HMI Shutdown Event Alarms$N","OTE(Rdy_Flow)","2"
RCOMMENT,"U_FlowPacing:AOI","Logic","Interlock","OTE(Sts_Intlk)","3"
RCOMMENT,"U_FlowPacing:AOI","Logic","Motor Start Cmd","OTE(Sts_PumpStartReqCmd)","4"
RCOMMENT,"U_FlowPacing:AOI","Logic","Motor 1 Start/Stop Map","OTE(Inp_Pump.PCmd_Stop)","5"
RCOMMENT,"U_FlowPacing:AOI","Logic","Pump Capacity$NPump Capacity (gal/hr) = OIC_PumpCapacity gal/hr * (OIC_Length / 100)","CPT(Val_ExpectedPumpCapacityGPH,OSet_PumpCapacityGPH*(OSet_PumpLength/100))","6"
RCOMMENT,"U_FlowPacing:AOI","Logic","Pump Max Paced Flow$N1 ppm = 8.345 lb/MG","CPT(ExpectedMaxPacedFlowMGD,Val_ExpectedPumpCapacityGPH *24*((Val_ChemWeightLbPGal*(Val_ChemPercentSolution/100))/(8.345*OSet_Dosage)))","7"
RCOMMENT,"U_FlowPacing:AOI","Logic","Flow MGD","CPT(Val_ExpectedMaxPacedFlowMGD,ExpectedMaxPacedFlowMGD)","8"
RCOMMENT,"U_FlowPacing:AOI","Logic","Pump Speed$NPump Speed % =[ Flow (units) / Pump Max Flow (units) ]* 100","CPT(TempSpeed,(Val_PacedFlowMGD / Val_ExpectedMaxPacedFlowMGD )* 100)","9"
RCOMMENT,"U_FlowPacing:AOI","Logic","Speed Output","MOV(0,Inp_Pump.PSet_SpeedRef)","10"
RCOMMENT,"U_FlowPacing:AOI","Logic","Speed AOI Map","MOV(Inp_Pump.PSet_SpeedRef,Val_PumpSpeedRef)","11"
RCOMMENT,"U_FlowPacing:AOI","Logic","Expected Flow Rate Calc","CPT(Val_ExpectedFlowRateGPH,Val_ExpectedPumpCapacityGPH*(Inp_Pump.PSet_SpeedRef/100))","12"
RCOMMENT,"U_FlowPacing:AOI","Logic","Auto Alarm","OTE(Alm_Prog)","13"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"U_WallClock:AOI","Logic","How to determine The day of The week, given The month, day and year?$N$NThe information below was lifted from the from the following web site: http://www.cs.uu.nl/wais/html/na-dir/sci-math-faq/dayofweek.html$N$N   First a brief explanation: in The Gregorian Calendar, over a period of four hundred years, there are 97 leap years and 303 normal years. Each$N normal year, The day of January 1 advances by one; for Each leap year  it advances by two.$N   $N   303 + 97 + 97 = 497 = 7 * 71 $N   $N   as a result, January 1 year N occurs on The same day of The week as January 1 year N + 400. Because The leap year pattern also recurs with a four hundred year cycle, a simple table of four hundred elements, and single modulus, suffices to determine The day of The week (in The$N   Gregorian Calendar), and does it much faster than all The other algorithms proposed. also, Each element takes (in principle) only three bits; The entire table thus takes only 1200 bits; on many computers this will be less than The instructions to do all The complicated calculations proposed or The other algorithms.$N  $N   Incidental Note: Because 7 does not Divide 400, January 1 occurs more frequently on some days than others! Trick your friends! in a cycle of 400 years, January 1 and March 1 occur on The following days with The following frequencies:   $N           Sun      Mon     Tue     Wed     Thu     Fri     Sat$N    Jan 1: 58       56      58      57      57      58      56$N    Mar 1: 58       56      58      56      58      57      57$N$N   Of interest is that (contrary to most initial guesses) The occurrence is not maximally flat.$N   $NIn The Mathematical Gazette, vol. 53,, pp.127-129, it is shown that The 13th of The month is more likely to be a Friday than any other day.The author is a 13 year old S.R.Baxter.$N   $N   The Gregorian Calendar was introduced in 1582 in parts of Europe; it was adopted in 1752 in Great Britain and its colonies, and on various dates in other countries. it replaced The Julian Calendar which has a four-year cycle of leap years; after four years January 1 has advanced by five days. Since 5 is relatively prime to 7, a table of 4 * 7 = 28 elements is necessary for The Julian Calendar.$N   $N   there is still a 3 day over 10,000 years error which The Gregorian Calendar does not take into account. At some Time such a correction will have to be done but your software will probably not last that long!$N   $N   Here is a standard method suitable for mental computation:$N   $N    1. take The last two digits of The year.$N    2. Divide by 4, discarding any fraction.$N    3. Add The day of The month.$N    4. Add The month$'S key value: JFM AMJ JAS OND 144 025 036 146$N    5. Subtract 1 for January or February of a leap year.$N    6. For a Gregorian Date, Add 0 for 1900$'S, 6 for 2000$'S, 4 for 1700$'S, 2 for 1800$'S; for other years, Add or Subtract multiples of 400.$N    7. For a Julian Date, Add 1 for 1700$'S, and 1 for every additional century you go back.$N    8. Add The last two digits of The year.$N    9. Divide by 7 and take The remainder.$N       $N   Now 1 is Sunday, The First day of The week, 2 is Monday, and so on.$N   $N   The following formula, which is for The Gregorian Calendar only, may be more convenient for computer programming. Note that in some programming languages The remainder operation can yield a negative result if given a negative operand, so mod 7 may not translate to a simple remainder.$N   $N   W = (k + floor(2.6m - 0.2) - 2C + Y + floor(Y/4) + floor(C/4)) mod 7 $N   $N   where floor() denotes The integer floor function [This is TRN() in Logix],$Nk is day (1 to 31)$N m is month (1 = March, ..., 10 = December, 11 = Jan, 12 = Feb) Treat Jan & Feb as months of The preceding year$N   C is century (1987 has C = 19)$N   Y is year (1987 has Y = 87 except Y = 86 for Jan & Feb)$N   W is week day (0 = Sunday, ..., 6 = Saturday)$N   $N   Here The century and 400 year corrections are built into The formula. The floor(2.6m - 0.2) term relates to The repetitive pattern that The 30-day months show when March is taken as The First month.$N   $N   The following short C program works for a restricted range, it returns 0 for Monday, 1 for Tuesday, etc.$N   $Ndow(m,d,Y){Y-=m<3;return(Y+Y/4-Y/100+Y/400+$Q-bed=pen+mad.$Q[m]+d)%7;}$N$N   The program appeared was posted by sakamoto@sm.sony.co.jp (Tomohiko sakamoto) on comp.lang.c on March 10th, 1993.$N   $N   a good mnemonic rule to help on The computation of The day of The week is as follows. in any given year The following days come on The same day of The week: 4/4, 6/6, 8/8, 10/10, 12/12  to remember The next four, remember that I work from 9-5 At a 7-11 so 9/5, 5/9, 7/11, 11/7 and The last day of Feb.$N   $N   $Qin 1995 they come on Tuesday. every year this advances one other than leap-years which advance 2. Therefore for 1996 The day will be Thursday, and for 1997 it will be Friday. Therefore ordinarily every 4 years it advances 5 days. there is a minor correction for The century Since The century is a leap year iff The century is divisible by 4. Therefore 2000 is a leap year, but 1900, 1800, and 1700 were not.$Q$N   $N   Even ignoring The pattern over for a period of years this is still useful Since you can generally figure out what day of The week a given Date is  on faster than someone else can look it up with a calender if The calender is not right there. (a useful skill that.)$N   $N References:      $N   Winning Ways for your Mathematical plays. Elwyn R. Berlekamp, John H.  Conway, and Richard k. Guy London ; Toronto : Academic Press, 1982.$N  $N   Mathematical Carnival. Martin Gardner. New York : Knopf, c1975.   $N   Elementary Number Theory and its applications. Kenneth Rosen. Reading,  Mass. ; Don Mills, Ont. : Addison-Wesley Pub. Co., c1993. p. 156.$N   $N   Michael Keith and Tom Craver. The Ultimate Perpetual Calendar? Journal of Recreational Mathematics, 22:4, pp. 280-282, 19","NOP()","0"
RCOMMENT,"U_WallClock:AOI","Logic","**TetraTech**$Nuse local since date time already has time zone info","OTU(OCmd_SetTime)","2"
RCOMMENT,"U_WallClock:AOI","Logic","Get the Controllers real time clock broken down by Year, month, day...microseconds and store in a tag so that the values can be used.$N**TetraTech**$Nuse local since date time already has time zone info","MOV(DOW_Input[5],Val_CurrentSecond)","3"
RCOMMENT,"U_WallClock:AOI","Logic","Extract the two digit year within the century from the 4 digit year value. (Lower two digits)","MOD(DOW_Input[0],100,DOW_Year)","4"
RCOMMENT,"U_WallClock:AOI","Logic","Extract the two digit centurr from the 4 digit year value.  (Upper two digits)$N","TRN(DOW_Temp00,DOW_Century)","5"
RCOMMENT,"U_WallClock:AOI","Logic","For this calculation, the month of March = 1, Dec=10, and Jan/Feb are represented as months 11/12 from the previous year.","SUB(DOW_Year,1,DOW_Year)","6"
RCOMMENT,"U_WallClock:AOI","Logic","Here The century and 400 year corrections are built into The formula. $NThe TRN((2.6 *m) - 0.2) equation relates to the repetitive pattern that the 30-day months show when March is taken as The First month.$N$NNote that the Logix CPU$'s floating point math returns some values slightly different than expected which can change the final results.$NEx: 12 * 2.6 returns 31.199999 rather than 31.2.  To overcome this issue a value of 0.199999 is used in place of the 0.2 in the original equation.","TRN(DOW_Temp02,DOW_Temp03)","7"
RCOMMENT,"U_WallClock:AOI","Logic","Leap Year Adjustment.","TRN(DOW_Temp05,DOW_Temp06)","9"
RCOMMENT,"U_WallClock:AOI","Logic","400 Year Adjustment.","TRN(DOW_Temp07,DOW_Temp08)","10"
RCOMMENT,"U_WallClock:AOI","Logic","Main part of equation... W = (k + floor(2.6m - 0.2) - 2C + Y + floor(Y/4) + floor(C/4)) mod 7$N$NDOW = DOW_Day + TRN((2.6 * DOW_Month) - 0.2) - (2 * DOW_Century) + DOW_Year + TRN(DOW_Year/4) + TRN(DOW_Century/4) MOD 7$N$NDOW_Temp03 =  TRN((2.6 * DOW_Month) - 0.2)$NDOW_Temp04 = (2 * DOW_Century)$NDOW_Temp06 = TRN(DOW_Year/4)$NDOW_Temp08 = TRN(DOW_Century/4)$N$NDOW_Temp14 = (DOW_Day + DOW_Temp03 - DOW_Temp04 + DOW_Year + DOW_Temp06 +  DOW_Temp08) MOD 7$N$N","MOD(DOW_Temp13,7,DOW_Temp14)","11"
RCOMMENT,"U_WallClock:AOI","Logic","MOD operation in some computers differ.  The equation provided in documentation above expects results from the MOD that are different than the actual results that the Logix5000$'s MOD instruction provide for values below the Divisor.  Because of this the logic below makes an adjustment to the the output from the MOD.","ADD(DOW_Temp14,7,DOW_Temp15)","12"
RCOMMENT,"U_WallClock:AOI","Logic","Trim off any fractional value to return the day of the week...","TRN(DOW_Temp15,DOW)","13"
